<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>VM Management</title>
<link rel="stylesheet" href="/spider/adminweb/static/css/xterm.css" />
<script src="/spider/adminweb/static/js/xterm.js"></script>
<!--
Copyright (c) 2017-2019, The xterm.js authors (https://github.com/xtermjs/xterm.js)
Copyright (c) 2014-2016, SourceLair Private Company (https://www.sourcelair.com)
Copyright (c) 2012-2013, Christopher Jeffrey (https://github.com/chjj/)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
-->
<style>
    /* General Styles */
    body {
        font-family: Arial, sans-serif;
        font-size: 12px;
    }
    
    /* Placeholder Styles */
    input::placeholder,
    textarea::placeholder {
        color: #c0c0c0;
        opacity: 1;
    }
    
    .header-container {
        display: flex;
        align-items: flex-end;
    }
    .header-container img {
        margin-right: 10px;
        height: 28px;
    }
    .header-container h1 {
        font-size: 16px;
        margin: 0;
    }
    h2, h3 {
        margin: 10px 0;
    }
    h2 {
        font-size: 16px;
    }
    h3 {
        font-size: 14px;
        margin-left: 1cm;
    }
    .content {
        margin-top: 70px;
    }
    #searchInput {
        width: 190px;
        padding-right: 2.5cm;
    }
    #clearSearch {
        position: absolute;
        right: 0.1cm;
        top: 50%;
        transform: translateY(-50%);
        border: none;
        background-color: transparent;
        cursor: pointer;
    }
    .searchContainer {
        position: relative;
        display: flex;
        align-items: center;
        padding-left: 0.5cm;
    }
    .searchContainer button {
        position: absolute;
        right: 0.5cm;
        top: 50%;
        transform: translateY(-50%);
        border: none;
        background-color: transparent;
        cursor: pointer;
    }
    .fixed-header {
        position: fixed;
        top: 0;
        width: 97%;
        background-color: white;
        z-index: 1000;
        display: flex;
        justify-content: space-between;
        padding: 10px 20px;
        align-items: center;
        box-shadow: 0 4px 6px -6px #222;
    }
    .fixed-action-buttons {
        display: flex;
        align-items: center;
    }
    .fixed-action-buttons button {
        margin-left: 10px;
    }
    .header-with-progress {
        display: flex;
        align-items: center;
        margin-bottom: 0px;
    }
    .progress-bar-container {
        width: 600px;
        margin-left: 10px;
        margin-bottom: 10px;
        height: 22px;
        background-color: #f0f5ff;
        border-radius: 4px;
        overflow: hidden;
        display: none;
        position: relative;
        z-index: 20;
    }
    .progress-bar {
        width: 0;
        height: 100%;
        background-color: #cce6ff;
        border-radius: 4px;
        transition: width 3s ease;
    }
    #timeDisplay {
        position: absolute;
        top: 50%;
        right: 10px;
        transform: translateY(-50%);
        font-size: 14px;
        color: #333;
        z-index: 30;
    }
    .add-button {
        font-size: 14px;
        font-weight: bold;
        margin-left: 1px;
        margin-right: 5px;
        margin-bottom: 10px;
    }
    .mock-add-button {
        margin-right: 1px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
        table-layout: fixed;
        margin-bottom: 0;
    }
    th, td {
        border: 1px solid black;
        padding: 6px;
        position: relative;
    }
    th {
        background-color: #f2f2f2;
        font-size: 14px;
        text-align: center;
    }
    td {
        text-align: left;
    }
    .column-num {
        width: 5%;
        text-align: center;
    }
    .center-align {
        text-align: center;
    }
    .fingerprint {
        width: 30%;
    }
    .check-column {
        width: 5%;
        text-align: center;
    }
    .highlight {
        background-color: #fffab6;
    }
    .misc {
        width: 15%;
    }
    .overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        justify-content: center;
        align-items: center;
    }
    .overlay-content {
        background-color: white;
        padding: 20px;
        border-radius: 5px;
        text-align: left;
        position: relative;
    }
    .tag-container {
        display: inline-block;
        background-color: #e1e1e1;
        border-radius: 3px;
        padding: 2px 5px;
        margin: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        cursor: pointer;
        max-width: calc(100% - 2ch);
    }
    .tag-container:hover {
        background-color: #c1e1c1;
    }
    .form-group {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }
    .form-group label {
        flex: 1;
        text-align: right;
        margin-right: 10px;
    }
    .form-group input, .form-group textarea {
        flex: 2;
    }
    .form-group button {
        margin-left: 10px;
    }
    .tag-input-group {
        display: flex;
        align-items: center;
        flex: 2;
    }
    .tag-input-group input {
        width: 100px;
        flex: 0.5;
        margin-right: 5px;
    }
    .tag-input-group button {
        margin-left: 5px;
    }
    #vm-tag-container {
        display: flex;
        flex-direction: column;
    }
    .tag-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    .tag-overlay-content {
        background-color: white;
        padding: 20px;
        border-radius: 5px;
        text-align: left;
        font-size: 14px;
        max-width: 300px;
        word-wrap: break-word;
        position: relative;
    }
    .overlay-close-btn {
        background-color: #f0f0f0;
        color: #d9534f;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        position: absolute;
        top: 10px;
        right: 10px;
    }
    .overlay-close-btn:hover {
        background-color: #e0e0e0;
    }
    .tag-overlay-content .button-group {
        display: flex;
        justify-content: space-between;
        margin-top: 20px;
    }
    .misc-content {
        max-height: 2.5em;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    .more-btn {
        display: none;
        background-color: transparent;
        border: none;
        color: blue;
        text-decoration: underline;
        cursor: pointer;
    }
    .misc-cell {
        position: relative;
    }
    .misc-cell .more-btn {
        position: absolute;
        right: 5px;
        bottom: 5px;
    }
    .vm-control-buttons a {
        font-size: 12px;
        color: #007bff;
        text-decoration: none;
        margin: 0 5px;
    }
    .vm-control-buttons a:hover {
        text-decoration: underline;
        color: #0056b3;
    }
    .vm-control-buttons input[type="text"] {
        width: 120px;
        padding: 3px;
        font-size: 12px;
        margin-right: 5px;
        border-radius: 4px;
        border: 1px solid #ccc;
    }
    .vm-control-buttons button {
        font-size: 12px;
        padding: 3px 8px;
        border-radius: 4px;
        border: 1px solid #007bff;
        background-color: #007bff;
        color: #fff;
        cursor: pointer;
    }
    .vm-control-buttons button:hover {
        background-color: #0056b3;
        border-color: #0056b3;
    }
    /* New Styles for Table Layout */
    .vm-name-cell {
        text-align: left;
        font-size: 13px;
        font-weight: bold;
    }

    .vm-system-id {
        display: block;
        font-size: 12px;
        font-weight: normal;
        color: #666;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        cursor: pointer;
    }

    .system-id-overlay {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50%;
        max-width: 600px;
        background-color: white;
        border: 1px solid black;
        padding: 20px;
        z-index: 2000;
        border-radius: 5px;
    }

    .system-id-overlay-content {
        position: relative;
        font-family: Arial, sans-serif;
        font-size: 14px;
        word-wrap: break-word;
    }



    .copy-btn {
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
        margin-left: 10px;
    }

    .vm-name-cell .vm-start-time {
        display: block;
        font-size: 12px;
        font-weight: normal;
        color: #666;
    }
    .ssh-access-cell {
        text-align: left;
    }
    .copy-icon-btn {
        background: none;
        border: none;
        cursor: pointer;
        padding: 0;
        transition: transform 0.2s ease, color 0.2s ease;
    }
    .copy-icon-btn:hover {
        transform: scale(1.2);
        color: #007bff;
    }
    .ssh-connect-btn {
        display: inline-block;
        margin-top: 5px;
        color: #007bff;
        cursor: pointer;
        text-decoration: underline;
        font-size: 12px;
    }
    .ssh-terminal-style {
        font-family: 'Courier New', Courier, monospace;
        background-color: #333;
        color: #ffffff;
        padding: 2px 4px;
        border-radius: 4px;
        display: inline-block;
    }
    .snapshot-cell {
        text-align: center;
    }
    .provisioning-info-link {
        cursor: pointer;
        color: #007bff;
        text-decoration: underline;
        font-size: 12px;
    }
    .provisioning-info-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    .provisioning-info-overlay-content {
        position: relative;
        padding-top: 40px;
        background-color: white;
        padding: 20px;
        border-radius: 5px;
        width: 80%;
        max-width: 600px;
        overflow-y: auto;
    }
    .provisioning-info-overlay-content table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
    }
    .provisioning-info-overlay-content h3 {
        font-size: 18px;
        margin-bottom: 15px;
    }
    .provisioning-info-overlay-content table th {
        width: 25%;
        font-size: 14px;
    }
    .provisioning-info-overlay-content table td {
        width: 75%;
        font-size: 14px;
    }
    .bullet-list {
        list-style-type: none;
        padding-left: 0;
    }
    .bullet-list li {
        margin-bottom: 8px;
    }
    .bullet-list li::before {
        content: '‚Ä¢';
        color: black;
        display: inline-block;
        width: 1em;
        margin-right: 5px;
    }

    #miscOverlay .overlay-content {
        font-size: 14px;
        width: 700px;
        position: relative;
        padding-top: 30px;
        line-height: 1.5;
        white-space: pre-wrap;
    }

    .snapshot-cell input[type="text"] {
        width: 50%;
    }
    .snapshot-cell button {
        font-size: 12px;
        padding: 3px 8px;
        border-radius: 4px;
        border: 1px solid #007bff;
        background-color: #007bff;
        color: #fff;
        cursor: pointer;
    }
    .snapshot-cell button:hover {
        background-color: #0056b3;
        border-color: #0056b3;
    }
    .add-btn-container {
        margin-top: 5px;
    }
    .add-btn-container .add-btn {
        background-color: transparent;
        font-size: 14px;
        font-weight: bold;
        border: none;
        color: blue;
        text-decoration: underline;
        cursor: pointer;
    }
    .add-tag-overlay-content {
        background-color: white;
        padding: 20px;
        border-radius: 5px;
        text-align: left;
        font-size: 14px;
        max-width: 300px;
        word-wrap: break-word;
        position: relative;
    }
    .add-tag-overlay-content .tag-overlay-input-group {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }
    .add-tag-overlay-content .tag-overlay-input-group:first-of-type {
        margin-top: 30px;
    }
    .add-tag-overlay-content .tag-overlay-input-group label {
        flex: 1;
        text-align: right;
        margin-right: 10px;
    }
    .add-tag-overlay-content .tag-overlay-input-group input {
        flex: 2;
    }
    .add-tag-overlay-content .tag-overlay-button-group {
        display: flex;
        justify-content: space-between;
        margin-top: 20px;
    }
    .vm-action-btn {
        font-size: 18px !important;
        background: none !important;
        background-color: transparent !important;
        border: none !important;
        cursor: pointer;
        padding: 0 !important;
        margin: 0 !important;
        transition: transform 0.2s ease;
        box-shadow: none !important;
    }
    .vm-action-btn:hover {
        transform: scale(1.2);
    }

    .drop-zone, #privatekey {
        width: 100%;
        border-radius: 4px;
        box-sizing: border-box;
    }
    .drop-zone {
        border: 2px dashed #ddd;
        padding: 20px;
        text-align: center;
        color: #aaa;
        margin-top: 5px;
        margin-bottom: 10px;
        cursor: pointer;
        background-color: #f9f9f9;
    }
    .drop-zone.dragover {
        border-color: #aaa;
        color: #000;
        background-color: #e3e3e3;
    }
    #privatekey {
        background-color: #fff5f5;
        padding: 10px;
        margin-bottom: 20px;
        resize: none; /* Optional: Prevent resizing */
        font-family: inherit;
        font-size: 12px;
    }

    .progress-message {
        background-color: #e6f7ff;
        color: #000;
        padding: 5px;
        border-radius: 4px;
        display: inline-block;
        position: relative;
        overflow: hidden;
    }

    .progress-message::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 100%;
        background-color: #e6f7ff; /* Progress bar color */
        transform: translateX(-100%);
        animation: progress-animation 3s linear infinite;
    }
    .checkbox-wrapper {
        display: block;
        margin-right: 0px; 
    }

    .checkbox-wrapper input[type="checkbox"] {
        margin-right: 5px;
    }

    #dataDiskSelect, #securityGroupSelect {
        border: 1px solid black;
        padding: 10px;
        width: 60%;
        overflow-y: auto;
        overflow-x: auto;
        margin: 0 auto;
        white-space: normal;
        max-height:300px;
    }

    #securityGroupSelect {
        background-color: #f3f3fd;
    }

    #diskSelect p {
        margin: 5px 0;
        color: black;
        font-size: 14px;
    }

    @keyframes progress-animation {
        0% {
            transform: translateX(-100%);
        }
        100% {
            transform: translateX(100%);
        }
    }

    /* Image and Spec Selection Overlays */
    .selection-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
        z-index: 2000;
    }

    .selection-overlay-content {
        background-color: white;
        padding: 20px;
        border-radius: 5px;
        width: 90%;
        max-width: 1200px;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
    }

    .table-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 100;
        font-size: 14px;
        color: #666;
    }

    .table-loading-overlay.active {
        display: flex;
    }

    .filter-section {
        background: linear-gradient(135deg, #f8f9fa 0%, #f1f3f5 100%);
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 25px;
        border: 1px solid #dee2e6;
    }

    .filter-section h3 {
        color: #495057;
        font-size: 14px;
        font-weight: 600;
        margin: 0 0 15px 0;
        padding-bottom: 10px;
        border-bottom: 1px solid #dee2e6;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .filter-section h3::before {
        content: "üîç";
        font-size: 14px;
    }

    .filter-row {
        display: flex;
        gap: 12px;
        margin-bottom: 12px;
        flex-wrap: wrap;
    }

    .filter-item {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-width: 150px;
    }

    .filter-item label {
        font-size: 12px;
        font-weight: 500;
        margin-bottom: 6px;
        color: #495057;
    }

    .filter-item select,
    .filter-item input {
        padding: 6px 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 12px;
        background-color: white;
    }

    .filter-item select:focus,
    .filter-item input:focus {
        outline: none;
        border-color: #80bdff;
    }

    .filter-item select:disabled {
        background-color: #f0f0f0;
        cursor: not-allowed;
    }

    .filter-buttons {
        display: flex;
        gap: 10px;
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #dee2e6;
    }

    .filter-buttons button {
        flex: 1;
        padding: 8px 16px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 12px;
        font-weight: normal;
        cursor: pointer;
        background-color: white;
    }

    .filter-buttons button:first-child {
        background-color: #e7f3ff;
        color: #0066cc;
        border-color: #99ccff;
    }

    .filter-buttons button:first-child:hover {
        background-color: #cce6ff;
        border-color: #66b3ff;
    }

    .filter-buttons button:last-child {
        background-color: white;
        color: #333;
    }

    .filter-buttons button:last-child:hover {
        background-color: #f8f9fa;
    }

    .selection-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
        font-size: 12px;
    }

    .selection-table th,
    .selection-table td {
        border: 1px solid black;
        padding: 2px 6px;
        text-align: center;
        line-height: 1.2;
    }

    .selection-table th {
        background-color: #f2f2f2;
        color: black;
        font-size: 14px;
        text-align: center;
        position: sticky;
        top: 0;
        z-index: 10;
    }

    .selection-table th:first-child,
    .selection-table td:first-child {
        width: 50px;
    }

    .selection-table th:nth-child(2) {
        max-width: 300px;
        text-align: center;
    }

    .selection-table td:nth-child(2) {
        max-width: 300px;
        white-space: normal;
        word-break: break-all;
        text-align: left;
    }

    .selection-table th:nth-child(3),
    .selection-table td:nth-child(3) {
        width: 80px;
    }

    .selection-table th:nth-child(4),
    .selection-table td:nth-child(4) {
        width: 90px;
    }

    .selection-table th:nth-child(5),
    .selection-table td:nth-child(5) {
        width: 160px;
    }

    .selection-table th:nth-child(6),
    .selection-table td:nth-child(6) {
        width: 90px;
    }

    .selection-table th:nth-child(7),
    .selection-table td:nth-child(7) {
        width: 80px;
    }

    .selection-table th:last-child,
    .selection-table td:last-child {
        width: 70px;
    }

    .selection-table tr:hover {
        background-color: #f5f5f5;
        cursor: pointer;
    }

    .selection-table tr.selected {
        background-color: #fffab6;
    }

    .select-btn {
        background-color: white;
        color: black;
        border: 1px solid #ccc;
        padding: 3px 8px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
    }

    .select-btn:hover {
        background-color: #f0f0f0;
    }

    .clear-filter-btn {
        background-color: white;
        color: black;
        border: 1px solid #ddd;
        padding: 1px 4px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 10px;
        font-weight: normal;
        line-height: 1;
    }

    .clear-filter-btn:hover {
        background-color: #f0f0f0;
        border-color: #ccc;
    }

    .loading-message {
        text-align: center;
        padding: 20px;
        font-size: 14px;
        color: #666;
    }

    #image-list-container,
    #spec-list-container {
        position: relative;
        min-height: 400px;
    }

    .no-data-message {
        text-align: center;
        padding: 20px;
        font-size: 14px;
        color: #999;
    }

    .pagination-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 15px;
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 4px;
    }

    .pagination-info-left {
        font-size: 14px;
        color: #495057;
    }

    .pagination-info-left .total-count {
        font-weight: bold;
        color: #212529;
    }

    .pagination-info-left .data-version {
        color: #6c757d;
        font-size: 13px;
    }

    .pagination-nav-right {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .pagination-controls button {
        padding: 6px 12px;
        border: 1px solid #ccc;
        background-color: white;
        color: #495057;
        border-radius: 3px;
        cursor: pointer;
        font-size: 16px;
    }

    .pagination-controls button:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }

    .pagination-controls button:hover:not(:disabled) {
        background-color: #e9ecef;
        border-color: #adb5bd;
    }

    .pagination-page-info {
        font-size: 14px;
        color: #495057;
        min-width: 70px;
        text-align: center;
    }

    .powered-by-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 11px;
        color: #6c757d;
        margin-left: 15px;
        padding: 3px 8px;
        background-color: #f8f9fa;
        border-radius: 4px;
        border: 1px solid #dee2e6;
    }

    .powered-by-badge::before {
        content: "‚ö°";
        font-size: 13px;
    }

    .powered-by-badge a {
        color: #0066cc;
        text-decoration: none;
        font-weight: 500;
    }

    .powered-by-badge a:hover {
        text-decoration: underline;
    }
</style>
</head>
<body>
    <div class="fixed-header">
        <div class="header-container">
            <img src="/spider/adminweb/images/left-menu/vm.png" alt="VM Icon">
            <h1>VM Management</h1>
            <div class="searchContainer">
                <input type="text" id="searchInput" onkeyup="searchKeyword()" placeholder="Search Keyword...">
                <button id="clearSearch" onclick="clearSearchInput()">X</button>
            </div>
        </div>        
        <div class="fixed-action-buttons">
            <input type="checkbox" onclick="toggleSelectAll(this)">
            <button onclick="deleteSelectedVMs()">Delete</button>
        </div>
    </div>

    <div class="content">
        <div class="header-with-progress">
            <button class="add-button" onclick="showOverlay()">+</button>
            <div id="mockButtonsContainer" style="display: flex; align-items: center;"></div>
            <div class="progress-bar-container" id="progressBarContainer">
                <div class="progress-bar" id="progressBar"></div>
                <span id="timeDisplay"></span>
            </div>                       
        </div>
        <table id="vm-table">
            <tr>
                <th class="column-num">#</th>
                <th class="center-align">Name</th>
                <th class="center-align">SSH Access</th>
                <th class="center-align">Status | Actions</th>
                <th class="center-align">Snapshot</th>
                <th class="center-align">Provisioning Info</th>
                <th class="center-align">Tags</th>
                <th class="center-align">Misc</th>
                <th class="check-column">
                    <input type="checkbox" onclick="toggleSelectAll(this)">
                </th>
            </tr>
            {{range $index, $vm := .VMs}}
            <tr>
                <td class="column-num">{{$index | inc}}</td>
                <td class="vm-name-cell">
                    {{$vm.IId.NameId}}<span class="vm-system-id" onclick="showSystemIdOverlay('{{$vm.IId.SystemId}}')">&nbsp;‚Ä¢ {{$vm.IId.SystemId}}</span>
                    <span class="vm-start-time" data-time="{{$vm.StartTime}}"></span>
                </td>    
                <td class="ssh-access-cell">
                    {{if $vm.PublicIP}}
                    ‚Ä¢ Public IP: {{$vm.PublicIP}}
                    <button class="copy-icon-btn" onclick="copyToClipboard('{{$vm.PublicIP}}')">
                        üìã
                    </button>
                    <br> ‚Ä¢ 
                    <div class="ssh-connect-btn" 
                        onclick="openSSHAccess({ vmUserId: '{{$vm.VMUserId}}', publicIP: '{{$vm.PublicIP}}', keyName: '{{$vm.KeyPairIId.NameId}}' });">
                        <span class="ssh-terminal-style">SSH: {{$vm.PublicIP}}</span>
                    </div>
                    {{end}}
                </td>                                      
                <td id="vmcontrol-{{$vm.IId.NameId}}" class="center-align vm-control-buttons">
                    {{if $vm.VMSpecName}}
                        {{if eq (index $.VMStatusMap $vm.IId.NameId) "Running"}}
                            <div style="display: inline-flex; align-items: center;">
                                <span style="margin-right: 8px;">Running &nbsp; |</span>
                                <button class="vm-action-btn" onclick="vmControl('{{$.ConnectionConfig}}', '{{$vm.IId.NameId}}', 'suspend')">‚è∏Ô∏è</button>
                                <button class="vm-action-btn" onclick="vmControl('{{$.ConnectionConfig}}', '{{$vm.IId.NameId}}', 'reboot')">&nbsp;üîÑ</button>
                            </div>
                        {{else if eq (index $.VMStatusMap $vm.IId.NameId) "Suspended"}}
                            <div style="display: inline-flex; align-items: center;">
                                <span style="margin-right: 8px;">Suspended &nbsp; |</span>
                                <button class="vm-action-btn" onclick="vmControl('{{$.ConnectionConfig}}', '{{$vm.IId.NameId}}', 'resume')">‚èØÔ∏è</button>
                            </div>
                        {{else}}
                            <div style="display: inline-flex; align-items: center;">
                                <span style="margin-right: 8px;">{{index $.VMStatusMap $vm.IId.NameId}}</span>
                                
                            </div>
                        {{end}}
                    {{end}}
                </td>                                
                <td class="snapshot-cell">
                    {{if $vm.VMSpecName}}
                    <input type="text" id="snapshot-name-{{$vm.IId.NameId}}" value="myimage-1">
                    <button type="button" onclick="postSnapshotVM('{{$.ConnectionConfig}}', '{{$vm.IId.NameId}}', document.getElementById('snapshot-name-{{$vm.IId.NameId}}').value)">Snap</button>
                    {{end}}
                </td>
                <td class="center-align provisioning-info-cell">
                    {{if $vm.VMSpecName}}
                        <a class="provisioning-info-link" onclick="showProvisioningInfoOverlay({
                            vpcName: '{{$vm.VpcIID.NameId}}',
                            subnetName: '{{$vm.SubnetIID.NameId}}',
                            zone: '{{$vm.Region.Zone}}',
                            securityGroupName: ['{{range $index, $sg := $vm.SecurityGroupIIds}}{{if $index}}, {{end}}{{$sg.NameId}}{{end}}'],
                            keypairName: '{{$vm.KeyPairIId.NameId}}',
                            vmUserId: '{{$vm.VMUserId}}',
                            imageType: '{{$vm.ImageType}}',
                            imageName: '{{$vm.ImageIId.NameId}}',
                            platform: '{{$vm.Platform}}',
                            vmSpecName: '{{$vm.VMSpecName}}',
                            rootDiskType: '{{$vm.RootDiskType}}',
                            rootDiskSize: '{{$vm.RootDiskSize}}',
                            rootDeviceName: '{{$vm.RootDeviceName}}',
                            dataDisks: ['{{range $index, $disk := $vm.DataDiskIIDs}}{{if $index}}, {{end}}{{$disk.NameId}}{{end}}'],
                            networkInterface: '{{$vm.NetworkInterface}}',
                            publicIP: '{{$vm.PublicIP}}',
                            publicDNS: '{{$vm.PublicDNS}}',
                            privateIP: '{{$vm.PrivateIP}}',
                            privateDNS: '{{$vm.PrivateDNS}}'
                        })">View Details</a>                    
                    {{end}}
                </td>
                <td>
                    {{if $vm.VMSpecName}}
                        {{range $tag := $vm.TagList}}
                        <div class="tag-container" onclick="showTagOverlay(event, '{{$tag.Key}}: {{$tag.Value}}', 'VM', '{{$vm.IId.NameId}}')">{{$tag.Key}}: {{$tag.Value}}</div>
                        {{end}}
                        <div class="add-btn-container">
                            <button class="add-btn" onclick="showAddTagOverlay('{{$vm.IId.NameId}}')">+</button>
                        </div>
                    {{end}}
                </td>                
                <td class="center-align misc-cell">
                    <div class="misc-content">{{range $kv := $vm.KeyValueList}}{{$kv.Key}} : {{$kv.Value}}<br>{{end}}
                    </div>
                    {{if $vm.KeyValueList}}
                    <button class="more-btn" onclick="showMiscOverlay(this)" style="display: inline;">more...</button>
                    {{else}}
                    <button class="more-btn" style="display: none;">more...</button>
                    {{end}}
                </td>                              
                <td class="check-column">
                    <input type="checkbox" name="deleteCheckbox" value="{{$vm.IId.NameId}}">
                </td>
            </tr>
            {{end}}
            {{if not .VMs}}
            <tr>
                <td colspan="9" class="center-align">No VMs found for this connection.</td>
            </tr>
            {{end}}
        </table>       
    </div>

    <div id="overlay" class="overlay">
        <div class="overlay-content">
            <button type="button" class="overlay-close-btn" onclick="hideOverlay()">X</button>
            <h2>Add New VM</h2>
            <form id="addVMForm" onsubmit="event.preventDefault(); postVM();">
                <input type="hidden" id="connConfig" value="{{.ConnectionConfig}}">
                <div class="form-group">
                    <label for="vmName">Name:</label>
                    <input type="text" id="vmName" name="vmName" required>
                </div>

                <div class="form-group">
                    <label for="vpcSelect">VPC:</label>
                    <select id="vpcSelect" name="vpcSelect" required onchange="updateSubnets(); loadSecurityGroups();" style="background-color: #f3f3fd;">
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="subnetSelect">Subnet:</label>
                    <select id="subnetSelect" name="subnetSelect" required onchange="updateSelectedSubnetZone()" style="background-color: #f3f3fd;">
                        <option value="">Please select a VPC first.</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="subnetZone">Subnet Zone:</label>
                    <input type="text" id="subnetZone" readonly style="background-color: #f3f3fd; cursor: not-allowed; border: 1px solid #767676; padding: 2px; height: auto; box-sizing: border-box;" placeholder="Select a subnet to see its zone">
                </div>
                
                <div class="form-group">
                    <label for="securityGroupSelect">Security Groups:</label>
                    <div id="securityGroupSelect" name="securityGroupSelect"></div>
                </div>
                
                <div class="form-group">
                    <label for="keypairSelect">KeyPair:</label>
                    <select id="keypairSelect" name="keypairSelect" required style="background-color: #f3f3fd;">
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="imageType">Image Type:</label>
                    <select id="imageType" name="imageType" required onchange="updateImageNameField()" style="background-color: #f7f7e6;">
                        <option value="PublicImage">PublicImage</option>
                        <option value="MyImage">MyImage</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label for="imageName">VM Image Name:</label>
                    <div id="imageNameField" style="display: flex; flex: 2; align-items: center;">
                        <input type="text" id="imageName" name="imageName" required style="background-color: #f7f7e6; flex: 1; border: 1px solid #767676; padding: 2px;" readonly>
                        <button type="button" onclick="showImageSelectionOverlay()" style="margin-left: 5px; min-width: 35px; font-size: 16px;">üîç</button>
                    </div>
                </div>                
                
                <div class="form-group">
                    <label for="vmSpecName">VM Spec Name:</label>
                    <div style="display: flex; flex: 2; align-items: center;">
                        <input type="text" id="vmSpecName" name="vmSpecName" required style="background-color: #f7f7e6; flex: 1; border: 1px solid #767676; padding: 2px;" readonly>
                        <button type="button" onclick="showSpecSelectionOverlay()" style="margin-left: 5px; min-width: 35px; font-size: 16px;">üîç</button>
                    </div>
                </div>                              

                <div class="form-group">
                    <label for="rootDiskType">Root Disk Type:</label>
                    <input type="text" id="rootDiskType" name="rootDiskType" value="default" required>
                </div>

                <div class="form-group">
                    <label for="rootDiskSize">Root Disk Size:</label>
                    <input type="text" id="rootDiskSize" name="rootDiskSize" placeholder="Size in GB">
                </div>              
                
                <div class="form-group">
                    <label for="dataDiskSelect">Data Disk Names:</label>
                    <div id="dataDiskSelect" name="dataDiskSelect"></div>
                </div>
                                
                <div class="form-group">
                    <label for="vmUserId">VM User ID:</label>
                    <input type="text" id="vmUserId" name="vmUserId" placeholder="Administrator" disabled style="background-color: #e9ecef; cursor: not-allowed;">
                </div>
                
                <div class="form-group">
                    <label for="vmUserPasswd">VM User Password:</label>
                    <input type="password" id="vmUserPasswd" name="vmUserPasswd" placeholder="Windows Only">
                </div>

                <div class="form-group" style="padding-left: 100px;">
                    <label for="vmTags">Tags:</label>
                    <div id="vm-tag-container"></div>
                    <button type="button" onclick="addVMTagField()">+</button>
                </div>
                
                <div class="form-group" style="display: flex; justify-content: center; align-items: center; margin-top: 20px;">
                    <label for="vmCount" style="margin-right: 5px;margin-left: 40px;">#:</label>
                    <input type="number" id="vmCount" name="vmCount" class="vm-count" value="1" min="1" max="10" style="width: 50px; margin-right: 10px;">                
                    <button type="submit">Add VM</button>
                    <button type="button" onclick="hideOverlay()" style="margin-left: 10px;">Cancel</button>
                </div>                
            </form>
        </div>
    </div>

    <div id="tag-overlay" class="tag-overlay">
        <div class="tag-overlay-content"></div>
    </div>

    <div id="add-tag-overlay" class="overlay">
        <div class="add-tag-overlay-content"></div>
    </div>

    <div id="miscOverlay" class="overlay">
        <div class="overlay-content">
            <button class="overlay-close-btn" onclick="closeMiscOverlay()">X</button>
            <div id="miscContent"></div>
        </div>
    </div>

    <div id="provisioningInfoOverlay" class="provisioning-info-overlay">
        <div class="provisioning-info-overlay-content"></div>
    </div>  

    <div id="system-id-overlay" class="system-id-overlay">
        <div class="system-id-overlay-content">
            <button class="overlay-close-btn" onclick="closeSystemIdOverlay()">X</button>
            <h2>System ID (Managed by CSP)</h2>
            <p id="fullSystemId"></p>
            <button class="copy-btn" onclick="copySystemId()">üìã</button>
        </div>
    </div>

    <!-- Image Selection Overlay -->
    <div id="image-selection-overlay" class="selection-overlay">
        <div class="selection-overlay-content">
            <button class="overlay-close-btn" onclick="closeImageSelectionOverlay()">X</button>
            <h2>Select VM Image
                <span id="image-mcinsight-badge" class="powered-by-badge" style="display: none;">Powered by <a href="http://mc-insight.cloud-barista.org" target="_blank">MC-Insight</a></span>
            </h2>
            
            <div class="filter-section">
                <h3>Filters</h3>
                <div class="filter-row">
                    <div class="filter-item">
                        <label>Region:</label>
                        <select id="image-filter-region">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label>Zone:</label>
                        <select id="image-filter-zone">
                            <option value="">All Zones</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <div style="display: flex; align-items: flex-start; gap: 3px;">
                            <label>Image Name:</label>
                            <button onclick="clearFilter('image-name')" class="clear-filter-btn" title="Clear Image Name filter">CLR</button>
                        </div>
                        <input type="text" id="image-filter-name" placeholder="Search by name">
                    </div>
                    <div class="filter-item">
                        <label>OS Architecture:</label>
                        <select id="image-filter-arch">
                            <option value="">All</option>
                            <option value="x86_64">x86_64</option>
                            <option value="arm64">arm64</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label>OS Platform:</label>
                        <select id="image-filter-platform">
                            <option value="">All</option>
                            <option value="linux/unix">Linux/UNIX</option>
                            <option value="windows">Windows</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <div style="display: flex; align-items: flex-start; gap: 3px;">
                            <label>OS Distribution:</label>
                            <button onclick="clearFilter('image-distribution')" class="clear-filter-btn" title="Clear OS Distribution filter">CLR</button>
                        </div>
                        <input type="text" id="image-filter-distribution" placeholder="e.g., ubuntu, centos">
                    </div>
                </div>
                <div class="filter-buttons">
                    <button class="select-btn" onclick="applyImageFilters()">Search</button>
                    <button class="select-btn" onclick="resetImageFilters()">Reset</button>
                </div>
            </div>

            <div class="pagination-controls" id="image-pagination" style="display: none;">
                <div class="pagination-info-left">
                    <span class="total-count" id="image-total-info">Total: 0</span>
                    <span class="data-version" id="image-data-version"></span>
                </div>
                <div class="pagination-nav-right">
                    <button onclick="loadImagePage('prev')" id="image-prev-btn">‚óÄ</button>
                    <span class="pagination-page-info" id="image-page-info">1 / 1</span>
                    <button onclick="loadImagePage('next')" id="image-next-btn">‚ñ∂</button>
                </div>
            </div>

            <div id="image-list-container">
                <div class="loading-message">Press Search to load images</div>
            </div>
        </div>
    </div>

    <!-- VM Spec Selection Overlay -->
    <div id="spec-selection-overlay" class="selection-overlay">
        <div class="selection-overlay-content">
            <button class="overlay-close-btn" onclick="closeSpecSelectionOverlay()">X</button>
            <h2>Select VM Spec
                <span id="spec-mcinsight-badge" class="powered-by-badge" style="display: none;">Powered by <a href="http://mc-insight.cloud-barista.org" target="_blank">MC-Insight</a></span>
            </h2>
            
            <div class="filter-section">
                <h3>Filters</h3>
                <div class="filter-row">
                    <div class="filter-item">
                        <label>Region:</label>
                        <select id="spec-filter-region">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label>Zone:</label>
                        <select id="spec-filter-zone">
                            <option value="">All Zones</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <div style="display: flex; align-items: flex-start; gap: 3px;">
                            <label>Spec Name:</label>
                            <button onclick="clearFilter('spec-name')" class="clear-filter-btn" title="Clear Spec Name filter">CLR</button>
                        </div>
                        <input type="text" id="spec-filter-name" placeholder="e.g., t2, c5">
                    </div>
                </div>
                <div class="filter-row" style="display: flex; gap: 15px;">
                    <div style="flex: 0.9; display: flex; gap: 15px; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
                        <div class="filter-item" style="flex: 1;">
                            <div style="display: flex; align-items: flex-start; gap: 3px;">
                                <label>vCPU:</label>
                                <button onclick="clearFilter('vcpu')" class="clear-filter-btn" title="Clear vCPU filter">CLR</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <input type="number" id="spec-filter-min-vcpu" min="1" placeholder="2" style="width: 100%;">
                                <span>~</span>
                                <input type="number" id="spec-filter-max-vcpu" min="1" placeholder="16" style="width: 100%;">
                            </div>
                        </div>
                        <div class="filter-item" style="flex: 1;">
                            <div style="display: flex; align-items: flex-start; gap: 3px;">
                                <label>Memory (MiB):</label>
                                <button onclick="clearFilter('mem')" class="clear-filter-btn" title="Clear Memory filter">CLR</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <input type="number" id="spec-filter-min-mem" min="1" placeholder="4096" style="width: 100%;">
                                <span>~</span>
                                <input type="number" id="spec-filter-max-mem" min="1" placeholder="65536" style="width: 100%;">
                            </div>
                        </div>
                    </div>
                    <div style="flex: 1.1; display: flex; gap: 15px; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
                        <div class="filter-item" style="flex: 1;">
                            <div style="display: flex; align-items: flex-start; gap: 3px;">
                                <label>GPU:</label>
                                <button onclick="clearFilter('gpu')" class="clear-filter-btn" title="Clear GPU filter">CLR</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <input type="number" id="spec-filter-min-gpu" min="1" placeholder="1" style="width: 100%;">
                                <span>~</span>
                                <input type="number" id="spec-filter-max-gpu" min="1" placeholder="8" style="width: 100%;">
                            </div>
                        </div>
                        <div class="filter-item" style="flex: 1;">
                            <div style="display: flex; align-items: flex-start; gap: 3px;">
                                <label>GPU Memory (GB):</label>
                                <button onclick="clearFilter('gpu-mem')" class="clear-filter-btn" title="Clear GPU Memory filter">CLR</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <input type="number" id="spec-filter-min-gpu-mem" min="0" placeholder="8" style="width: 100%;">
                                <span>~</span>
                                <input type="number" id="spec-filter-max-gpu-mem" min="0" placeholder="128" style="width: 100%;">
                            </div>
                        </div>
                        <div class="filter-item" style="flex: 1;">
                            <div style="display: flex; align-items: flex-start; gap: 3px;">
                                <label>GPU Model:</label>
                                <button onclick="clearFilter('gpu-model')" class="clear-filter-btn" title="Clear GPU Model filter">CLR</button>
                            </div>
                            <input type="text" id="spec-filter-gpu-model" placeholder="e.g., a100, t4" style="width: 89%;">
                        </div>
                    </div>
                </div>
                <div class="filter-buttons">
                    <button class="select-btn" onclick="applySpecFilters()">Search</button>
                    <button class="select-btn" onclick="resetSpecFilters()">Reset</button>
                </div>
            </div>

            <div class="pagination-controls" id="spec-pagination" style="display: none;">
                <div class="pagination-info-left">
                    <span class="total-count" id="spec-total-info">Total: 0</span>
                    <span class="data-version" id="spec-data-version"></span>
                </div>
                <div class="pagination-nav-right">
                    <button onclick="loadSpecPage('prev')" id="spec-prev-btn">‚óÄ</button>
                    <span class="pagination-page-info" id="spec-page-info">1 / 1</span>
                    <button onclick="loadSpecPage('next')" id="spec-next-btn">‚ñ∂</button>
                </div>
            </div>

            <div id="spec-list-container">
                <div class="loading-message">Press Search to load VM specs</div>
            </div>
        </div>
    </div>

    <!-- Price Info Overlay -->
    <div id="price-info-overlay" class="selection-overlay">
        <div class="selection-overlay-content" style="max-width: 600px;">
            <button class="overlay-close-btn" onclick="closePriceInfoOverlay()">X</button>
            <h2>VM Price Information</h2>
            
            <div style="padding: 20px; max-height: 600px; overflow-y: auto;">
                <div style="margin: 0 0 25px 0; padding: 12px 15px; background-color: #e3f2fd; border-left: 4px solid #2196f3; border-radius: 4px;">
                    <strong style="color: #1565c0;">Data Source:</strong> 
                    <span style="color: #333;">Price information is sourced from <a href="http://mc-insight.cloud-barista.org/" target="_blank" style="color: #1976d2; text-decoration: underline; font-weight: 500;">MC-Insight</a> API and regularly updated to reflect the latest CSP pricing.</span>
                </div>

                <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                    <tr style="border-bottom: 2px solid #ddd;">
                        <th style="text-align: left; padding: 10px; background-color: #f5f5f5; width: 30%;">Category</th>
                        <th style="text-align: left; padding: 10px; background-color: #f5f5f5;">Details</th>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold; vertical-align: top;">Provided VM Price</td>
                        <td style="padding: 10px;">VM Spec-based OnDemand pricing (USD/Hour)<br><span style="font-size: 12px; color: #666;">‚Äª OS/Software license costs not included</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; font-weight: bold; vertical-align: top;">Supported CSPs</td>
                        <td style="padding: 10px;">AWS, Azure, GCP, Alibaba, Tencent, IBM, NCP</td>
                    </tr>
                </table>

                <div style="margin: 20px 0; padding: 12px 15px; background-color: #fff8e1; border-left: 4px solid #ffa726; border-radius: 4px;">
                    <strong style="color: #e65100;">‚ö† Important:</strong> 
                    <span style="color: #333;">Root Disk and Network costs may or may not be included in the price, depending on the CSP.</span>
                </div>

                <h3 style="margin-top: 30px; margin-left: 0;">Reference: CSP Official Pricing Pages</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                    <tr style="border-bottom: 2px solid #ddd;">
                        <th style="text-align: left; padding: 10px; background-color: #f5f5f5; width: 20%;">CSP</th>
                        <th style="text-align: left; padding: 10px; background-color: #f5f5f5;">Official Pricing Page</th>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold;">AWS</td>
                        <td style="padding: 10px;"><a href="https://aws.amazon.com/ec2/pricing/on-demand/" target="_blank" style="color: #007bff; text-decoration: underline;">EC2 On-Demand Pricing</a></td>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold;">Azure</td>
                        <td style="padding: 10px;"><a href="https://azure.microsoft.com/en-us/pricing/details/virtual-machines/linux/" target="_blank" style="color: #007bff; text-decoration: underline;">Virtual Machines Pricing</a></td>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold;">GCP</td>
                        <td style="padding: 10px;"><a href="https://cloud.google.com/compute/all-pricing" target="_blank" style="color: #007bff; text-decoration: underline;">Compute Engine Pricing</a></td>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold;">Alibaba</td>
                        <td style="padding: 10px;"><a href="https://www.alibabacloud.com/en/product/ecs" target="_blank" style="color: #007bff; text-decoration: underline;">Elastic Compute Service</a></td>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold;">Tencent</td>
                        <td style="padding: 10px;"><a href="https://intl.cloud.tencent.com/pricing/cvm" target="_blank" style="color: #007bff; text-decoration: underline;">Cloud Virtual Machine Pricing</a></td>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold;">IBM</td>
                        <td style="padding: 10px;"><a href="https://www.ibm.com/cloud/virtual-servers/pricing" target="_blank" style="color: #007bff; text-decoration: underline;">Virtual Servers Pricing</a></td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; font-weight: bold;">NCP</td>
                        <td style="padding: 10px;"><a href="https://www.ncloud.com/v2/product/compute/server#pricing" target="_blank" style="color: #007bff; text-decoration: underline;">Server Pricing</a></td>
                    </tr>
                </table>
            </div>
        </div>
    </div>

</body>
<script>
    function vmControl(connConfig, vmName, action) {
        const controlCell = document.getElementById(`vmcontrol-${vmName}`);
        const rowElement = controlCell.parentElement;
        const targetState = action === 'suspend' ? 'Suspended' : 'Running';
        let attempts = 0;
        const maxAttempts = 30;

        // Utility function to update UI based on the action
        function updateUI(message) {
            controlCell.innerHTML = `<span class="progress-message">${message}...</span>`;
        }

        // Utility function to handle server response and start checking status
        function handleResponse(response) {
            const status = response.Status;

            // Update UI based on VM status
            switch (status) {
                case "Suspending":
                    updateUI("VM is suspending");
                    break;
                case "Suspended":
                    updateControlCell("Suspended");
                    break;
                case "Resuming":
                    updateUI("VM is resuming");
                    break;
                case "Running":
                    updateControlCell("Running");
                    break;
                case "Rebooting":
                    updateUI("VM is rebooting");
                    break;
                case "Terminating":
                    controlCell.innerHTML = `<span style="color:gray;">VM is terminating...</span>`;
                    break;
                case "Terminated":
                    controlCell.innerHTML = `<span style="color:red;">VM has been terminated</span>`;
                    break;
                case "Failed":
                    controlCell.innerHTML = `<span style="color:red;">VM action failed</span>`;
                    break;
                case "NotExist":
                    controlCell.innerHTML = `<span style="color:red;">VM does not exist</span>`;
                    break;
                default:
                    controlCell.innerHTML = `<span style="color:orange;">Unexpected status: ${status}</span>`;
                    break;
            }

            // Start checking the status after initiating the action
            checkVMStatus();
        }

        // Function to update the entire row with the latest VM information
        function updateVMRow(status) {
            fetch(`/spider/vm/${vmName}?ConnectionName=${connConfig}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(vmData => {
                const sshAccessCell = rowElement.querySelector('.ssh-access-cell');
                const provisioningInfoCell = rowElement.querySelector('.provisioning-info-cell');
                const miscCell = rowElement.querySelector('.misc-cell .misc-content');

                // Update SSH Access
                sshAccessCell.innerHTML = `
                    ‚Ä¢ Public IP: ${vmData.PublicIP}
                    <button class="copy-icon-btn" onclick="copyToClipboard('${vmData.PublicIP}')">üìã</button>
                    <br> ‚Ä¢ 
                    <div class="ssh-connect-btn" 
                        onclick="if ('${vmData.PublicIP}') { openSSHAccess({ vmUserId: '${vmData.VMUserId}', publicIP: '${vmData.PublicIP}', keyName: '${vmData.KeyPairIId.NameId}' }); }">
                        <span class="ssh-terminal-style">SSH: ${vmData.PublicIP}</span>
                    </div>
                `;

                // Update Provisioning Info
                provisioningInfoCell.innerHTML = `
                    <a class="provisioning-info-link" onclick="showProvisioningInfoOverlay({
                        vpcName: '${vmData.VpcIID.NameId}',
                        subnetName: '${vmData.SubnetIID.NameId}',
                        zone: '${vmData.Region.Zone}',
                        securityGroupName: ['${vmData.SecurityGroupIIds.map(sg => sg.NameId).join("', '")}'],
                        keypairName: '${vmData.KeyPairIId.NameId}',
                        vmUserId: '${vmData.VMUserId}',
                        imageType: '${vmData.ImageType}',
                        imageName: '${vmData.ImageIId.NameId}',
                        platform: '${vmData.Platform}',
                        vmSpecName: '${vmData.VMSpecName}',
                        rootDiskType: '${vmData.RootDiskType}',
                        rootDiskSize: '${vmData.RootDiskSize}',
                        rootDeviceName: '${vmData.RootDeviceName}',
                        dataDisks: ['${vmData.DataDiskIIDs.map(disk => disk.NameId).join("', '")}'],
                        networkInterface: '${vmData.NetworkInterface}',
                        publicIP: '${vmData.PublicIP}',
                        publicDNS: '${vmData.PublicDNS}',
                        privateIP: '${vmData.PrivateIP}',
                        privateDNS: '${vmData.PrivateDNS}'
                    })">View Details</a>
                `;

                // Update Misc Information
                miscCell.innerHTML = vmData.KeyValueList.map(kv => `${kv.Key} : ${kv.Value}`).join('<br>');

                // Update Status | Actions Field with the latest status
                updateControlCell(status);
            })
            .catch(() => {
                controlCell.innerHTML = `<span style="color:red;">Failed to update row</span>`;
            });
        }

        // Function to update the Status | Actions cell based on the status
        function updateControlCell(status) {
            if (status === 'Running') {
                controlCell.innerHTML = `
                    <div style="display: inline-flex; align-items: center;">
                        <span style="margin-right: 8px;">Running &nbsp; |</span>
                        <button class="vm-action-btn" onclick="vmControl('${connConfig}', '${vmName}', 'suspend')">‚è∏Ô∏è</button>
                        <button class="vm-action-btn" onclick="vmControl('${connConfig}', '${vmName}', 'reboot')">&nbsp;üîÑ</button>
                    </div>
                `;
            } else if (status === 'Suspended') {
                controlCell.innerHTML = `
                    <div style="display: inline-flex; align-items: center;">
                        <span style="margin-right: 8px;">Suspended &nbsp; |</span>
                        <button class="vm-action-btn" onclick="vmControl('${connConfig}', '${vmName}', 'resume')">‚èØÔ∏è</button>
                    </div>
                `;
            } else {
                controlCell.innerHTML = `
                    <div style="display: inline-flex; align-items: center;">
                        <span style="margin-right: 8px;">${status} |</span>
                    </div>
                `;
            }
        }

        // Function to periodically check the VM status
        function checkVMStatus() {
            attempts++;

            fetch(`/spider/vmstatus/${vmName}?ConnectionName=${connConfig}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                const status = data.Status;
                if (status === targetState) {
                    // Update the entire row with the latest data
                    updateVMRow(status);
                } else if (attempts < maxAttempts) {
                    setTimeout(checkVMStatus, 1000); // Retry after 1 second
                } else {
                    controlCell.innerHTML = `<span style="color:orange;">Still processing, please try refreshing manually.</span>`;
                }
            })
            .catch(() => {
                controlCell.innerHTML = `<span style="color:red;">Failed to update status</span>`;
            });
        }

        // Set message based on the action
        const actionMessages = {
            suspend: "Suspending",
            resume: "Resuming",
            reboot: "Rebooting"
        };
        updateUI(actionMessages[action] || "Processing");

        // Send request to the server
        fetchWithProgress(`/spider/controlvm/${vmName}?action=${action}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ ConnectionName: connConfig })
        })
        .then(response => response.json())
        .then(handleResponse)
        .catch(() => {
            controlCell.innerHTML = `<span style="color:red;">Failed to execute action</span>`;
        });
    }



    function postSnapshotVM(connConfig, vmName, snapshotName) {
        const snapshotData = {
            ConnectionName: connConfig,
            ReqInfo: {
                Name: snapshotName,
                SourceVM: vmName
            }
        };

        fetchWithProgress(`/spider/myimage`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(snapshotData)
        })
        .then(response => response.json().then(data => ({ data, ok: response.ok })))
        .then(({ data, ok }) => {
            if (!ok || data.message) {
                const errorMessage = data.message || "Unknown error";
                showError(`VM Name: ${vmName}: Failed to create snapshot: ${errorMessage}`);
            } else if (data.IId && data.IId.NameId) {
                alert(`Snapshot "${data.IId.NameId}" created successfully. You can check the result in MyImage.`);
            }
        })
        .catch(error => {
            showError(`VM Name: ${vmName}: Error creating snapshot: ${error.message}`);
        });

    }

    function deleteSelectedVMs() {
        const connConfig = document.getElementById('connConfig').value;
        const checkboxes = document.querySelectorAll('input[name="deleteCheckbox"]:checked');
        if (checkboxes.length === 0) {
            alert("Please select VMs to delete.");
            return;
        }

        if (!confirm("Are you sure you want to delete the selected VMs?")) {
            return;
        }

        const deletePromises = Array.from(checkboxes).map(checkbox => {
            const vmName = checkbox.value;
            const data = {
                ConnectionName: connConfig
            };

            return fetchWithProgress(`/spider/vm/${vmName}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            }).then(response => {
                if (!response.ok) {
                    return response.json().then(error => {
                        throw new Error(error.message);
                    });
                }
                return response.json();
            });
        });

        Promise.all(deletePromises)
            .then(() => location.reload())
            .catch(error => {
                alert("Error deleting VMs: " + error.message);
            });
    }

    function toggleSelectAll(source) {
        const checkboxes = document.querySelectorAll('input[name="deleteCheckbox"]');
        for (const checkbox of checkboxes) {
            checkbox.checked = source.checked;
        }
    }

    function deleteVM(vmName) {
        const connConfig = document.getElementById('connConfig').value;
        const data = {
            ConnectionName: connConfig
        };

        fetchWithProgress(`/spider/vm/${vmName}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        })
        .then(response => response.json())
        .then(data => {
            if (data.Result === "true") {
                location.reload();
            } else {
                showError("Failed to delete VM: " + (data.Message || "Unknown error"), "VM Name: " + vmName);
            }
        })
        .catch(error => {
            showError("Error deleting VM: " + error.message, "VM Name: " + vmName);
        });
    }

    function postVM() {
        const vmCount = parseInt(document.getElementById('vmCount').value);
        if (vmCount > 1) {
            if (!confirm(`Are you sure you want to create ${vmCount} VMs?`)) {
                return;
            }
        }

        // Validate that at least one security group is selected
        const selectedSecurityGroups = document.querySelectorAll('#securityGroupSelect input[type="checkbox"]:checked');
        if (selectedSecurityGroups.length === 0) {
            alert('Please select at least one Security Group.');
            return;
        }

        const connConfig = document.getElementById('connConfig').value;

        const vmPromises = Array.from({ length: vmCount }).map((_, index) => {
            const vmName = vmCount > 1 ? `${document.getElementById('vmName').value}-${index + 1}` : document.getElementById('vmName').value;

            const requestData = {
                ConnectionName: connConfig,
                ReqInfo: {
                    Name: vmName,
                    ImageType: document.getElementById('imageType').value,
                    ImageName: document.getElementById('imageName').value,
                    VMSpecName: document.getElementById('vmSpecName').value,
                    VPCName: document.getElementById('vpcSelect').options[document.getElementById('vpcSelect').selectedIndex].text.split(' ')[0],
                    SubnetName: document.getElementById('subnetSelect').value,
                    SecurityGroupNames: Array.from(document.querySelectorAll('#securityGroupSelect input[type="checkbox"]:checked')).map(checkbox => checkbox.value),
                    RootDiskType: document.getElementById('rootDiskType').value,
                    RootDiskSize: document.getElementById('rootDiskSize').value || undefined,  
                    DataDiskNames: Array.from(document.querySelectorAll('#dataDiskSelect input[type="checkbox"]:checked')).map(checkbox => checkbox.value),    
                    KeyPairName: document.getElementById('keypairSelect').value,
                    VMUserId: document.getElementById('vmUserId').value,
                    VMUserPasswd: document.getElementById('vmUserPasswd').value,
                    TagList: Array.from(document.querySelectorAll('.vm-tag-input')).map(tagInput => ({
                        Key: tagInput.querySelector('.vm-tag-key').value.trim(),
                        Value: tagInput.querySelector('.vm-tag-value').value.trim()
                    }))
                }
            };

            return fetchWithProgress('/spider/vm', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            })
            .then(response => response.json().then(data => ({ data, ok: response.ok })))
            .then(({ data, ok }) => {
                if (!ok || data.message) {
                    const errorMessage = data.message || "Unknown error";
                    showError(`VM Name: ${vmName}: Failed to create VM: ${errorMessage}`);
                    return { success: false, vmName };
                } else if (data.IId && data.IId.NameId) {
                    console.log(`VM "${data.IId.NameId}" created successfully.`);
                    return { success: true, vmName };
                }
            })
            .catch(error => {
                showError(`VM Name: ${vmName}: Error creating VM: ${error.message}`);
                return { success: false, vmName };
            });
        });

        Promise.all(vmPromises)
            .then((results) => {
                const successCount = results.filter(r => r && r.success).length;
                if (successCount > 0) {
                    location.reload();
                }
                // If all failed, keep the overlay open for retry
            })
            .catch(error => {
                showError("Error creating VMs: " + error.message, "Multiple VMs");
            });
    }


    function searchKeyword() {
        let input, filter, table, tr, td, i;
        input = document.getElementById('searchInput');
        filter = input.value.toUpperCase().trim(); 
        if (!filter) {
            clearSearchInput();
            return;
        }

        table = document.getElementById('vm-table');
        tr = table.getElementsByTagName('tr');
        
        for (i = 1; i < tr.length; i++) {
            for (let j = 0; j < tr[i].cells.length; j++) {
                td = tr[i].cells[j];
                if (td) {
                    let txtValue = td.textContent || td.innerText;
                    if (txtValue.toUpperCase().indexOf(filter) > -1) {
                        td.classList.add('highlight');
                    } else {
                        td.classList.remove('highlight');
                    }
                }
            }
        }
    }

    function clearSearchInput() {
        document.getElementById("searchInput").value = "";
        let table = document.getElementById('vm-table');
        let tr = table.getElementsByTagName('tr');
        for (let i = 1; i < tr.length; i++) {
            for (let j = 0; j < tr[i].cells.length; j++) {
                tr[i].cells[j].classList.remove('highlight');
            }
        }
    }

    function showOverlay() {
        document.getElementById('overlay').style.display = 'flex';
        document.addEventListener('keydown', handleOverlayEsc);
        clearFormFields();
    }

    function clearFormFields() {
        // Save current zone value before reset
        const subnetZoneInput = document.getElementById('subnetZone');
        const currentZone = subnetZoneInput ? subnetZoneInput.value : '';
        
        // Clear form fields
        document.getElementById('addVMForm').reset();

        // Restore zone value after reset
        if (subnetZoneInput && currentZone) {
            subnetZoneInput.value = currentZone;
        }

        const region = '{{.RegionName}}';
        const vmNameInput = document.getElementById('vmName');
        vmNameInput.value = `${region}-vm-${Math.random().toString(36).substring(2, 5)}`;
        loadSecurityGroups();
        const tagContainer = document.getElementById('vm-tag-container');
        while (tagContainer.firstChild) {
            tagContainer.removeChild(tagContainer.firstChild);
        }
        
    }

    function hideOverlay() {
        document.getElementById('overlay').style.display = 'none';
        document.removeEventListener('keydown', handleOverlayEsc);
        clearFormFields();
    }

    function handleOverlayEsc(event) {
        if (event.key === "Escape") {
            // Don't close Add New VM overlay if Image/Spec/Price selection overlay is open
            const imageOverlay = document.getElementById('image-selection-overlay');
            const specOverlay = document.getElementById('spec-selection-overlay');
            const priceOverlay = document.getElementById('price-info-overlay');
            
            if ((imageOverlay && imageOverlay.style.display === 'flex') ||
                (specOverlay && specOverlay.style.display === 'flex') ||
                (priceOverlay && priceOverlay.style.display === 'flex')) {
                return; // Let the selection overlay handle the ESC key
            }
            
            hideOverlay();
        }
    }

    function addVMTagField() {
        const tagContainer = document.getElementById('vm-tag-container');
        
        const tagInput = document.createElement('div');
        tagInput.className = 'vm-tag-input tag-input-group';
        tagInput.innerHTML = `
            <input type="text" class="vm-tag-key" placeholder="Key" required>
            <input type="text" class="vm-tag-value" placeholder="Value" required>
            <button type="button" onclick="removeTagField(this)">-</button>
        `;
        tagContainer.appendChild(tagInput);
    }

    function removeTagField(button) {
        button.parentElement.remove();
    }

    function showTagOverlay(event, tag, resourceType, resourceName) {
        event.stopPropagation();

        const tagOverlay = document.getElementById('tag-overlay');
        const tagOverlayContent = document.querySelector('.tag-overlay-content');

        tagOverlayContent.innerHTML = `
            <button class="overlay-close-btn" onclick="closeTagOverlay()">X</button>
            <p>${tag}</p>
            <div class="button-group">
                <button onclick="deleteTag('${tag}', '${resourceType}', '${resourceName}')">Delete</button>
                <button onclick="closeTagOverlay()">Cancel</button>
            </div>
        `;

        tagOverlay.style.display = 'flex';

        document.addEventListener('keydown', handleTagOverlayEsc);
        document.addEventListener('click', handleClickOutsideOverlay);
    }

    function closeTagOverlay() {
        const tagOverlay = document.getElementById('tag-overlay');
        tagOverlay.style.display = 'none';
        document.removeEventListener('keydown', handleTagOverlayEsc);
        document.removeEventListener('click', handleClickOutsideOverlay);
    }

    function handleTagOverlayEsc(event) {
        if (event.key === "Escape") {
            closeTagOverlay();
        }
    }

    function handleClickOutsideOverlay(event) {
        const tagOverlay = document.getElementById('tag-overlay');
        if (tagOverlay.style.display === 'flex' && !tagOverlay.contains(event.target)) {
            closeTagOverlay();
        }
    }

    function showError(message, title) {
        alert(`${title}: ${message}`);
    }

    function deleteTag(tag, resourceType, resourceName) {
        const connConfig = document.getElementById('connConfig').value;
        const [tagKey, tagValue] = tag.split(': ');

        const data = {
            ConnectionName: connConfig,
            ReqInfo: {
                ResourceType: resourceType.trim(),
                ResourceName: resourceName.trim()
            }
        };

        fetchWithProgress(`/spider/tag/${tagKey.trim()}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        }).then(response => {
            if (!response.ok) {
                return response.json().then(error => {
                    throw new Error(error.message);
                });
            }
            return response.json();
        }).then(() => {
            closeTagOverlay();
            location.reload();
        }).catch(error => {
            showError("Error deleting tag: " + error.message, "Resource Name: " + resourceName);
        });
    }

    document.addEventListener('click', (event) => {
        const tagOverlay = document.getElementById('tag-overlay');
        if (tagOverlay && tagOverlay.style.display === 'flex' && !tagOverlay.contains(event.target)) {
            closeTagOverlay();
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        fetch('/spider/connectionconfig/{{.ConnectionConfig}}')
            .then(response => response.json())
            .then(data => {
                const currentProvider = data.ProviderName;
                if (currentProvider === 'MOCK') {
                    const mockButtonsContainer = document.getElementById('mockButtonsContainer');

                    const button10 = document.createElement('button');
                    button10.className = 'mock-add-button add-button';
                    button10.textContent = '+10';
                    button10.onclick = () => createMultipleVMs(10);

                    const button50 = document.createElement('button');
                    button50.className = 'mock-add-button add-button';
                    button50.textContent = '+50';
                    button50.onclick = () => createMultipleVMs(50);

                    mockButtonsContainer.appendChild(button10);
                    mockButtonsContainer.appendChild(button50);
                }
            })
            .catch(error => {
                showError("Error loading connection configuration: " + error.message, "Connection Config Error");
            });
    });

    function createMultipleVMs(count) {
        const connConfigElement = document.getElementById('connConfig').value;

        const fetchVPCAndSubnet = () => {
            return fetch(`/spider/vpc?ConnectionName=${encodeURIComponent(connConfigElement)}`)
                .then(response => response.json())
                .then(data => {
                    if (data.vpc && data.vpc.length > 0) {
                        const firstVPC = data.vpc[0];
                        const vpcName = firstVPC.IId.NameId;
                        const subnetName = firstVPC.SubnetInfoList[0].IId.NameId;
                        return { vpcName, subnetName };
                    } else {
                        throw new Error('No VPCs available.');
                    }
                })
                .catch(error => {
                    console.error('Error fetching VPCs and Subnets:', error);
                    return { vpcName: '', subnetName: '' };
                });
        };

        const fetchFirstResource = (resourceType, urlPath) => {
            return fetch(`/spider/${urlPath}?ConnectionName=${encodeURIComponent(connConfigElement)}`)
                .then(response => response.json())
                .then(data => {
                    if (data[resourceType] && data[resourceType].length > 0) {
                        return data[resourceType][0].IId.NameId;
                    } else {
                        throw new Error(`No ${resourceType} available.`);
                    }
                })
                .catch(error => {
                    console.error(`Error fetching ${resourceType}:`, error);
                    return '';
                });
        };

        Promise.all([
            fetchVPCAndSubnet(),
            fetchFirstResource('securitygroup', 'securitygroup'),
            fetchFirstResource('keypair', 'keypair')
        ])
        .then(([{ vpcName, subnetName }, securityGroupName, keypairName]) => {
            if (!vpcName || !subnetName || !securityGroupName || !keypairName) {
                showError("Missing required resources for VM creation.", "Resource Error");
                throw new Error("Missing required resources for VM creation.");
            }

            const vmPromises = Array.from({ length: count }).map(() => {
                const vmName = `vm-${Math.random().toString(36).substring(2, 7)}`;
                const imageType = 'PublicImage';
                const imageName = 'mock-vmimage-01';
                const vmSpecName = 'mock-vmspec-01';
                const rootDiskType = 'default';
                const rootDiskSize = '50';

                const requestData = {
                    ConnectionName: connConfigElement,
                    ReqInfo: {
                        Name: vmName,
                        ImageType: imageType,
                        ImageName: imageName,
                        VMSpecName: vmSpecName,
                        VPCName: vpcName,
                        SubnetName: subnetName,
                        SecurityGroupNames: [securityGroupName],
                        RootDiskType: rootDiskType,
                        RootDiskSize: rootDiskSize,
                        DataDiskNames: [],
                        KeyPairName: keypairName,
                        TagList: []
                    }
                };

                return fetchWithProgress('/spider/vm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                }).then(response => {
                    if (!response.ok) {
                        return response.json().then(error => {
                            throw new Error(error.message);
                        });
                    }
                    return response.json();
                });
            });

            return Promise.all(vmPromises);
        })
        .then(() => location.reload())
        .catch(error => {
            showError("Error creating VMs: " + error.message, "VM Creation Error");
        });
    }

    function fetchWithProgress(url, options) {
        showProgressBar();
        
        const startTime = Date.now();
        const timerInterval = 500; 
        let timerId = setInterval(() => {
            const elapsedTime = (Date.now() - startTime) / 1000;
            const timeDisplay = document.getElementById('timeDisplay');
            timeDisplay.textContent = `${(Math.floor(elapsedTime * 2) / 2).toFixed(1)}s`;
        }, timerInterval);

        return fetch(url, options)
            .then(response => {
                clearInterval(timerId); 
                hideProgressBar();
                return response;
            })
            .catch(error => {
                clearInterval(timerId);
                hideProgressBar();
                throw error;
            });
    }

    function showProgressBar() {
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBar = document.getElementById('progressBar');
        progressBar.style.width = '0%';
        progressBarContainer.style.display = 'block';

        setTimeout(() => {
            progressBar.style.width = '100%';
        }, 100);
    }

    function hideProgressBar() {
        const progressBarContainer = document.getElementById('progressBarContainer');
        setTimeout(() => {
            progressBarContainer.style.display = 'none';
            document.getElementById('timeDisplay').textContent = ''; 
        }, 500);
    }

    document.addEventListener('DOMContentLoaded', function() {
        const connConfigElement = document.getElementById('connConfig');

        if (connConfigElement) {
            loadVPCs();
            loadKeyPairs();
            //loadSecurityGroups();
        } else {
            console.error("Error: 'connConfig' element not found.");
        }
    });

    function loadVPCs() {
        const connConfigElement = document.getElementById('connConfig');
        
        if (!connConfigElement) {
            console.error("Error: 'connConfig' element is null. Ensure that the element is present in the DOM.");
            return;
        }

        const connConfig = connConfigElement.value;
        const vpcSelect = document.getElementById('vpcSelect');

        if (!vpcSelect) {
            console.error("Error: 'vpcSelect' element is null. Ensure that the element is present in the DOM.");
            return;
        }

        fetch(`/spider/vpc?ConnectionName=${connConfig}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            
            vpcSelect.innerHTML = ''; // Clear existing options

            if (data.vpc && data.vpc.length > 0) {
                data.vpc.forEach((vpc, index) => {
                    const option = document.createElement('option');
                    option.value = JSON.stringify(vpc.SubnetInfoList);
                    option.textContent = `${vpc.IId.NameId} (${vpc.IPv4_CIDR})`;
                    vpcSelect.appendChild(option);
                });
                
                updateSubnets(); // Update subnets based on selected VPC
                loadSecurityGroups(); // Load security groups based on selected VPC
            } else {
                vpcSelect.innerHTML = '<option>No VPCs. Create one.</option>';
            }
        })
        .catch(error => {
            console.error('Error loading VPCs: ' + error.message);
        });
    }

    function updateSubnets() {
        const vpcSelect = document.getElementById('vpcSelect');
        const subnetSelect = document.getElementById('subnetSelect');
        const subnetZoneInput = document.getElementById('subnetZone');

        subnetSelect.innerHTML = '';
        
        if (!vpcSelect.value) {
            subnetSelect.innerHTML = '<option>Please select a VPC first.</option>';
            if (subnetZoneInput) subnetZoneInput.value = '';
            return;
        }
        
        let selectedSubnets;
        try {
            selectedSubnets = JSON.parse(vpcSelect.value);
        } catch (e) {
            subnetSelect.innerHTML = '<option>Error loading subnets</option>';
            if (subnetZoneInput) subnetZoneInput.value = '';
            return;
        }

        if (selectedSubnets && Array.isArray(selectedSubnets) && selectedSubnets.length > 0) {
            selectedSubnets.forEach((subnet, index) => {
                const option = document.createElement('option');
                option.value = subnet.IId.NameId;
                option.textContent = `${subnet.IId.NameId} (${subnet.IPv4_CIDR})`;
                
                // Set zone as data attribute
                if (subnet.Zone) {
                    option.setAttribute('data-zone', subnet.Zone);
                }
                
                subnetSelect.appendChild(option);
            });

            // Explicitly select first subnet
            subnetSelect.selectedIndex = 0;
            
            // Update zone display for first subnet
            updateSelectedSubnetZone();
            
            // Load data disks for first subnet's zone
            if (selectedSubnets[0].Zone) {
                loadDataDisks(selectedSubnets[0].Zone);
            }
        } else {
            subnetSelect.innerHTML = '<option>No subnets available for this VPC.</option>';
            if (subnetZoneInput) {
                subnetZoneInput.value = '';
            }
        }
    }

    function updateSelectedSubnetZone() {
        const subnetSelect = document.getElementById('subnetSelect');
        const subnetZoneInput = document.getElementById('subnetZone');
        
        if (!subnetZoneInput) {
            return;
        }
        
        if (!subnetSelect || subnetSelect.options.length === 0) {
            subnetZoneInput.value = '';
            return;
        }
        
        const selectedOption = subnetSelect.options[subnetSelect.selectedIndex];
        
        if (selectedOption) {
            const zone = selectedOption.getAttribute('data-zone') || selectedOption.dataset.zone;
            
            if (zone) {
                subnetZoneInput.value = zone;
                loadDataDisks(zone);
            } else {
                subnetZoneInput.value = '';
            }
        } else {
            subnetZoneInput.value = '';
        }
    }

    function loadKeyPairs() {
        const connConfig = document.getElementById('connConfig').value;
        const keypairSelect = document.getElementById('keypairSelect');

        if (!keypairSelect) {
            console.error('KeyPair select element not found');
            return;
        }

        fetch(`/spider/keypair?ConnectionName=${connConfig}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            keypairSelect.innerHTML = ''; // Clear existing options

            if (data.keypair && data.keypair.length > 0) {
                data.keypair.forEach(keypair => {
                    const option = document.createElement('option');
                    option.value = keypair.IId.NameId;
                    option.textContent = keypair.IId.NameId;
                    keypairSelect.appendChild(option);
                });
            } else {
                keypairSelect.innerHTML = '<option>No keypairs available.</option>';
            }
        })
        .catch(error => {
            alert('Error loading keypairs: ' + error.message);
        });
    }

    function loadSecurityGroups() {
        const connConfig = document.getElementById('connConfig').value;
        const securityGroupSelect = document.getElementById('securityGroupSelect');
        const vpcName = document.getElementById('vpcSelect').options[document.getElementById('vpcSelect').selectedIndex].text.split(' ')[0];
        const url = `/spider/securitygroup/vpc/${vpcName}?ConnectionName=${connConfig}`
        
        if (!securityGroupSelect) {
            console.error('Security Group select element not found');
            return;
        }

        fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            securityGroupSelect.innerHTML = ''; // Clear existing options

            if (data.securitygroup && data.securitygroup.length > 0) {
                data.securitygroup.forEach(sg => {
                    const checkboxWrapper = document.createElement('div');
                    checkboxWrapper.className = 'checkbox-wrapper';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = sg.IId.NameId;
                    checkbox.id = `sg-${sg.IId.NameId}`;
                    checkbox.name = 'securityGroupCheckbox';
                    
                    const label = document.createElement('label');
                    label.htmlFor = `sg-${sg.IId.NameId}`;
                    label.textContent = sg.IId.NameId;
                    
                    checkboxWrapper.appendChild(checkbox);
                    checkboxWrapper.appendChild(label);
                    securityGroupSelect.appendChild(checkboxWrapper);
                });
            } else {
                const noSGMessage = document.createElement('p');
                noSGMessage.textContent = 'No security groups available for this VPC.';
                securityGroupSelect.appendChild(noSGMessage);
            }
        })
        .catch(error => {
            alert('Error loading security groups: ' + error.message);
        });
    }

    function showProvisioningInfoOverlay(vmInfo) {
        const overlay = document.getElementById('provisioningInfoOverlay');
        const overlayContent = document.querySelector('.provisioning-info-overlay-content');
        overlayContent.innerHTML = `
            <button class="overlay-close-btn" onclick="closeProvisioningInfoOverlay()">X</button>
            <h3>VM Provisioning Info</h3>
            <table>
                <tr>
                    <th>VPC/Subnet</th>
                    <td>
                        <ul class="bullet-list">
                            <li>VPC: ${vmInfo.vpcName || 'N/A'}</li>
                            <li>Subnet: ${vmInfo.subnetName || 'N/A'} (${vmInfo.zone || 'N/A'})</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <th>Security Group</th>
                    <td>
                        <ul class="bullet-list">
                            <li>${(vmInfo.securityGroupName && vmInfo.securityGroupName.length > 0) ? vmInfo.securityGroupName.join('</li><li>') : 'N/A'}</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <th>KeyPair</th>
                    <td>
                        <ul class="bullet-list">
                            <li>${vmInfo.keypairName || 'N/A'}</li>
                            <li>VM User: ${vmInfo.vmUserId || 'N/A'}</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <th>Image/Spec</th>
                    <td>
                        <ul class="bullet-list">
                            <li>Image Type: ${vmInfo.imageType || 'N/A'}</li>
                            <li>Image ID: ${vmInfo.imageName || 'N/A'}</li>
                            <li>Platform: ${vmInfo.platform || 'N/A'}</li>
                            <li>Spec: ${vmInfo.vmSpecName || 'N/A'}</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <th>Disk</th>
                    <td>
                        <ul class="bullet-list">
                            <li>Root Disk Type: ${vmInfo.rootDiskType || 'N/A'} (${vmInfo.rootDiskSize || 'N/A'})</li>
                            <li>Root Device: ${vmInfo.rootDeviceName || 'N/A'}</li>
                            <li>Data Disks: ${(vmInfo.dataDisks && vmInfo.dataDisks.length > 0) 
                                    ? vmInfo.dataDisks.join('</li><li>') 
                                    : 'N/A'}
                            </li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <th>Network</th>
                    <td>
                        <ul class="bullet-list">
                            <li>NIC: ${vmInfo.networkInterface || 'N/A'}</li>
                            <li>Public IP: ${vmInfo.publicIP || 'N/A'}</li>
                            <li>Public DNS: ${vmInfo.publicDNS || 'N/A'}</li>
                            <li>Private IP: ${vmInfo.privateIP || 'N/A'}</li>
                            <li>Private DNS: ${vmInfo.privateDNS || 'N/A'}</li>
                        </ul>
                    </td>
                </tr>
            </table>
        `;
        overlay.style.display = 'flex';
        document.addEventListener('keydown', handleProvisioningInfoOverlayEsc);
    }

    function closeProvisioningInfoOverlay() {
        const overlay = document.getElementById('provisioningInfoOverlay');
        overlay.style.display = 'none';
        document.removeEventListener('keydown', handleProvisioningInfoOverlayEsc);
    }

    function handleProvisioningInfoOverlayEsc(event) {
        if (event.key === "Escape") {
            closeProvisioningInfoOverlay();
        }
    }

    function openSSHAccess(vmInfo) {
        let sshOverlay = document.getElementById('ssh-overlay');

        if (!sshOverlay) {
            sshOverlay = document.createElement('div');
            sshOverlay.id = 'ssh-overlay';
            sshOverlay.className = 'overlay';
            sshOverlay.innerHTML = `
                <div class="overlay-content" style="position: relative;">
                    <button class="overlay-close-btn" onclick="closeSSHOverlay()">X</button>
                    <h2>SSH Access</h2>
                    <p>Connect to ${vmInfo.vmUserId}@${vmInfo.publicIP}</p>
                    <form id="ssh-form">
                        <label for="privatekey">Private Key:</label><br>
                        <div id="dropZone" class="drop-zone">Drag & Drop a key file here or paste it manually</div>
                        <textarea id="privatekey" name="privatekey" rows="10" cols="30" required style="background-color: #fff5f5;">Private key for ${vmInfo.keyName}.</textarea><br>
                        <button type="button" onclick="connectSSH('${vmInfo.vmUserId}', '${vmInfo.publicIP}')">Connect</button>
                        <button type="button" onclick="closeSSHOverlay()">Cancel</button>
                    </form>
                    <div id="terminal" style="display:none;"></div>
                </div>
            `;
            document.body.appendChild(sshOverlay);
            setupDropZone();
        } else {
            sshOverlay.querySelector('#privatekey').value = `Private key for ${vmInfo.keyName}.`;
            sshOverlay.querySelector('p').textContent = `Connect to ${vmInfo.vmUserId}@${vmInfo.publicIP}`;
            sshOverlay.querySelector('#terminal').style.display = 'none';
            sshOverlay.querySelector('#ssh-form').style.display = 'block';
            sshOverlay.querySelector('button[onclick^="connectSSH"]').onclick = function() {
                connectSSH(vmInfo.vmUserId, vmInfo.publicIP);
            };
        }

        sshOverlay.style.display = 'flex';

        document.addEventListener('keydown', handleSSHOverlayEsc);
    }

    function closeSSHOverlay() {
        const sshOverlay = document.getElementById('ssh-overlay');
        sshOverlay.style.display = 'none';
        document.removeEventListener('keydown', handleSSHOverlayEsc);
    }

    function handleSSHOverlayEsc(event) {
        if (event.key === "Escape") {
            closeSSHOverlay();
        }
    }

    function connectSSH(user, ip) {
        const privateKey = document.getElementById('privatekey').value;
        const terminalDiv = document.getElementById('terminal');

        const sshForm = document.getElementById('ssh-form');
        sshForm.style.display = 'none';
        terminalDiv.style.display = 'block';

        if (terminalDiv._initialized) {
            terminalDiv.innerHTML = '';
        }

        const term = new Terminal({
            cursorBlink: true,
            cols: 100,
            rows: 30,
            scrollback: 5000
        });

        term.open(terminalDiv);
        terminalDiv._initialized = true;
        const socket = new WebSocket("ws://" + location.host + "/spider/adminweb/sshwebterminal/ws?user=" + encodeURIComponent(user) + "&ip=" + encodeURIComponent(ip) + "&privatekey=" + encodeURIComponent(privateKey));

        socket.onopen = function() {
            term.write('Connected to SSH...\r\n');
        };

        socket.onmessage = function(event) {
            const message = event.data;

            if (message.startsWith("Failed")) {
                alert(message); 
            } else {
                processLargeData(message, term);
            }
        };

        term.onData(function(data) {
            socket.send(data);
        });

        socket.onclose = function () {
            term.write('Connection closed.\r\n');
            closeSSHConnection(socket, term);
        };

        socket.onerror = function (error) {
            alert("Failed to connect to the SSH server. Please check your private key and try again. Error: " + (error.message || error));
            closeSSHConnection(socket, term);
        };

        function closeSSHConnection(socket, term) {
            if (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING) {
                socket.close();
            }
            term.dispose();
            closeSSHOverlay();
        }
    }

    function processLargeData(data, term) {
        const chunkSize = 1024;
        for (let i = 0; i < data.length; i += chunkSize) {
            term.write(data.substring(i, i + chunkSize));
        }
    }


    function setupDropZone() {
        const dropZone = document.getElementById('dropZone');
        const textArea = document.getElementById('privatekey');

        dropZone.addEventListener('dragover', function(event) {
            event.stopPropagation();
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', function() {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', function(event) {
            event.stopPropagation();
            event.preventDefault();
            dropZone.classList.remove('dragover');

            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    textArea.value = event.target.result;
                };
                reader.readAsText(files[0]);
            }
        });
    }


    function copyToClipboard(text) {
        const tempInput = document.createElement('input');
        tempInput.style.position = 'absolute';
        tempInput.style.left = '-9999px';
        tempInput.value = text;
        document.body.appendChild(tempInput);
        tempInput.select();
        try {
            document.execCommand('copy');
        } catch (err) {
            alert('Failed to copy text: ', err);
        }
        document.body.removeChild(tempInput);
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        const timeElements = document.querySelectorAll('.vm-start-time');

        timeElements.forEach(function(element) {
            const originalTime = element.getAttribute('data-time');
            const formattedTime = formatTime(originalTime);
            element.innerHTML = '&nbsp;‚Ä¢ ' + formattedTime;
        });

        function formatTime(originalTime) {
            const parts = originalTime.split(" ");
            const date = parts[0];
            const time = parts[1].slice(0, 5);
            const timezone = parts[3];
            return `${date} ${time} ${timezone}`;
        }
    });

    function loadDataDisks(zone) {
        const connConfig = document.getElementById('connConfig').value;

        fetch(`/spider/disk?ConnectionName=${connConfig}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            const diskSelect = document.getElementById('dataDiskSelect');
            diskSelect.innerHTML = '';
            
            const filteredDisks = data.disk.filter(disk => disk.Zone === zone && disk.Status === "Available");
            
            if (filteredDisks.length > 0){
                filteredDisks.forEach(disk => {
                    if (disk.Zone === zone && disk.Status === "Available"){
                        const checkboxWrapper = document.createElement('div');
                        checkboxWrapper.className = 'checkbox-wrapper';

                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.name = 'disks';
                        checkbox.value = disk.IId.NameId;
                        checkbox.id = `disk-${disk.IId.NameId}`;

                        const label = document.createElement('label');
                        label.htmlFor = `disk-${disk.IId.NameId}`;
                        label.textContent = `${disk.IId.NameId} (${disk.DiskSize} GB)`;

                        checkboxWrapper.appendChild(checkbox);
                        checkboxWrapper.appendChild(label);

                        diskSelect.appendChild(checkboxWrapper);
                    }
                });
            } else {
                const noDiskMessage = document.createElement('p');
                noDiskMessage.textContent = 'No disks available in the same zone.';
                diskSelect.appendChild(noDiskMessage);
            }
        }).catch(error =>{
            alert("Error loading data disks: " + error.message);
        });
    }

    document.getElementById('subnetSelect').addEventListener('change', function() {
        const selectedZone = this.options[this.selectedIndex].dataset.zone;
        loadDataDisks(selectedZone);
    });

    function showMiscOverlay(button) {
        const miscContent = button.previousElementSibling.innerHTML;
        document.getElementById('miscContent').innerHTML = `<div>${miscContent}</div>`;
        document.getElementById('miscOverlay').style.display = 'flex';
        document.addEventListener('keydown', handleMiscOverlayEsc);
    }

    function closeMiscOverlay() {
        document.getElementById('miscOverlay').style.display = 'none';
        document.removeEventListener('keydown', handleMiscOverlayEsc);
    }

    function handleMiscOverlayEsc(event) {
        if (event.key === "Escape") {
            closeMiscOverlay();
        }
    }

    function updateImageNameField() {
        const imageType = document.getElementById('imageType').value;
        const imageNameField = document.getElementById('imageNameField');
        const rootDiskTypeField = document.getElementById('rootDiskType');
        const rootDiskSizeField = document.getElementById('rootDiskSize');
        
        if (imageType === 'MyImage') {
            rootDiskTypeField.value = '';
            rootDiskSizeField.value = '';
            rootDiskTypeField.disabled = true;
            rootDiskSizeField.disabled = true;
            fetchMyImages();
        } else if (imageType === 'PublicImage') {
            rootDiskTypeField.value = 'default';
            rootDiskTypeField.disabled = false;
            rootDiskSizeField.disabled = false;
            imageNameField.innerHTML = `
                <input type="text" id="imageName" name="imageName" required style="background-color: #f7f7e6;">
            `;
        }
    }

    function fetchMyImages() {
        const connConfig = document.getElementById('connConfig').value;
        
        fetch(`/spider/myimage?ConnectionName=${connConfig}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            const imageNameField = document.getElementById('imageNameField');
            const images = data.myImage || [];
            
            if (images.length > 0) {
                imageNameField.innerHTML = `
                    <select id="imageName" name="imageName" required style="background-color: #f7f7e6;">
                        ${images.map(image => `<option value="${image.IId.NameId}">${image.IId.NameId} (${image.Status})</option>`).join('')}
                    </select>
                `;
            } else {
                imageNameField.innerHTML = '<p>No available MyImages</p>';
            }
        })
        .catch(error => {
            alert('Error fetching MyImages: ' + error.message);
        });
    }

    function showAddTagOverlay(vmName) {
        const addTagOverlay = document.getElementById('add-tag-overlay');
        const addTagOverlayContent = document.querySelector('.add-tag-overlay-content');
        addTagOverlayContent.innerHTML = `
            <button type="button" class="overlay-close-btn" onclick="closeAddTagOverlay()">X</button>
            <div class="tag-overlay-input-group">
                <label for="tagOverlayTagKey">Tag Key:</label>
                <input type="text" id="tagOverlayTagKey" name="tagKey" required>
            </div>
            <div class="tag-overlay-input-group">
                <label for="tagOverlayTagValue">Tag Value:</label>
                <input type="text" id="tagOverlayTagValue" name="tagValue" required>
            </div>
            <div class="tag-overlay-button-group">
                <button onclick="addTag('${vmName}')">Add</button>
                <button onclick="closeAddTagOverlay()">Cancel</button>
            </div>
        `;
        addTagOverlay.style.display = 'flex';
        document.addEventListener('keydown', handleAddTagOverlayEsc);
    }

    function closeAddTagOverlay() {
        const addTagOverlay = document.getElementById('add-tag-overlay');
        addTagOverlay.style.display = 'none';
        document.removeEventListener('keydown', handleAddTagOverlayEsc);
    }

    function handleAddTagOverlayEsc(event) {
        if (event.key === "Escape") {
            closeAddTagOverlay();
        }
    }
    
    function addTag(vmName) {
        const tagKey = document.getElementById('tagOverlayTagKey').value;
        const tagValue = document.getElementById('tagOverlayTagValue').value;
        const connConfig = document.getElementById('connConfig').value;

        const data = {
            ConnectionName: connConfig,
            ReqInfo: {
                ResourceType: 'VM',
                ResourceName: vmName,
                Tag: { Key: tagKey, Value: tagValue }
            }
        };

        fetchWithProgress('/spider/tag', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        }).then(response => {
            if (!response.ok) {
                return response.json().then(error => {
                    throw new Error(error.message);
                });
            }
            return response.json();
        }).then(() => {
            closeAddTagOverlay();
            location.reload();
        }).catch(error => {
            showError("Error adding tag: " + error.message, "VM Name: " + keyPairName);
        });
    }

    function showSystemIdOverlay(systemId) {
        const overlay = document.getElementById('system-id-overlay');
        const fullSystemIdElement = document.getElementById('fullSystemId');
        fullSystemIdElement.textContent = systemId;

        overlay.style.display = 'block';
        document.addEventListener('keydown', handleSystemIdOverlayEsc);
    }

    function closeSystemIdOverlay() {
        const overlay = document.getElementById('system-id-overlay');
        overlay.style.display = 'none';
        document.removeEventListener('keydown', handleSystemIdOverlayEsc);
    }

    function handleSystemIdOverlayEsc(event) {
        if (event.key === "Escape") {
            closeSystemIdOverlay();
        }
    }

    function copySystemId() {
        const fullSystemIdElement = document.getElementById('fullSystemId');
        const range = document.createRange();
        range.selectNode(fullSystemIdElement);
        const selection = window.getSelection();

        selection.removeAllRanges();
        selection.addRange(range);

        try {
            document.execCommand('copy');
            closeSystemIdOverlay();
        } catch (err) {
            console.error('Error copying SystemId: ', err);
        }

        selection.removeAllRanges();
    }

    // MC-Insight API Configuration (via Spider Proxy)
    const MC_INSIGHT_API_BASE = '/spider/mcinsight';
    const ITEMS_PER_PAGE = 50;

    let currentImagePage = 0;
    let currentSpecPage = 0;
    let imageFilters = {};
    let specFilters = {};
    let imageTotalCount = 0;
    let specTotalCount = 0;
    let imageSortField = 'image_id';
    let imageSortOrder = 'asc';
    let specSortField = 'name';
    let specSortOrder = 'asc';
    
    // OpenStack data cache (fetched from Spider API)
    let openstackAllImages = [];
    let openstackAllSpecs = [];

    // Check if MC-Insight API Token is configured
    async function checkMCInsightToken() {
        try {
            const response = await fetch(`${MC_INSIGHT_API_BASE}/vm-image/filters`);
            return response.status !== 503;
        } catch (error) {
            return false;
        }
    }

    function showTokenWarning(containerId) {
        const container = document.getElementById(containerId);
        container.innerHTML = `
            <div style="
                background: #fff3cd;
                border: 2px solid #ffc107;
                border-radius: 8px;
                padding: 20px 30px;
                margin: 20px auto;
                max-width: 600px;
                box-shadow: 0 4px 12px rgba(255, 193, 7, 0.2);
            ">
                <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <span style="font-size: 32px; margin-right: 15px;">‚ö†Ô∏è</span>
                    <h3 style="margin: 0; color: #856404; font-size: 18px;">MC-Insight API Token Required</h3>
                </div>
                <div style="color: #856404; line-height: 1.6;">
                    <p style="margin: 10px 0;">To search multi-cloud metadata using MC-Insight, you need to configure the MC-Insight API Token.</p>
                    <p style="margin: 10px 0;">Please follow these steps:</p>
                    <ol style="margin: 10px 0; padding-left: 20px;">
                        <li>Get token from <strong>MC-Insight service administrator</strong></li>
                        <li>Set the <code style="background: #fff; padding: 2px 6px; border-radius: 3px; border: 1px solid #ddd;">MC_INSIGHT_API_TOKEN</code> value in <code style="background: #fff; padding: 2px 6px; border-radius: 3px; border: 1px solid #ddd;">./setup.env</code></li>
                        <li>Restart CB-Spider</li>
                    </ol>
                </div>
            </div>
        `;
    }

    // Helper function to get CSP and Region info from connection config
    async function getConnectionInfo() {
        try {
            const connConfig = document.getElementById('connConfig').value;
            const connData = await fetch(`/spider/connectionconfig/${connConfig}`).then(r => r.json());
            const providerName = connData.ProviderName.toLowerCase();
            const regionName = connData.RegionName;
            
            // Get Region details to find actual CSP region name
            const regionData = await fetch(`/spider/region/${regionName}`).then(r => r.json());
            
            // Extract actual CSP region from KeyValueInfoList
            let cspRegion = '';
            if (regionData && regionData.KeyValueInfoList) {
                const regionEntry = regionData.KeyValueInfoList.find(kv => kv.Key === 'Region');
                if (regionEntry) {
                    cspRegion = regionEntry.Value;
                }
            }
            
            // Get zone from subnet zone input field (updated when subnet is selected)
            const subnetZoneInput = document.getElementById('subnetZone');
            const zoneName = subnetZoneInput && subnetZoneInput.value ? subnetZoneInput.value : '';
            
            return { csp: providerName, region: cspRegion, zone: zoneName };
        } catch (error) {
            console.error('Error getting connection info:', error);
            throw error;
        }
    }

    // Helper function to get CSP name from connection config (backward compatibility)
    function getCSPFromConnection() {
        return getConnectionInfo().then(info => info.csp);
    }

    // ==================== IMAGE SELECTION FUNCTIONS ====================

    function showImageSelectionOverlay() {
        // Check if subnet is selected
        const subnetSelect = document.getElementById('subnetSelect');
        
        if (!subnetSelect.value || subnetSelect.value === '') {
            alert('Please select a Subnet first. The Zone will be determined from the selected Subnet.');
            return;
        }
        
        const overlay = document.getElementById('image-selection-overlay');
        overlay.style.display = 'flex';
        document.addEventListener('keydown', handleImageSelectionOverlayEsc);
        
        // Check if MC-Insight token is configured
        checkMCInsightToken().then(hasToken => {
            if (!hasToken) {
                showTokenWarning('image-list-container');
                document.getElementById('image-pagination').style.display = 'none';
                return;
            }
            
            // Get current connection info and set filters
            getConnectionInfo().then(info => {
                if (!info.zone) {
                    alert('Cannot determine Zone from selected Subnet. Please select a valid Subnet.');
                    closeImageSelectionOverlay();
                    return;
                }
                
                loadImageFilterOptions(info.csp, info.region, info.zone);
                
                // Add Enter key event listeners to filter inputs
                ['image-filter-name', 'image-filter-distribution'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('keypress', function(event) {
                            if (event.key === 'Enter') {
                                event.preventDefault();
                                applyImageFilters();
                            }
                        });
                    }
                });
            }).catch(error => {
                console.error('Error loading connection info:', error);
                alert('Failed to load connection information');
                closeImageSelectionOverlay();
            });
        });
    }

    function closeImageSelectionOverlay() {
        const overlay = document.getElementById('image-selection-overlay');
        overlay.style.display = 'none';
        document.removeEventListener('keydown', handleImageSelectionOverlayEsc);
    }

    function handleImageSelectionOverlayEsc(event) {
        if (event.key === 'Escape') {
            const priceOverlay = document.getElementById('price-info-overlay');
            // Don't close if Price Info overlay is open (it should close first)
            if (priceOverlay && priceOverlay.style.display === 'flex') {
                return;
            }
            event.stopImmediatePropagation();
            closeImageSelectionOverlay();
        }
    }

    function loadImageFilterOptions(csp, currentRegion, currentZone) {
        // ==================== OPENSTACK: EXTRACT FROM CACHED DATA ====================
        if (csp.toLowerCase() === 'openstack') {
            const regionSelect = document.getElementById('image-filter-region');
            const zoneSelect = document.getElementById('image-filter-zone');
            const archSelect = document.getElementById('image-filter-arch');
            const platformSelect = document.getElementById('image-filter-platform');
            
            // Set region and zone from connection (locked)
            regionSelect.innerHTML = `<option value="${currentRegion}">${currentRegion}</option>`;
            regionSelect.disabled = true;
            regionSelect.style.backgroundColor = '#f0f0f0';
            
            zoneSelect.innerHTML = `<option value="${currentZone}">${currentZone}</option>`;
            zoneSelect.disabled = true;
            zoneSelect.style.backgroundColor = '#f0f0f0';
            
            // If we have cached images, extract unique values for filters
            if (openstackAllImages.length > 0) {
                // Extract unique architectures
                const uniqueArchs = [...new Set(openstackAllImages.map(img => img.os_architecture).filter(v => v && v !== 'NA'))];
                archSelect.innerHTML = '<option value="">All</option>';
                uniqueArchs.forEach(arch => {
                    const option = document.createElement('option');
                    option.value = arch;
                    option.textContent = arch;
                    archSelect.appendChild(option);
                });
                archSelect.value = '';
                
                // Extract unique platforms
                const uniquePlatforms = [...new Set(openstackAllImages.map(img => img.os_platform).filter(v => v && v !== 'na'))];
                platformSelect.innerHTML = '<option value="">All</option>';
                uniquePlatforms.forEach(platform => {
                    const option = document.createElement('option');
                    option.value = platform;
                    option.textContent = platform.charAt(0).toUpperCase() + platform.slice(1);
                    platformSelect.appendChild(option);
                });
                platformSelect.value = '';
            } else {
                // Set defaults while data is loading
                archSelect.innerHTML = '<option value="">All</option>';
                archSelect.value = '';
                platformSelect.innerHTML = '<option value="">All</option>';
                platformSelect.value = '';
            }
            
            // Set filters with locked region/zone
            imageFilters = {
                region: currentRegion,
                zone: currentZone
            };
            
            // Set initial message - data loads when Search is clicked
            document.getElementById('image-list-container').innerHTML = '<div class="loading-message">Press Search to load images</div>';
            document.getElementById('image-pagination').style.display = 'none';
            return;
        }
        
        // ==================== NON-OPENSTACK: USE MC-INSIGHT FILTER API ====================
        // Show MC-Insight badge for non-OpenStack CSPs
        const badge = document.getElementById('image-mcinsight-badge');
        if (badge) badge.style.display = '';
        
        fetch(`/spider/mcinsight/vm-image/filters`)
        .then(response => response.json())
        .then(data => {
            
            const regionSelect = document.getElementById('image-filter-region');
            const zoneSelect = document.getElementById('image-filter-zone');
            const archSelect = document.getElementById('image-filter-arch');
            const platformSelect = document.getElementById('image-filter-platform');
            
            regionSelect.innerHTML = '';
            zoneSelect.innerHTML = '';
            
            // Try NCP first, fallback to NCPVPC if not found
            let actualCsp = csp;
            if (csp.toLowerCase() === 'ncp' && (!data.cloud_hierarchy || !data.cloud_hierarchy[csp])) {
                actualCsp = 'ncpvpc';
                console.log('NCP not found in filters, using NCPVPC');
            }
            // Try NHN first, fallback to nhncloud if not found
            if (csp.toLowerCase() === 'nhn' && (!data.cloud_hierarchy || !data.cloud_hierarchy[csp])) {
                actualCsp = 'nhncloud';
                console.log('NHN not found in filters, using nhncloud');
            }
            // Try KT first, fallback to ktvpc if not found
            if (csp.toLowerCase() === 'kt' && (!data.cloud_hierarchy || !data.cloud_hierarchy[csp])) {
                actualCsp = 'ktvpc';
                console.log('KT not found in filters, using ktvpc');
            }
            
            // Populate Region/Zone (cloud_hierarchy)
            if (data.cloud_hierarchy && data.cloud_hierarchy[actualCsp]) {
                const regions = Object.keys(data.cloud_hierarchy[actualCsp]);
                
                regions.forEach(region => {
                    const option = document.createElement('option');
                    option.value = region;
                    option.textContent = region;
                    if (region === currentRegion) {
                        option.selected = true;
                    }
                    regionSelect.appendChild(option);
                });
                
                regionSelect.disabled = true;
                regionSelect.style.backgroundColor = '#f0f0f0';
                
                const zones = data.cloud_hierarchy[actualCsp][currentRegion];
                
                if (zones && zones.length > 0) {
                    zones.forEach(zone => {
                        const option = document.createElement('option');
                        option.value = zone;
                        option.textContent = zone;
                        if (zone === currentZone) {
                            option.selected = true;
                        }
                        zoneSelect.appendChild(option);
                    });
                    
                    zoneSelect.disabled = true;
                    zoneSelect.style.backgroundColor = '#f0f0f0';
                }
            }
            
            // Populate OS Architecture options dynamically
            if (data.os_architecture) {
                archSelect.innerHTML = '<option value="">All</option>';
                data.os_architecture.filter(val => val !== '~null').forEach(arch => {
                    const option = document.createElement('option');
                    option.value = arch;
                    option.textContent = arch;
                    archSelect.appendChild(option);
                });
                // Default to All
                archSelect.value = '';
            }
            
            // Populate OS Platform options dynamically
            if (data.os_platform) {
                platformSelect.innerHTML = '<option value="">All</option>';
                data.os_platform.filter(val => val !== '~null').forEach(platform => {
                    const option = document.createElement('option');
                    option.value = platform;
                    option.textContent = platform.charAt(0).toUpperCase() + platform.slice(1);
                    platformSelect.appendChild(option);
                });
                // Default to All
                platformSelect.value = '';
            }
            
        })
        .catch(error => {
            console.error('Error loading image filters:', error);
            alert('Failed to load image filters');
        });
    }

    function loadImageZones(csp, zones) {
        // This function is no longer needed as zones are loaded and locked in loadImageFilterOptions
    }

    function applyImageFilters() {
        currentImagePage = 0;
        imageFilters = {
            region: document.getElementById('image-filter-region').value,
            zone: document.getElementById('image-filter-zone').value,
            os_architecture: document.getElementById('image-filter-arch').value,
            os_platform: document.getElementById('image-filter-platform').value,
            os_distribution: document.getElementById('image-filter-distribution').value.trim(),
            image_name: document.getElementById('image-filter-name').value.trim()
        };
        loadImages();
    }

    function resetImageFilters() {
        // Region and Zone are locked, so we don't reset them
        // Reset to initial values
        document.getElementById('image-filter-arch').value = '';
        document.getElementById('image-filter-platform').value = '';
        document.getElementById('image-filter-distribution').value = '';
        document.getElementById('image-filter-name').value = '';
        
        // Keep region and zone filters but reset others
        imageFilters = {
            region: document.getElementById('image-filter-region').value,
            zone: document.getElementById('image-filter-zone').value
        };
        currentImagePage = 0;
        imageSortField = 'image_id';
        imageSortOrder = 'asc';
        document.getElementById('image-list-container').innerHTML = '<div class="loading-message">Press Search to load images</div>';
        document.getElementById('image-pagination').style.display = 'none';
    }

    // ==================== OPENSTACK SPIDER API FUNCTIONS ====================
    
    async function loadImagesFromSpider(connectionName) {
        const url = `/spider/vmimage?ConnectionName=${encodeURIComponent(connectionName)}`;
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Spider API error: ${response.status}`);
        }
        const data = await response.json();
        
        // Transform Spider API format to MC-Insight format
        // Spider returns: {image: [{IId, Name, OSArchitecture, OSPlatform, OSDistribution, OSDiskType, OSDiskSizeGB, ImageStatus, KeyValueList}]}
        const transformedImages = (data.image || []).map(img => {
            // Parse disk size
            let diskSize = -1;
            if (img.OSDiskSizeGB && img.OSDiskSizeGB !== 'NA' && img.OSDiskSizeGB !== '0') {
                const parsed = parseInt(img.OSDiskSizeGB);
                if (!isNaN(parsed) && parsed > 0) diskSize = parsed;
            }
            
            return {
                image_id: img.IId?.NameId || img.Name || 'Unknown',
                system_id: img.IId?.SystemId || img.Name || '',
                os_architecture: img.OSArchitecture && img.OSArchitecture !== 'NA' ? img.OSArchitecture : 'NA',
                os_platform: img.OSPlatform && img.OSPlatform !== 'NA' ? img.OSPlatform.toLowerCase() : 'na',
                os_distribution: img.OSDistribution && img.OSDistribution !== 'NA' ? img.OSDistribution : 'NA',
                os_disk_type: img.OSDiskType && img.OSDiskType !== 'NA' ? img.OSDiskType : 'NA',
                os_disk_size_gb: diskSize,
                image_status: img.ImageStatus || 'NA'
            };
        });
        
        return transformedImages;
    }
    
    async function loadSpecsFromSpider(connectionName) {
        const url = `/spider/vmspec?ConnectionName=${encodeURIComponent(connectionName)}`;
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Spider API error: ${response.status}`);
        }
        const data = await response.json();
        
        // Transform Spider API format to MC-Insight format
        // Spider returns: {vmspec: [{Region, Name, VCpu: {Count, ClockGHz}, MemSizeMiB, DiskSizeGB, Gpu, KeyValueList}]}
        const transformedSpecs = (data.vmspec || []).map(spec => {
            // Parse Memory (MiB)
            let memSizeMib = -1;
            if (spec.MemSizeMiB) {
                const parsed = parseInt(spec.MemSizeMiB);
                if (!isNaN(parsed) && parsed > 0) memSizeMib = parsed;
            }
            
            // Parse Disk (GB)
            let diskSizeGb = -1;
            if (spec.DiskSizeGB) {
                const parsed = parseInt(spec.DiskSizeGB);
                if (!isNaN(parsed) && parsed > 0) diskSizeGb = parsed;
            }
            
            // Parse vCPU Count
            let vcpuCount = -1;
            if (spec.VCpu?.Count) {
                const parsed = parseInt(spec.VCpu.Count);
                if (!isNaN(parsed) && parsed > 0) vcpuCount = parsed;
            }
            
            // Parse vCPU Clock
            let vcpuClockGhz = 'NA';
            if (spec.VCpu?.ClockGHz && spec.VCpu.ClockGHz !== '-1') {
                vcpuClockGhz = spec.VCpu.ClockGHz;
            }
            
            return {
                name: spec.Name || 'Unknown',
                vcpu_count: vcpuCount,
                vcpu_clock_ghz: vcpuClockGhz,
                mem_size_mib: memSizeMib,
                disk_size_gb: diskSizeGb,
                gpu_count: spec.Gpu?.length > 0 ? spec.Gpu[0].Count : -1,
                gpu_mem_size_gb: spec.Gpu?.length > 0 && spec.Gpu[0].MemSizeGB ? parseInt(spec.Gpu[0].MemSizeGB) : -1,
                gpu_model: spec.Gpu?.length > 0 ? spec.Gpu[0].Model : 'NA',
                price_per_hour: null  // OpenStack doesn't have price info - use null to display as NA
            };
        });
        
        return transformedSpecs;
    }
    
    function extractKeyValue(keyValueList, key) {
        if (!keyValueList || !Array.isArray(keyValueList)) return null;
        const item = keyValueList.find(kv => kv.Key === key);
        return item ? item.Value : null;
    }
    
    function filterOpenStackImages(images, filters) {
        return images.filter(img => {
            // Apply filters
            if (filters.os_architecture && img.os_architecture !== filters.os_architecture) return false;
            if (filters.os_platform && img.os_platform !== filters.os_platform.toLowerCase()) return false;
            if (filters.os_distribution && !img.os_distribution.toLowerCase().includes(filters.os_distribution.toLowerCase())) return false;
            if (filters.image_name && !img.image_id.toLowerCase().includes(filters.image_name.toLowerCase())) return false;
            return true;
        });
    }
    
    function filterOpenStackSpecs(specs, filters) {
        return specs.filter(spec => {
            // Apply name filter
            if (filters.name && !spec.name.toLowerCase().includes(filters.name.toLowerCase())) return false;
            
            // Apply vCPU filter
            if (filters.min_vcpu_count !== undefined && filters.min_vcpu_count !== '' && spec.vcpu_count < parseInt(filters.min_vcpu_count)) return false;
            if (filters.max_vcpu_count !== undefined && filters.max_vcpu_count !== '' && spec.vcpu_count > parseInt(filters.max_vcpu_count)) return false;
            
            // Apply memory filter (filters use MiB, spec uses MiB - direct comparison)
            if (filters.min_mem_size_mib !== undefined && filters.min_mem_size_mib !== '' && spec.mem_size_mib > 0) {
                if (spec.mem_size_mib < parseInt(filters.min_mem_size_mib)) return false;
            }
            if (filters.max_mem_size_mib !== undefined && filters.max_mem_size_mib !== '' && spec.mem_size_mib > 0) {
                if (spec.mem_size_mib > parseInt(filters.max_mem_size_mib)) return false;
            }
            
            // Apply GPU count filter (exclude NA when filter is set)
            if (filters.min_gpu_count !== undefined && filters.min_gpu_count !== '') {
                if (spec.gpu_count <= 0) return false;  // Exclude NA (-1) or 0
                if (spec.gpu_count < parseInt(filters.min_gpu_count)) return false;
            }
            if (filters.max_gpu_count !== undefined && filters.max_gpu_count !== '') {
                if (spec.gpu_count <= 0) return false;  // Exclude NA (-1) or 0
                if (spec.gpu_count > parseInt(filters.max_gpu_count)) return false;
            }
            
            // Apply GPU memory filter (exclude NA when filter is set)
            if (filters.min_gpu_mem_size_gb !== undefined && filters.min_gpu_mem_size_gb !== '') {
                if (spec.gpu_mem_size_gb <= 0) return false;  // Exclude NA (-1) or 0
                if (spec.gpu_mem_size_gb < parseInt(filters.min_gpu_mem_size_gb)) return false;
            }
            if (filters.max_gpu_mem_size_gb !== undefined && filters.max_gpu_mem_size_gb !== '') {
                if (spec.gpu_mem_size_gb <= 0) return false;  // Exclude NA (-1) or 0
                if (spec.gpu_mem_size_gb > parseInt(filters.max_gpu_mem_size_gb)) return false;
            }
            
            // Apply GPU model filter (exclude NA when filter is set)
            if (filters.gpu_model && filters.gpu_model !== '') {
                if (spec.gpu_model === 'NA' || !spec.gpu_model) return false;  // Exclude NA
                if (!spec.gpu_model.toLowerCase().includes(filters.gpu_model.toLowerCase())) return false;
            }
            
            return true;
        });
    }
    
    function sortOpenStackData(data, field, order) {
        return [...data].sort((a, b) => {
            let aVal = a[field];
            let bVal = b[field];
            
            // Handle NA values
            if (aVal === 'NA' || aVal === -1) aVal = order === 'asc' ? Infinity : -Infinity;
            if (bVal === 'NA' || bVal === -1) bVal = order === 'asc' ? Infinity : -Infinity;
            
            // Convert to numbers if needed
            if (typeof aVal === 'string' && !isNaN(aVal)) aVal = parseFloat(aVal);
            if (typeof bVal === 'string' && !isNaN(bVal)) bVal = parseFloat(bVal);
            
            // String comparison (case-insensitive)
            if (typeof aVal === 'string') aVal = aVal.toLowerCase();
            if (typeof bVal === 'string') bVal = bVal.toLowerCase();
            
            if (aVal < bVal) return order === 'asc' ? -1 : 1;
            if (aVal > bVal) return order === 'asc' ? 1 : -1;
            return 0;
        });
    }

    function loadImages() {
        getCSPFromConnection().then(csp => {
            // ==================== OPENSTACK: USE SPIDER API ====================
            if (csp.toLowerCase() === 'openstack') {
                // Hide MC-Insight badge for OpenStack
                const badge = document.getElementById('image-mcinsight-badge');
                if (badge) badge.style.display = 'none';
                
                const container = document.getElementById('image-list-container');
                let loadingOverlay = container.querySelector('.table-loading-overlay');
                if (!loadingOverlay) {
                    loadingOverlay = document.createElement('div');
                    loadingOverlay.className = 'table-loading-overlay';
                    loadingOverlay.textContent = 'Loading...';
                    container.appendChild(loadingOverlay);
                }
                loadingOverlay.classList.add('active');
                
                // Get current connection name
                const connectionName = document.getElementById('connConfig').value;
                
                // Load images from Spider API (only once, then cache)
                if (openstackAllImages.length === 0) {
                    loadImagesFromSpider(connectionName)
                        .then(images => {
                            openstackAllImages = images;
                            
                            // Apply filters and sorting
                            let filteredImages = filterOpenStackImages(openstackAllImages, imageFilters);
                            filteredImages = sortOpenStackData(filteredImages, imageSortField, imageSortOrder);
                            
                            // Update total count
                            imageTotalCount = filteredImages.length;
                            
                            // Paginate
                            const startIdx = currentImagePage * ITEMS_PER_PAGE;
                            const endIdx = startIdx + ITEMS_PER_PAGE;
                            const pageImages = filteredImages.slice(startIdx, endIdx);
                            
                            displayImages(pageImages);
                            updateImagePagination('Spider-OpenStack');
                            loadingOverlay.classList.remove('active');
                        })
                        .catch(error => {
                            console.error('Error loading OpenStack images:', error);
                            loadingOverlay.classList.remove('active');
                            container.innerHTML = `
                                <div class="no-data-message">
                                    <p><strong>Error loading OpenStack images</strong></p>
                                    <p style="font-size: 12px; color: #666;">${error.message}</p>
                                    <button class="select-btn" onclick="openstackAllImages = []; loadImages();" style="margin-top: 10px;">Retry</button>
                                </div>
                            `;
                        });
                } else {
                    // Use cached data
                    let filteredImages = filterOpenStackImages(openstackAllImages, imageFilters);
                    filteredImages = sortOpenStackData(filteredImages, imageSortField, imageSortOrder);
                    
                    imageTotalCount = filteredImages.length;
                    const startIdx = currentImagePage * ITEMS_PER_PAGE;
                    const endIdx = startIdx + ITEMS_PER_PAGE;
                    const pageImages = filteredImages.slice(startIdx, endIdx);
                    
                    displayImages(pageImages);
                    updateImagePagination('Spider-OpenStack');
                    loadingOverlay.classList.remove('active');
                }
                return;
            }
            
            // ==================== NON-OPENSTACK: USE MC-INSIGHT API ====================
            // Show MC-Insight badge for non-OpenStack CSPs
            const badge = document.getElementById('image-mcinsight-badge');
            if (badge) badge.style.display = '';
            
            const params = new URLSearchParams({
                csp: csp,
                skip: currentImagePage * ITEMS_PER_PAGE,
                limit: ITEMS_PER_PAGE
            });

            // Add filters if they exist
            Object.keys(imageFilters).forEach(key => {
                if (imageFilters[key]) {
                    params.append(key, imageFilters[key]);
                }
            });

            // Add sort parameter if set
            if (imageSortField) {
                const sortParam = imageSortOrder === 'desc' ? `-${imageSortField}` : imageSortField;
                params.append('sort', sortParam);
            }

            const container = document.getElementById('image-list-container');
            
            // Show loading overlay instead of replacing content
            let loadingOverlay = container.querySelector('.table-loading-overlay');
            if (!loadingOverlay) {
                loadingOverlay = document.createElement('div');
                loadingOverlay.className = 'table-loading-overlay';
                loadingOverlay.textContent = 'Loading...';
                container.appendChild(loadingOverlay);
            }
            loadingOverlay.classList.add('active');

            const apiUrl = `${MC_INSIGHT_API_BASE}/vm-image?${params.toString()}`;

            fetch(apiUrl, {
                method: 'GET',
                headers: {
                    'accept': 'application/json'
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // If NCP returns no results, try with NCPVPC
                if ((data.total === 0 || !data.items || data.items.length === 0) && csp.toLowerCase() === 'ncp') {
                    console.log('NCP returned no results, trying NCPVPC...');
                    params.set('csp', 'ncpvpc');
                    const fallbackUrl = `${MC_INSIGHT_API_BASE}/vm-image?${params.toString()}`;
                    return fetch(fallbackUrl, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json'
                        }
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    });
                }
                // If NHN returns no results, try with nhncloud
                if ((data.total === 0 || !data.items || data.items.length === 0) && csp.toLowerCase() === 'nhn') {
                    console.log('NHN returned no results, trying nhncloud...');
                    params.set('csp', 'nhncloud');
                    const fallbackUrl = `${MC_INSIGHT_API_BASE}/vm-image?${params.toString()}`;
                    return fetch(fallbackUrl, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json'
                        }
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    });
                }
                // If KT returns no results, try with ktvpc
                if ((data.total === 0 || !data.items || data.items.length === 0) && csp.toLowerCase() === 'kt') {
                    console.log('KT returned no results, trying ktvpc...');
                    params.set('csp', 'ktvpc');
                    const fallbackUrl = `${MC_INSIGHT_API_BASE}/vm-image?${params.toString()}`;
                    return fetch(fallbackUrl, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json'
                        }
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    });
                }
                return data;
            })
            .then(data => {
                imageTotalCount = data.total || 0;
                displayImages(data.items || []);
                updateImagePagination(data.data_version);
                loadingOverlay.classList.remove('active');
            })
            .catch(error => {
                console.error('Error loading images:', error);
                const errorMsg = error.message || error.toString();
                loadingOverlay.classList.remove('active');
                
                // Check if it's a token configuration error (503 Service Unavailable)
                if (errorMsg.includes('503')) {
                    container.innerHTML = `
                        <div class="no-data-message">
                            <p><strong>MC-Insight API Token Required</strong></p>
                            <p style="font-size: 12px; color: #666; margin-top: 10px;">
                                To search multi-cloud metadata using MC-Insight, you need to configure the MC-Insight API Token.<br>
                                Please set the <code>MC_INSIGHT_API_TOKEN</code> value in <code>./setup.env</code> and restart CB-Spider.
                            </p>
                        </div>
                    `;
                } else {
                    container.innerHTML = `
                        <div class="no-data-message">
                            <p><strong>Error loading images</strong></p>
                            <p style="font-size: 12px; color: #666;">${errorMsg}</p>
                            <button class="select-btn" onclick="applyImageFilters()" style="margin-top: 10px;">Retry</button>
                        </div>
                    `;
                }
            });
        }).catch(error => {
            console.error('Error getting CSP:', error);
            const container = document.getElementById('image-list-container');
            container.innerHTML = `<div class="no-data-message">Error loading connection configuration: ${error.message}</div>`;
        });
    }

    function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
            // Show a brief feedback
            const tooltip = document.createElement('div');
            tooltip.textContent = 'Copied!';
            tooltip.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #495057; color: white; padding: 10px 20px; border-radius: 4px; z-index: 10000; font-size: 14px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);';
            document.body.appendChild(tooltip);
            setTimeout(() => tooltip.remove(), 1000);
        }).catch(err => {
            console.error('Failed to copy:', err);
            alert('Failed to copy to clipboard');
        });
    }

    function displayImages(images) {
        const container = document.getElementById('image-list-container');
        
        if (images.length === 0) {
            container.innerHTML = '<div class="no-data-message">No images found matching the filters.</div>';
            return;
        }

        // Helper function to display value or NA
        const displayValue = (value) => {
            if (value === -1 || value === '-' || value === '-1') return '<span style="color: #999;">NA</span>';
            if (value === null || value === undefined || value === '') return '<span style="color: #999;">NA</span>';
            return value;
        };

        // Helper function to create sortable header
        const createSortableHeader = (label, field) => {
            const isActive = imageSortField === field;
            const arrow = isActive ? (imageSortOrder === 'asc' ? ' ‚ñ≤' : ' ‚ñº') : '';
            return `<th onclick="sortImages('${field}')" style="cursor: pointer; user-select: none;" title="Click to sort">${label}${arrow}</th>`;
        };

        let tableHTML = `
            <table class="selection-table">
                <thead>
                    <tr>
                        <th>#</th>
                        ${createSortableHeader('Name', 'image_id')}
                        ${createSortableHeader('OS Arch', 'os_architecture')}
                        ${createSortableHeader('OS Platform', 'os_platform')}
                        ${createSortableHeader('OS Distribution', 'os_distribution')}
                        ${createSortableHeader('Disk Type', 'os_disk_type')}
                        ${createSortableHeader('Disk Size (GB)', 'os_disk_size_gb')}
                        ${createSortableHeader('Status', 'image_status')}
                    </tr>
                </thead>
                <tbody>
        `;

        images.forEach((image, index) => {
            const rowNumber = currentImagePage * ITEMS_PER_PAGE + index + 1;
            tableHTML += `
                <tr>
                    <td style="color: #6c757d;">${rowNumber}</td>
                    <td style="font-family: monospace;"><a href="javascript:void(0)" onclick='selectImage("${image.image_id}")' title="Click to select this image" style="cursor: pointer; color: #007bff; text-decoration: underline;">${image.image_id}</a></td>
                    <td>${image.os_architecture === 'NA' ? '<span style="color: #999;">NA</span>' : displayValue(image.os_architecture)}</td>
                    <td>${image.os_platform === 'na' ? '<span style="color: #999;">NA</span>' : displayValue(image.os_platform)}</td>
                    <td>${displayValue(image.os_distribution)}</td>
                    <td>${image.os_disk_type === 'NA' ? '<span style="color: #999;">NA</span>' : displayValue(image.os_disk_type)}</td>
                    <td>${image.os_disk_size_gb === 0 ? '0' : (image.os_disk_size_gb > 0 ? image.os_disk_size_gb.toLocaleString() : '<span style="color: #999;">NA</span>')}</td>
                    <td>${displayValue(image.image_status)}</td>
                </tr>
            `;
        });

        tableHTML += '</tbody></table>';
        container.innerHTML = tableHTML;
    }

    function sortImages(field) {
        if (imageSortField === field) {
            // Toggle sort order if clicking the same field
            imageSortOrder = imageSortOrder === 'asc' ? 'desc' : 'asc';
        } else {
            // Set new field and default to ascending
            imageSortField = field;
            imageSortOrder = 'asc';
        }
        // Reset to first page when sorting changes
        currentImagePage = 0;
        loadImages();
    }

    function selectImage(imageId) {
        document.getElementById('imageName').value = imageId;
        closeImageSelectionOverlay();
    }

    function loadImagePage(direction) {
        if (direction === 'next' && (currentImagePage + 1) * ITEMS_PER_PAGE < imageTotalCount) {
            currentImagePage++;
            loadImages();
        } else if (direction === 'prev' && currentImagePage > 0) {
            currentImagePage--;
            loadImages();
        }
    }

    function updateImagePagination(dataVersion) {
        const pagination = document.getElementById('image-pagination');
        const pageInfo = document.getElementById('image-page-info');
        const totalInfo = document.getElementById('image-total-info');
        const versionInfo = document.getElementById('image-data-version');
        const prevBtn = document.getElementById('image-prev-btn');
        const nextBtn = document.getElementById('image-next-btn');

        const totalPages = Math.ceil(imageTotalCount / ITEMS_PER_PAGE);
        pageInfo.textContent = `${currentImagePage + 1} / ${totalPages}`;
        totalInfo.textContent = `Total: ${imageTotalCount.toLocaleString()}`;
        
        if (dataVersion) {
            let formattedDate = dataVersion;
            try {
                // Parse format: YYYYMMDD-HHMMSS
                const match = dataVersion.match(/(\d{4})(\d{2})(\d{2})-(\d{2})(\d{2})(\d{2})/);
                if (match) {
                    const year = match[1];
                    const month = parseInt(match[2]) - 1; // 0-based
                    const day = match[3];
                    const hour = match[4];
                    const minute = match[5];
                    const second = match[6];
                    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    formattedDate = `${months[month]} ${parseInt(day)}, ${year}, ${hour}:${minute}:${second}`;
                }
            } catch (e) {
                // If parsing fails, use the raw value
            }
            versionInfo.textContent = ` (data_ver: ${formattedDate})`;
        }

        prevBtn.disabled = currentImagePage === 0;
        nextBtn.disabled = (currentImagePage + 1) * ITEMS_PER_PAGE >= imageTotalCount;

        pagination.style.display = imageTotalCount > 0 ? 'flex' : 'none';
    }

    // ==================== VM SPEC SELECTION FUNCTIONS ====================

    function showSpecSelectionOverlay() {
        // Check if subnet is selected
        const subnetSelect = document.getElementById('subnetSelect');
        
        if (!subnetSelect.value || subnetSelect.value === '') {
            alert('Please select a Subnet first. The Zone will be determined from the selected Subnet.');
            return;
        }
        
        const overlay = document.getElementById('spec-selection-overlay');
        overlay.style.display = 'flex';
        document.addEventListener('keydown', handleSpecSelectionOverlayEsc);
        
        // Check if MC-Insight token is configured
        checkMCInsightToken().then(hasToken => {
            if (!hasToken) {
                showTokenWarning('spec-list-container');
                document.getElementById('spec-pagination').style.display = 'none';
                return;
            }
            
            // Get current connection info and set filters
            getConnectionInfo().then(info => {
                if (!info.zone) {
                    alert('Cannot determine Zone from selected Subnet. Please select a valid Subnet.');
                    closeSpecSelectionOverlay();
                    return;
                }
                
                loadSpecFilterOptions(info.csp, info.region, info.zone);
                
                // Add focus event listeners to set placeholder as initial value for number inputs
                const numberInputs = [
                    { id: 'spec-filter-min-vcpu', defaultValue: '2' },
                    { id: 'spec-filter-max-vcpu', defaultValue: '16' },
                    { id: 'spec-filter-min-mem', defaultValue: '4096' },
                    { id: 'spec-filter-max-mem', defaultValue: '65536' },
                    { id: 'spec-filter-min-gpu', defaultValue: '1' },
                    { id: 'spec-filter-max-gpu', defaultValue: '8' },
                    { id: 'spec-filter-min-gpu-mem', defaultValue: '8' },
                    { id: 'spec-filter-max-gpu-mem', defaultValue: '128' }
                ];
                
                numberInputs.forEach(input => {
                    const element = document.getElementById(input.id);
                    if (element) {
                        element.addEventListener('focus', function() {
                            if (this.value === '') {
                                this.value = input.defaultValue;
                            }
                        });
                        
                        // Add custom step behavior for memory inputs (*2, /2)
                        if (input.id.includes('-mem')) {
                            let isTyping = false;
                            let previousValue = null;
                            let isComposing = false;
                            
                            // Block IME (Korean, etc.) input
                            element.addEventListener('compositionstart', function() {
                                isComposing = true;
                            });
                            
                            element.addEventListener('compositionend', function() {
                                isComposing = false;
                                this.value = this.value.replace(/[^0-9]/g, '');
                            });
                            
                            element.addEventListener('focus', function() {
                                previousValue = parseInt(this.value) || parseInt(input.defaultValue);
                            });
                            
                            // Detect direct keyboard number input
                            element.addEventListener('keydown', function(event) {
                                // Block all non-numeric keys except special keys
                                if (isComposing) {
                                    event.preventDefault();
                                    return;
                                }
                                
                                // Arrow keys - apply *2, /2
                                if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                                    event.preventDefault();
                                    const currentValue = parseInt(this.value) || parseInt(input.defaultValue);
                                    if (event.key === 'ArrowUp') {
                                        this.value = currentValue * 2;
                                    } else {
                                        const newValue = Math.floor(currentValue / 2);
                                        this.value = newValue > 0 ? newValue : 1;
                                    }
                                    previousValue = parseInt(this.value);
                                    return;
                                }
                                
                                // Number keys, backspace, delete - mark as typing
                                if ((event.key >= '0' && event.key <= '9') || 
                                    event.key === 'Backspace' || 
                                    event.key === 'Delete') {
                                    isTyping = true;
                                }
                            });
                            
                            // Handle spinner clicks and other value changes
                            element.addEventListener('input', function() {
                                // Block non-numeric characters (including Korean)
                                const cleaned = this.value.replace(/[^0-9]/g, '');
                                if (this.value !== cleaned) {
                                    this.value = cleaned;
                                    previousValue = parseInt(this.value) || 0;
                                    return;
                                }
                                
                                if (isTyping) {
                                    // Direct keyboard input - allow normal behavior
                                    isTyping = false;
                                    previousValue = parseInt(this.value);
                                    return;
                                }
                                
                                // Spinner click or other change - apply *2, /2
                                const currentValue = parseInt(this.value);
                                if (!isNaN(currentValue) && previousValue !== null && currentValue !== previousValue) {
                                    if (currentValue > previousValue) {
                                        this.value = previousValue * 2;
                                    } else if (currentValue < previousValue) {
                                        const newValue = Math.floor(previousValue / 2);
                                        this.value = newValue > 0 ? newValue : 1;
                                    }
                                    previousValue = parseInt(this.value);
                                }
                            });
                            
                            element.addEventListener('wheel', function(event) {
                                event.preventDefault();
                                const currentValue = parseInt(this.value) || parseInt(input.defaultValue);
                                if (event.deltaY < 0) {
                                    this.value = currentValue * 2;
                                } else {
                                    const newValue = Math.floor(currentValue / 2);
                                    this.value = newValue > 0 ? newValue : 1;
                                }
                                previousValue = parseInt(this.value);
                            });
                        } else {
                            // For non-memory inputs, block non-numeric characters
                            let isComposing = false;
                            
                            element.addEventListener('compositionstart', function() {
                                isComposing = true;
                            });
                            
                            element.addEventListener('compositionend', function() {
                                isComposing = false;
                                this.value = this.value.replace(/[^0-9]/g, '');
                            });
                            
                            element.addEventListener('keydown', function(event) {
                                if (isComposing) {
                                    event.preventDefault();
                                    return;
                                }
                            });
                            
                            element.addEventListener('input', function() {
                                this.value = this.value.replace(/[^0-9]/g, '');
                            });
                        }
                    }
                });
                
                // Add validation for max fields to ensure max >= min
                const maxFieldValidations = [
                    { maxId: 'spec-filter-max-vcpu', minId: 'spec-filter-min-vcpu', isMemory: false },
                    { maxId: 'spec-filter-max-mem', minId: 'spec-filter-min-mem', isMemory: true },
                    { maxId: 'spec-filter-max-gpu', minId: 'spec-filter-min-gpu', isMemory: false },
                    { maxId: 'spec-filter-max-gpu-mem', minId: 'spec-filter-min-gpu-mem', isMemory: true }
                ];
                
                maxFieldValidations.forEach(validation => {
                    const maxElement = document.getElementById(validation.maxId);
                    const minElement = document.getElementById(validation.minId);
                    
                    if (maxElement && minElement) {
                        const validateMaxValue = function() {
                            const currentValue = this.value.trim();
                            
                            // Only validate if there's a value entered
                            if (currentValue === '') return;
                            
                            const maxValue = parseInt(currentValue);
                            const minValue = parseInt(minElement.value);
                            
                            // If max < min, set to min value (without alert)
                            if (!isNaN(maxValue) && !isNaN(minValue) && maxValue < minValue) {
                                this.value = minValue;
                            }
                        };
                        
                        // Validate on blur (when user finishes typing and clicks away)
                        maxElement.addEventListener('blur', validateMaxValue);
                        
                        // Validate on wheel (after value changes)
                        maxElement.addEventListener('wheel', function(event) {
                            setTimeout(() => validateMaxValue.call(this), 0);
                        });
                        
                        // For memory inputs, add validation after arrow key handling
                        if (validation.isMemory) {
                            const originalKeydownHandler = maxElement.onkeydown;
                            maxElement.addEventListener('keydown', function(event) {
                                if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                                    setTimeout(() => validateMaxValue.call(this), 0);
                                }
                            });
                        }
                    }
                });
                
                // Add Enter key event listeners to filter inputs
                ['spec-filter-name', 'spec-filter-gpu-model', 'spec-filter-min-vcpu', 'spec-filter-max-vcpu', 'spec-filter-min-mem', 'spec-filter-max-mem', 'spec-filter-min-gpu', 'spec-filter-max-gpu', 'spec-filter-min-gpu-mem', 'spec-filter-max-gpu-mem'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('keypress', function(event) {
                            if (event.key === 'Enter') {
                                event.preventDefault();
                                applySpecFilters();
                            }
                        });
                    }
                });
            }).catch(error => {
                console.error('Error loading connection info:', error);
                alert('Failed to load connection information');
                closeSpecSelectionOverlay();
            });
        });
    }

    function closeSpecSelectionOverlay() {
        const overlay = document.getElementById('spec-selection-overlay');
        overlay.style.display = 'none';
        document.removeEventListener('keydown', handleSpecSelectionOverlayEsc);
    }

    function showPriceInfoOverlay() {
        document.removeEventListener('keydown', handlePriceInfoOverlayEsc); // Prevent duplicate handlers
        document.getElementById('price-info-overlay').style.display = 'flex';
        document.addEventListener('keydown', handlePriceInfoOverlayEsc);
    }

    function closePriceInfoOverlay() {
        document.getElementById('price-info-overlay').style.display = 'none';
        document.removeEventListener('keydown', handlePriceInfoOverlayEsc);
    }

    function handlePriceInfoOverlayEsc(event) {
        if (event.key === 'Escape') {
            const priceOverlay = document.getElementById('price-info-overlay');
            
            // If price info overlay is visible, close it immediately
            if (priceOverlay.style.display === 'flex') {
                event.stopImmediatePropagation();
                closePriceInfoOverlay();
            }
        }
    }

    function handleSpecSelectionOverlayEsc(event) {
        if (event.key === 'Escape') {
            const priceOverlay = document.getElementById('price-info-overlay');
            // Don't close if Price Info overlay is open (it should close first)
            if (priceOverlay && priceOverlay.style.display === 'flex') {
                return;
            }
            event.stopImmediatePropagation();
            closeSpecSelectionOverlay();
        }
    }

    function loadSpecFilterOptions(csp, currentRegion, currentZone) {
        // ==================== OPENSTACK: SIMPLE REGION/ZONE SETUP ====================
        if (csp.toLowerCase() === 'openstack') {
            const regionSelect = document.getElementById('spec-filter-region');
            const zoneSelect = document.getElementById('spec-filter-zone');
            
            // Set region and zone from connection (locked)
            regionSelect.innerHTML = `<option value="${currentRegion}">${currentRegion}</option>`;
            regionSelect.disabled = true;
            regionSelect.style.backgroundColor = '#f0f0f0';
            
            zoneSelect.innerHTML = `<option value="${currentZone}">${currentZone}</option>`;
            zoneSelect.disabled = true;
            zoneSelect.style.backgroundColor = '#f0f0f0';
            
            // Set filters with locked region/zone
            specFilters = {
                region: currentRegion,
                zone: currentZone
            };
            
            // Set initial message - data loads when Search is clicked
            document.getElementById('spec-list-container').innerHTML = '<div class="loading-message">Press Search to load VM specs</div>';
            document.getElementById('spec-pagination').style.display = 'none';
            return;
        }
        
        // ==================== NON-OPENSTACK: USE MC-INSIGHT FILTER API ====================
        // Show MC-Insight badge for non-OpenStack CSPs
        const badge = document.getElementById('spec-mcinsight-badge');
        if (badge) badge.style.display = '';
        
        fetch(`/spider/mcinsight/vm-spec/filters`)
        .then(response => response.json())
        .then(data => {
            
            const regionSelect = document.getElementById('spec-filter-region');
            const zoneSelect = document.getElementById('spec-filter-zone');
            
            regionSelect.innerHTML = '';
            zoneSelect.innerHTML = '';
            
            // Try NCP first, fallback to NCPVPC if not found
            let actualCsp = csp;
            if (csp.toLowerCase() === 'ncp' && (!data.cloud_hierarchy || !data.cloud_hierarchy[csp])) {
                actualCsp = 'ncpvpc';
                console.log('NCP not found in filters, using NCPVPC');
            }
            // Try NHN first, fallback to nhncloud if not found
            if (csp.toLowerCase() === 'nhn' && (!data.cloud_hierarchy || !data.cloud_hierarchy[csp])) {
                actualCsp = 'nhncloud';
                console.log('NHN not found in filters, using nhncloud');
            }
            // Try KT first, fallback to ktvpc if not found
            if (csp.toLowerCase() === 'kt' && (!data.cloud_hierarchy || !data.cloud_hierarchy[csp])) {
                actualCsp = 'ktvpc';
                console.log('KT not found in filters, using ktvpc');
            }
            
            // Populate Region/Zone (cloud_hierarchy)
            if (data.cloud_hierarchy && data.cloud_hierarchy[actualCsp]) {
                const regions = Object.keys(data.cloud_hierarchy[actualCsp]);
                
                regions.forEach(region => {
                    const option = document.createElement('option');
                    option.value = region;
                    option.textContent = region;
                    if (region === currentRegion) {
                        option.selected = true;
                    }
                    regionSelect.appendChild(option);
                });
                
                regionSelect.disabled = true;
                regionSelect.style.backgroundColor = '#f0f0f0';
                
                const zones = data.cloud_hierarchy[actualCsp][currentRegion];
                
                if (zones && zones.length > 0) {
                    zones.forEach(zone => {
                        const option = document.createElement('option');
                        option.value = zone;
                        option.textContent = zone;
                        if (zone === currentZone) {
                            option.selected = true;
                        }
                        zoneSelect.appendChild(option);
                    });
                    
                    zoneSelect.disabled = true;
                    zoneSelect.style.backgroundColor = '#f0f0f0';
                }
            }
            
        })
        .catch(error => {
            console.error('Error loading spec filters:', error);
            alert('Failed to load spec filters');
        });
    }

    function loadSpecZones(csp, zones) {
        // This function is no longer needed as zones are loaded and locked in loadSpecFilterOptions
    }

    function applySpecFilters() {
        currentSpecPage = 0;
        specFilters = {
            name: document.getElementById('spec-filter-name').value.trim(),
            region: document.getElementById('spec-filter-region').value,
            zone: document.getElementById('spec-filter-zone').value,
            gpu_model: document.getElementById('spec-filter-gpu-model').value.trim(),
            min_vcpu_count: document.getElementById('spec-filter-min-vcpu').value,
            max_vcpu_count: document.getElementById('spec-filter-max-vcpu').value,
            min_mem_size_mib: document.getElementById('spec-filter-min-mem').value,
            max_mem_size_mib: document.getElementById('spec-filter-max-mem').value,
            min_gpu_count: document.getElementById('spec-filter-min-gpu').value,
            max_gpu_count: document.getElementById('spec-filter-max-gpu').value,
            min_gpu_mem_size_gb: document.getElementById('spec-filter-min-gpu-mem').value,
            max_gpu_mem_size_gb: document.getElementById('spec-filter-max-gpu-mem').value
        };
        loadSpecs();
    }

    function clearFilter(filterType) {
        switch(filterType) {
            case 'vcpu':
                document.getElementById('spec-filter-min-vcpu').value = '';
                document.getElementById('spec-filter-max-vcpu').value = '';
                break;
            case 'mem':
                document.getElementById('spec-filter-min-mem').value = '';
                document.getElementById('spec-filter-max-mem').value = '';
                break;
            case 'gpu':
                document.getElementById('spec-filter-min-gpu').value = '';
                document.getElementById('spec-filter-max-gpu').value = '';
                break;
            case 'gpu-mem':
                document.getElementById('spec-filter-min-gpu-mem').value = '';
                document.getElementById('spec-filter-max-gpu-mem').value = '';
                break;
            case 'gpu-model':
                document.getElementById('spec-filter-gpu-model').value = '';
                break;
            case 'spec-name':
                document.getElementById('spec-filter-name').value = '';
                break;
            case 'image-name':
                document.getElementById('image-filter-name').value = '';
                break;
            case 'image-distribution':
                document.getElementById('image-filter-distribution').value = '';
                break;
        }
    }

    function resetSpecFilters() {
        // Region and Zone are locked, so we don't reset them
        document.getElementById('spec-filter-name').value = '';
        document.getElementById('spec-filter-gpu-model').value = '';
        document.getElementById('spec-filter-min-vcpu').value = '';
        document.getElementById('spec-filter-max-vcpu').value = '';
        document.getElementById('spec-filter-min-mem').value = '';
        document.getElementById('spec-filter-max-mem').value = '';
        document.getElementById('spec-filter-min-gpu').value = '';
        document.getElementById('spec-filter-max-gpu').value = '';
        document.getElementById('spec-filter-min-gpu-mem').value = '';
        document.getElementById('spec-filter-max-gpu-mem').value = '';
        
        // Keep region and zone filters but reset others
        specFilters = {
            region: document.getElementById('spec-filter-region').value,
            zone: document.getElementById('spec-filter-zone').value
        };
        currentSpecPage = 0;
        specSortField = 'name';
        specSortOrder = 'asc';
        document.getElementById('spec-list-container').innerHTML = '<div class="loading-message">Press Search to load VM specs</div>';
        document.getElementById('spec-pagination').style.display = 'none';
    }

    function loadSpecs() {
        getCSPFromConnection().then(csp => {
            // ==================== OPENSTACK: USE SPIDER API ====================
            if (csp.toLowerCase() === 'openstack') {
                // Hide MC-Insight badge for OpenStack
                const badge = document.getElementById('spec-mcinsight-badge');
                if (badge) badge.style.display = 'none';
                
                const container = document.getElementById('spec-list-container');
                let loadingOverlay = container.querySelector('.table-loading-overlay');
                if (!loadingOverlay) {
                    loadingOverlay = document.createElement('div');
                    loadingOverlay.className = 'table-loading-overlay';
                    loadingOverlay.textContent = 'Loading specs...';
                    container.appendChild(loadingOverlay);
                }
                loadingOverlay.classList.add('active');
                
                // Get current connection name
                const connectionName = document.getElementById('connConfig').value;
                
                // Load specs from Spider API (only once, then cache)
                if (openstackAllSpecs.length === 0) {
                    loadSpecsFromSpider(connectionName)
                        .then(specs => {
                            openstackAllSpecs = specs;
                            
                            // Apply filters and sorting
                            let filteredSpecs = filterOpenStackSpecs(openstackAllSpecs, specFilters);
                            filteredSpecs = sortOpenStackData(filteredSpecs, specSortField, specSortOrder);
                            
                            // Update total count
                            specTotalCount = filteredSpecs.length;
                            
                            // Paginate
                            const startIdx = currentSpecPage * ITEMS_PER_PAGE;
                            const endIdx = startIdx + ITEMS_PER_PAGE;
                            const pageSpecs = filteredSpecs.slice(startIdx, endIdx);
                            
                            displaySpecs(pageSpecs);
                            updateSpecPagination('Spider-OpenStack');
                            loadingOverlay.classList.remove('active');
                        })
                        .catch(error => {
                            console.error('Error loading OpenStack specs:', error);
                            loadingOverlay.classList.remove('active');
                            container.innerHTML = `
                                <div class="no-data-message">
                                    <p><strong>Error loading OpenStack specs</strong></p>
                                    <p style="font-size: 12px; color: #666;">${error.message}</p>
                                    <button class="select-btn" onclick="openstackAllSpecs = []; loadSpecs();" style="margin-top: 10px;">Retry</button>
                                </div>
                            `;
                        });
                } else {
                    // Use cached data
                    let filteredSpecs = filterOpenStackSpecs(openstackAllSpecs, specFilters);
                    filteredSpecs = sortOpenStackData(filteredSpecs, specSortField, specSortOrder);
                    
                    specTotalCount = filteredSpecs.length;
                    const startIdx = currentSpecPage * ITEMS_PER_PAGE;
                    const endIdx = startIdx + ITEMS_PER_PAGE;
                    const pageSpecs = filteredSpecs.slice(startIdx, endIdx);
                    
                    displaySpecs(pageSpecs);
                    updateSpecPagination('Spider-OpenStack');
                    loadingOverlay.classList.remove('active');
                }
                return;
            }
            
            // ==================== NON-OPENSTACK: USE MC-INSIGHT API ====================
            // Show MC-Insight badge for non-OpenStack CSPs
            const badge = document.getElementById('spec-mcinsight-badge');
            if (badge) badge.style.display = '';
            
            // If sorting by price, fetch all data for client-side sorting
            const isPriceSorting = specSortField === 'price_per_hour';
            
            const params = new URLSearchParams({
                csp: csp,
                skip: isPriceSorting ? 0 : currentSpecPage * ITEMS_PER_PAGE,
                limit: isPriceSorting ? 10000 : ITEMS_PER_PAGE
            });

            // Add filters if they exist
            Object.keys(specFilters).forEach(key => {
                if (specFilters[key]) {
                    params.append(key, specFilters[key]);
                }
            });

            // Add sort parameter if set (except for price_per_hour which is client-side sorted)
            if (specSortField && specSortField !== 'price_per_hour') {
                const sortParam = specSortOrder === 'desc' ? `-${specSortField}` : specSortField;
                params.append('sort', sortParam);
            }

            const container = document.getElementById('spec-list-container');
            
            // Show loading overlay instead of replacing content
            let loadingOverlay = container.querySelector('.table-loading-overlay');
            if (!loadingOverlay) {
                loadingOverlay = document.createElement('div');
                loadingOverlay.className = 'table-loading-overlay';
                loadingOverlay.textContent = 'Loading specs and prices...';
                container.appendChild(loadingOverlay);
            }
            loadingOverlay.classList.add('active');

            const apiUrl = `${MC_INSIGHT_API_BASE}/vm-spec?${params.toString()}`;

            // Fetch specs first
            fetch(apiUrl, {
                method: 'GET',
                headers: {
                    'accept': 'application/json'
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(specData => {
                // If NCP returns no results, try with NCPVPC
                if ((specData.total === 0 || !specData.items || specData.items.length === 0) && csp.toLowerCase() === 'ncp') {
                    console.log('NCP returned no results, trying NCPVPC...');
                    params.set('csp', 'ncpvpc');
                    const fallbackUrl = `${MC_INSIGHT_API_BASE}/vm-spec?${params.toString()}`;
                    return fetch(fallbackUrl, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json'
                        }
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(fallbackData => {
                        return { ...fallbackData, usedFallback: true, fallbackCsp: 'ncpvpc' };
                    });
                }
                // If NHN returns no results, try with nhncloud
                if ((specData.total === 0 || !specData.items || specData.items.length === 0) && csp.toLowerCase() === 'nhn') {
                    console.log('NHN returned no results, trying nhncloud...');
                    params.set('csp', 'nhncloud');
                    const fallbackUrl = `${MC_INSIGHT_API_BASE}/vm-spec?${params.toString()}`;
                    return fetch(fallbackUrl, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json'
                        }
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(fallbackData => {
                        return { ...fallbackData, usedFallback: true, fallbackCsp: 'nhncloud' };
                    });
                }
                // If KT returns no results, try with ktvpc
                if ((specData.total === 0 || !specData.items || specData.items.length === 0) && csp.toLowerCase() === 'kt') {
                    console.log('KT returned no results, trying ktvpc...');
                    params.set('csp', 'ktvpc');
                    const fallbackUrl = `${MC_INSIGHT_API_BASE}/vm-spec?${params.toString()}`;
                    return fetch(fallbackUrl, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json'
                        }
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(fallbackData => {
                        return { ...fallbackData, usedFallback: true, fallbackCsp: 'ktvpc' };
                    });
                }
                return specData;
            })
            .then(specData => {
                specTotalCount = specData.total || 0;
                const specs = specData.items || [];
                const actualCsp = specData.usedFallback ? specData.fallbackCsp : csp;
                
                // Build price API parameters based on filters
                const priceParams = new URLSearchParams({
                    csp: actualCsp,
                    skip: 0,
                    limit: 10000  // Get all prices to match with specs
                });
                
                // Add region/zone filters if they exist
                if (specFilters.region) priceParams.append('region', specFilters.region);
                if (specFilters.zone) priceParams.append('zone', specFilters.zone);
                
                const priceApiUrl = `${MC_INSIGHT_API_BASE}/price-info?${priceParams.toString()}`;
                
                // Fetch price data
                return fetch(priceApiUrl, {
                    method: 'GET',
                    headers: {
                        'accept': 'application/json'
                    }
                })
                .then(priceResponse => {
                    if (!priceResponse.ok) {
                        console.warn('Failed to fetch price info, displaying specs without prices');
                        return { specs: specs, prices: [] };
                    }
                    return priceResponse.json();
                })
                .then(priceData => {
                    return { 
                        specs: specs, 
                        prices: priceData.items || [],
                        dataVersion: specData.data_version
                    };
                })
                .catch(priceError => {
                    console.warn('Error fetching prices:', priceError);
                    return { 
                        specs: specs, 
                        prices: [],
                        dataVersion: specData.data_version
                    };
                });
            })
            .then(combinedData => {
                // Merge specs with price data
                let specsWithPrices = mergeSpecsWithPrices(combinedData.specs, combinedData.prices);
                
                // If sorting by price, do client-side sorting and pagination
                if (specSortField === 'price_per_hour') {
                    specsWithPrices.sort((a, b) => {
                        const priceA = a.price_per_hour !== null && a.price_per_hour !== undefined ? parseFloat(a.price_per_hour) : Infinity;
                        const priceB = b.price_per_hour !== null && b.price_per_hour !== undefined ? parseFloat(b.price_per_hour) : Infinity;
                        
                        if (specSortOrder === 'asc') {
                            return priceA - priceB;
                        } else {
                            return priceB - priceA;
                        }
                    });
                    
                    // Apply pagination to sorted data
                    const start = currentSpecPage * ITEMS_PER_PAGE;
                    const end = start + ITEMS_PER_PAGE;
                    specsWithPrices = specsWithPrices.slice(start, end);
                }
                
                displaySpecs(specsWithPrices);
                updateSpecPagination(combinedData.dataVersion);
                loadingOverlay.classList.remove('active');
            })
            .catch(error => {
                console.error('Error loading specs:', error);
                const errorMsg = error.message || error.toString();
                loadingOverlay.classList.remove('active');
                
                // Check if it's a token configuration error (503 Service Unavailable)
                if (errorMsg.includes('503')) {
                    container.innerHTML = `
                        <div class="no-data-message">
                            <p><strong>MC-Insight API Token Required</strong></p>
                            <p style="font-size: 12px; color: #666; margin-top: 10px;">
                                To search multi-cloud metadata using MC-Insight, you need to configure the MC-Insight API Token.<br>
                                Please set the <code>MC_INSIGHT_API_TOKEN</code> value in <code>./setup.env</code> and restart CB-Spider.
                            </p>
                        </div>
                    `;
                } else {
                    container.innerHTML = `
                        <div class="no-data-message">
                            <p><strong>Error loading VM specs</strong></p>
                            <p style="font-size: 12px; color: #666;">${errorMsg}</p>
                            <button class="select-btn" onclick="applySpecFilters()" style="margin-top: 10px;">Retry</button>
                        </div>
                    `;
                }
            });
        }).catch(error => {
            console.error('Error getting CSP:', error);
            const container = document.getElementById('spec-list-container');
            container.innerHTML = `<div class="no-data-message">Connection ConfigÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}</div>`;
        });
    }

    function mergeSpecsWithPrices(specs, prices) {
        // Create a map of name -> price info for quick lookup
        const priceMap = {};
        prices.forEach(price => {
            const key = price.name;
            if (!priceMap[key] || (priceMap[key].price > price.price)) {
                // Keep the lowest price (typically on-demand Linux)
                priceMap[key] = price;
            }
        });
        
        // Merge price info with specs
        return specs.map(spec => {
            const priceInfo = priceMap[spec.name];
            return {
                ...spec,
                price_per_hour: priceInfo ? priceInfo.price : null,
                price_currency: priceInfo ? priceInfo.currency : null,
                price_description: priceInfo ? priceInfo.price_description : null,
                unit: priceInfo ? priceInfo.unit : null
            };
        });
    }

    function displaySpecs(specs) {
        const container = document.getElementById('spec-list-container');
        
        if (specs.length === 0) {
            container.innerHTML = '<div class="no-data-message">No VM specs found matching the filters.</div>';
            return;
        }

        // Helper function to display value or NA
        const displayValue = (value) => {
            if (value === -1 || value === '-' || value === '-1' || !value || value === 0) return '<span style="color: #999;">NA</span>';
            return value;
        };
        
        const displayNumeric = (value) => {
            if (value === -1 || value === '-' || value === '-1' || !value) return '<span style="color: #999;">NA</span>';
            return typeof value === 'number' ? value.toLocaleString() : value;
        };

        // Helper function to create sortable header
        const createSortableSpecHeader = (label, field, style = '') => {
            const isActive = specSortField === field;
            const arrow = isActive ? (specSortOrder === 'asc' ? ' ‚ñ≤' : ' ‚ñº') : '';
            const baseStyle = 'cursor: pointer; user-select: none;';
            const finalStyle = style ? `${baseStyle} ${style}` : baseStyle;
            return `<th onclick="sortSpecs('${field}')" style="${finalStyle}" title="Click to sort">${label}${arrow}</th>`;
        };

        let tableHTML = `
            <table class="selection-table">
                <colgroup>
                    <col style="width: 40px;">
                    <col style="width: 180px;">
                    <col style="width: 70px;">
                    <col style="width: 110px;">
                    <col style="width: 85px;">
                    <col style="width: 50px;">
                    <col style="width: 90px;">
                    <col style="width: 150px;">
                    <col style="width: 130px;">
                </colgroup>
                <thead>
                    <tr>
                        <th>#</th>
                        ${createSortableSpecHeader('Name', 'name')}
                        ${createSortableSpecHeader('vCPU', 'vcpu_count')}
                        ${createSortableSpecHeader('Memory (MiB)', 'mem_size_mib')}
                        ${createSortableSpecHeader('Disk (GB)', 'disk_size_gb')}
                        ${createSortableSpecHeader('GPU', 'gpu_count', 'background-color: #e8f4f8;')}
                        ${createSortableSpecHeader('Memory (GB)', 'gpu_mem_size_gb', 'background-color: #e8f4f8;')}
                        ${createSortableSpecHeader('Model', 'gpu_model', 'background-color: #e8f4f8;')}
                        <th onclick="sortSpecsByPrice()" style="cursor: pointer; user-select: none; background-color: #fff4e6;" title="Click to sort">
                            Price/Hour${specSortField === 'price_per_hour' ? (specSortOrder === 'asc' ? ' ‚ñ≤' : ' ‚ñº') : ''}
                            <span onclick="event.stopPropagation(); showPriceInfoOverlay()" style="cursor: pointer; color: #007bff; font-weight: bold; margin-left: 5px;" title="Click for price info details">‚ìò</span>
                        </th>
                    </tr>
                </thead>
                <tbody>
        `;

        specs.forEach((spec, index) => {
            const rowNumber = currentSpecPage * ITEMS_PER_PAGE + index + 1;
            
            // Format vCPU with clock
            let vcpuDisplay = displayNumeric(spec.vcpu_count);
            if (spec.vcpu_clock_ghz && spec.vcpu_clock_ghz !== -1 && spec.vcpu_clock_ghz !== '-' && spec.vcpu_clock_ghz !== 'NA') {
                vcpuDisplay += ` <span style="color: #666;">(${spec.vcpu_clock_ghz}GHz)</span>`;
            }
            
            // Format price display
            let priceDisplay = '<span style="color: #999;">NA</span>';
            if (spec.price_per_hour !== null && spec.price_per_hour !== undefined) {
                const priceValue = parseFloat(spec.price_per_hour);
                if (!isNaN(priceValue)) {
                    priceDisplay = `$${priceValue.toFixed(4)}`;
                    // Add On-Demand or Spot type if available
                    const details = [];
                    if (spec.price_description) {
                        const desc = spec.price_description.toLowerCase();
                        if (desc.includes('on-demand') || desc.includes('ondemand')) details.push('On-Demand');
                        else if (desc.includes('spot')) details.push('Spot');
                    }
                    if (details.length > 0) {
                        priceDisplay += ` <span style="color: #999; font-size: 0.85em;">(${details.join(', ')})</span>`;
                    }
                }
            }
            
            // Format GPU Model display
            let gpuModelDisplay = spec.gpu_model === 'NA' || !spec.gpu_model 
                ? '<span style="color: #999;">NA</span>' 
                : spec.gpu_model;
            
            tableHTML += `
                <tr>
                    <td style="color: #6c757d;">${rowNumber}</td>
                    <td><a href="javascript:void(0)" onclick='selectSpec("${spec.name}")' title="Click to select this spec" style="cursor: pointer; color: #007bff; text-decoration: underline;">${spec.name}</a></td>
                    <td>${vcpuDisplay}</td>
                    <td>${displayNumeric(spec.mem_size_mib)}</td>
                    <td>${displayNumeric(spec.disk_size_gb)}</td>
                    <td>${spec.gpu_count > 0 ? spec.gpu_count : '<span style="color: #999;">NA</span>'}</td>
                    <td>${displayNumeric(spec.gpu_mem_size_gb)}</td>
                    <td>${gpuModelDisplay}</td>
                    <td>${priceDisplay}</td>
                </tr>
            `;
        });

        tableHTML += '</tbody></table>';
        container.innerHTML = tableHTML;
    }

    function sortSpecs(field) {
        if (specSortField === field) {
            // Toggle sort order if clicking the same field
            specSortOrder = specSortOrder === 'asc' ? 'desc' : 'asc';
        } else {
            // Set new field and default to ascending
            specSortField = field;
            specSortOrder = 'asc';
        }
        // Reset to first page when sorting changes
        currentSpecPage = 0;
        loadSpecs();
    }

    function selectSpec(specName) {
        document.getElementById('vmSpecName').value = specName;
        closeSpecSelectionOverlay();
    }

    function sortSpecsByPrice() {
        if (specSortField === 'price_per_hour') {
            // Toggle sort order if clicking the same field
            specSortOrder = specSortOrder === 'asc' ? 'desc' : 'asc';
        } else {
            // Set new field and default to ascending
            specSortField = 'price_per_hour';
            specSortOrder = 'asc';
        }
        // Reset to first page when sorting changes
        currentSpecPage = 0;
        loadSpecs();
    }

    function loadSpecPage(direction) {
        if (direction === 'next' && (currentSpecPage + 1) * ITEMS_PER_PAGE < specTotalCount) {
            currentSpecPage++;
            loadSpecs();
        } else if (direction === 'prev' && currentSpecPage > 0) {
            currentSpecPage--;
            loadSpecs();
        }
    }

    function updateSpecPagination(dataVersion) {
        const pagination = document.getElementById('spec-pagination');
        const pageInfo = document.getElementById('spec-page-info');
        const totalInfo = document.getElementById('spec-total-info');
        const versionInfo = document.getElementById('spec-data-version');
        const prevBtn = document.getElementById('spec-prev-btn');
        const nextBtn = document.getElementById('spec-next-btn');

        const totalPages = Math.ceil(specTotalCount / ITEMS_PER_PAGE);
        pageInfo.textContent = `${currentSpecPage + 1} / ${totalPages}`;
        totalInfo.textContent = `Total: ${specTotalCount.toLocaleString()}`;
        
        if (dataVersion) {
            let formattedDate = dataVersion;
            try {
                // Parse format: YYYYMMDD-HHMMSS
                const match = dataVersion.match(/(\d{4})(\d{2})(\d{2})-(\d{2})(\d{2})(\d{2})/);
                if (match) {
                    const year = match[1];
                    const month = parseInt(match[2]) - 1; // 0-based
                    const day = match[3];
                    const hour = match[4];
                    const minute = match[5];
                    const second = match[6];
                    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    formattedDate = `${months[month]} ${parseInt(day)}, ${year}, ${hour}:${minute}:${second}`;
                }
            } catch (e) {
                // If parsing fails, use the raw value
            }
            versionInfo.textContent = ` (data_ver: ${formattedDate})`;
        }

        prevBtn.disabled = currentSpecPage === 0;
        nextBtn.disabled = (currentSpecPage + 1) * ITEMS_PER_PAGE >= specTotalCount;

        pagination.style.display = specTotalCount > 0 ? 'flex' : 'none';
    }

</script>

</html>
