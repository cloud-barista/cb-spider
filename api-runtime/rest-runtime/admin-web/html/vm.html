<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>VM Management</title>
<link rel="stylesheet" href="/spider/adminweb/static/css/xterm.css" />
<script src="/spider/adminweb/static/js/xterm.js"></script>
<!--
Copyright (c) 2017-2019, The xterm.js authors (https://github.com/xtermjs/xterm.js)
Copyright (c) 2014-2016, SourceLair Private Company (https://www.sourcelair.com)
Copyright (c) 2012-2013, Christopher Jeffrey (https://github.com/chjj/)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
-->
<style>
    /* General Styles */
    body {
        font-family: Arial, sans-serif;
        font-size: 12px;
    }
    
    /* Placeholder Styles */
    input::placeholder,
    textarea::placeholder {
        color: #c0c0c0;
        opacity: 1;
    }
    
    /* Loading Spinner */
    .global-loading-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
        z-index: 10000;
    }
    
    .loading-spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .header-container {
        display: flex;
        align-items: flex-end;
    }
    .header-container img {
        margin-right: 10px;
        height: 28px;
    }
    .header-container h1 {
        font-size: 16px;
        margin: 0;
    }
    h2, h3 {
        margin: 10px 0;
    }
    h2 {
        font-size: 16px;
    }
    h3 {
        font-size: 14px;
        margin-left: 1cm;
    }
    .content {
        margin-top: 70px;
    }
    #searchInput {
        width: 190px;
        padding-right: 2.5cm;
    }
    #clearSearch {
        position: absolute;
        right: 0.1cm;
        top: 50%;
        transform: translateY(-50%);
        border: none;
        background-color: transparent;
        cursor: pointer;
    }
    .searchContainer {
        position: relative;
        display: flex;
        align-items: center;
        padding-left: 0.5cm;
    }
    .searchContainer button {
        position: absolute;
        right: 0.5cm;
        top: 50%;
        transform: translateY(-50%);
        border: none;
        background-color: transparent;
        cursor: pointer;
    }
    .fixed-header {
        position: fixed;
        top: 0;
        width: 97%;
        background-color: white;
        z-index: 1000;
        display: flex;
        justify-content: space-between;
        padding: 10px 20px;
        align-items: center;
        box-shadow: 0 4px 6px -6px #222;
    }
    .fixed-action-buttons {
        display: flex;
        align-items: center;
    }
    .fixed-action-buttons button {
        margin-left: 10px;
    }
    .header-with-progress {
        display: flex;
        align-items: center;
        margin-bottom: 0px;
    }
    .progress-bar-container {
        width: 600px;
        margin-left: 10px;
        margin-bottom: 10px;
        height: 22px;
        background-color: #f0f5ff;
        border-radius: 4px;
        overflow: hidden;
        display: none;
        position: relative;
        z-index: 20;
    }
    .progress-bar {
        width: 0;
        height: 100%;
        background-color: #cce6ff;
        border-radius: 4px;
        transition: width 3s ease;
    }
    #timeDisplay {
        position: absolute;
        top: 50%;
        right: 10px;
        transform: translateY(-50%);
        font-size: 14px;
        color: #333;
        z-index: 30;
    }
    .add-button {
        font-size: 14px;
        font-weight: bold;
        margin-left: 1px;
        margin-right: 5px;
        margin-bottom: 10px;
    }
    .mock-add-button {
        margin-right: 1px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
        table-layout: fixed;
        margin-bottom: 0;
    }
    th, td {
        border: 1px solid black;
        padding: 6px;
        position: relative;
    }
    th {
        background-color: #f2f2f2;
        font-size: 14px;
        text-align: center;
    }
    td {
        text-align: left;
    }
    .column-num {
        width: 5%;
        text-align: center;
    }
    .center-align {
        text-align: center;
    }
    .fingerprint {
        width: 30%;
    }
    .check-column {
        width: 5%;
        text-align: center;
    }
    .highlight {
        background-color: #fffab6;
    }
    .misc {
        width: 15%;
    }
    .overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        justify-content: center;
        align-items: center;
    }
    .overlay-content {
        background-color: white;
        padding: 20px;
        border-radius: 5px;
        text-align: left;
        position: relative;
    }
    .tag-container {
        display: inline-block;
        background-color: #e1e1e1;
        border-radius: 3px;
        padding: 2px 5px;
        margin: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        cursor: pointer;
        max-width: calc(100% - 2ch);
    }
    .tag-container:hover {
        background-color: #c1e1c1;
    }
    .form-group {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }
    .form-group-container {
        border: 1px solid #d0d0d0;
        border-radius: 4px;
        padding: 10px;
        margin-bottom: 10px;
        background-color: #f9f9f9;
        position: relative;
    }
    .form-group-recent-btn {
        position: absolute;
        top: 2px;
        left: 4px;
        font-size: 11px;
        padding: 1px 5px;
        border: 1px solid #89b4d1;
        background-color: #e3f2fd;
        border-radius: 2px;
        cursor: pointer;
        z-index: 1;
        color: #1565c0;
    }
    .form-group-recent-btn:hover {
        background-color: #bbdefb;
        border-color: #1565c0;
    }
    .form-group-favorite-btn {
        position: absolute;
        top: 2px;
        right: 4px;
        font-size: 11px;
        padding: 1px 5px;
        border: 1px solid #b8860b;
        background-color: #fffef0;
        border-radius: 2px;
        cursor: pointer;
        z-index: 1;
        color: #8b6914;
    }
    .form-group-favorite-btn:hover {
        background-color: #fffacd;
        border-color: #8b6914;
    }
    .overlay-import-btn {
        font-size: 12px;
        padding: 3px 10px;
        border: 1px solid #4caf50;
        background-color: #e8f5e9;
        border-radius: 3px;
        cursor: pointer;
        color: #2e7d32;
        margin-left: 8px;
    }
    .overlay-import-btn:hover {
        background-color: #c8e6c9;
        border-color: #2e7d32;
    }
    .overlay-export-btn {
        font-size: 12px;
        padding: 3px 10px;
        border: 1px solid #ff9800;
        background-color: #fff3e0;
        border-radius: 3px;
        cursor: pointer;
        color: #e65100;
        margin-left: 8px;
    }
    .overlay-export-btn:hover {
        background-color: #ffe0b2;
        border-color: #e65100;
    }
    .form-group-container .form-group {
        margin-bottom: 5px;
    }
    .form-group-container .form-group:first-of-type {
        margin-top: 16px;
    }
    .form-group-container .form-group:last-child {
        margin-bottom: 0;
    }
    .form-group label {
        flex: 1;
        text-align: right;
        margin-right: 10px;
    }
    .form-group input, .form-group textarea {
        flex: 2;
    }
    .form-group button {
        margin-left: 10px;
    }
    .tag-input-group {
        display: flex;
        align-items: center;
        flex: 2;
    }
    .tag-input-group input {
        width: 100px;
        flex: 0.5;
        margin-right: 5px;
    }
    .tag-input-group button {
        margin-left: 5px;
    }
    #vm-tag-container {
        display: flex;
        flex-direction: column;
    }
    .tag-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    .tag-overlay-content {
        background-color: white;
        padding: 20px;
        border-radius: 5px;
        text-align: left;
        font-size: 14px;
        max-width: 300px;
        word-wrap: break-word;
        position: relative;
    }
    .overlay-close-btn {
        background-color: #f0f0f0;
        color: #d9534f;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        position: absolute;
        top: 10px;
        right: 10px;
    }
    .overlay-close-btn:hover {
        background-color: #e0e0e0;
    }
    .tag-overlay-content .button-group {
        display: flex;
        justify-content: space-between;
        margin-top: 20px;
    }
    .misc-content {
        max-height: 2.5em;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    .more-btn {
        display: none;
        background-color: transparent;
        border: none;
        color: blue;
        text-decoration: underline;
        cursor: pointer;
    }
    .misc-cell {
        position: relative;
    }
    .misc-cell .more-btn {
        position: absolute;
        right: 5px;
        bottom: 5px;
    }
    .vm-control-buttons a {
        font-size: 12px;
        color: #007bff;
        text-decoration: none;
        margin: 0 5px;
    }
    .vm-control-buttons a:hover {
        text-decoration: underline;
        color: #0056b3;
    }
    .vm-control-buttons input[type="text"] {
        width: 120px;
        padding: 3px;
        font-size: 12px;
        margin-right: 5px;
        border-radius: 4px;
        border: 1px solid #ccc;
    }
    .vm-control-buttons button {
        font-size: 12px;
        padding: 3px 8px;
        border-radius: 4px;
        border: 1px solid #007bff;
        background-color: #007bff;
        color: #fff;
        cursor: pointer;
    }
    .vm-control-buttons button:hover {
        background-color: #0056b3;
        border-color: #0056b3;
    }
    /* New Styles for Table Layout */
    .vm-name-cell {
        text-align: left;
        font-size: 13px;
        font-weight: bold;
    }

    .vm-system-id {
        display: block;
        font-size: 12px;
        font-weight: normal;
        color: #666;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        cursor: pointer;
    }

    .system-id-overlay {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50%;
        max-width: 600px;
        background-color: white;
        border: 1px solid black;
        padding: 20px;
        z-index: 2000;
        border-radius: 5px;
    }

    .system-id-overlay-content {
        position: relative;
        font-family: Arial, sans-serif;
        font-size: 14px;
        word-wrap: break-word;
    }



    .copy-btn {
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
        margin-left: 10px;
    }

    .vm-name-cell .vm-start-time {
        display: block;
        font-size: 12px;
        font-weight: normal;
        color: #666;
    }
    .ssh-access-cell {
        text-align: left;
    }
    .copy-icon-btn {
        background: none;
        border: none;
        cursor: pointer;
        padding: 0;
        transition: transform 0.2s ease, color 0.2s ease;
    }
    .copy-icon-btn:hover {
        transform: scale(1.2);
        color: #007bff;
    }
    .ssh-connect-btn {
        display: inline-block;
        margin-top: 5px;
        color: #007bff;
        cursor: pointer;
        text-decoration: underline;
        font-size: 12px;
    }
    .ssh-terminal-style {
        font-family: 'Courier New', Courier, monospace;
        background-color: #333;
        color: #ffffff;
        padding: 2px 4px;
        border-radius: 4px;
        display: inline-block;
    }
    .snapshot-cell {
        text-align: center;
    }
    .provisioning-info-link {
        cursor: pointer;
        color: #007bff;
        text-decoration: underline;
        font-size: 12px;
    }
    .provisioning-info-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    .provisioning-info-overlay-content {
        position: relative;
        padding-top: 40px;
        background-color: white;
        padding: 20px;
        border-radius: 5px;
        width: 80%;
        max-width: 600px;
        overflow-y: auto;
    }
    .provisioning-info-overlay-content table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 20px;
    }
    .provisioning-info-overlay-content h3 {
        font-size: 18px;
        margin-bottom: 15px;
    }
    .provisioning-info-overlay-content table th {
        width: 25%;
        font-size: 14px;
    }
    .provisioning-info-overlay-content table td {
        width: 75%;
        font-size: 14px;
    }
    .bullet-list {
        list-style-type: none;
        padding-left: 0;
    }
    .bullet-list li {
        margin-bottom: 8px;
    }
    .bullet-list li::before {
        content: '‚Ä¢';
        color: black;
        display: inline-block;
        width: 1em;
        margin-right: 5px;
    }

    #miscOverlay .overlay-content {
        font-size: 14px;
        width: 700px;
        position: relative;
        padding-top: 30px;
        line-height: 1.5;
        white-space: pre-wrap;
    }

    .snapshot-cell input[type="text"] {
        width: 50%;
    }
    .snapshot-cell button {
        font-size: 12px;
        padding: 3px 8px;
        border-radius: 4px;
        border: 1px solid #007bff;
        background-color: #007bff;
        color: #fff;
        cursor: pointer;
    }
    .snapshot-cell button:hover {
        background-color: #0056b3;
        border-color: #0056b3;
    }
    .add-btn-container {
        margin-top: 5px;
    }
    .add-btn-container .add-btn {
        background-color: transparent;
        font-size: 14px;
        font-weight: bold;
        border: none;
        color: blue;
        text-decoration: underline;
        cursor: pointer;
    }
    .add-tag-overlay-content {
        background-color: white;
        padding: 20px;
        border-radius: 5px;
        text-align: left;
        font-size: 14px;
        max-width: 300px;
        word-wrap: break-word;
        position: relative;
    }
    .add-tag-overlay-content .tag-overlay-input-group {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }
    .add-tag-overlay-content .tag-overlay-input-group:first-of-type {
        margin-top: 30px;
    }
    .add-tag-overlay-content .tag-overlay-input-group label {
        flex: 1;
        text-align: right;
        margin-right: 10px;
    }
    .add-tag-overlay-content .tag-overlay-input-group input {
        flex: 2;
    }
    .add-tag-overlay-content .tag-overlay-button-group {
        display: flex;
        justify-content: space-between;
        margin-top: 20px;
    }
    .vm-action-btn {
        font-size: 18px !important;
        background: none !important;
        background-color: transparent !important;
        border: none !important;
        cursor: pointer;
        padding: 0 !important;
        margin: 0 !important;
        transition: transform 0.2s ease;
        box-shadow: none !important;
    }
    .vm-action-btn:hover {
        transform: scale(1.2);
    }

    .drop-zone, #privatekey {
        width: 100%;
        border-radius: 4px;
        box-sizing: border-box;
    }
    .drop-zone {
        border: 2px dashed #ddd;
        padding: 20px;
        text-align: center;
        color: #aaa;
        margin-top: 5px;
        margin-bottom: 10px;
        cursor: pointer;
        background-color: #f9f9f9;
    }
    .drop-zone.dragover {
        border-color: #aaa;
        color: #000;
        background-color: #e3e3e3;
    }
    #privatekey {
        background-color: #fff5f5;
        padding: 10px;
        margin-bottom: 20px;
        resize: none; /* Optional: Prevent resizing */
        font-family: inherit;
        font-size: 12px;
    }

    .progress-message {
        background-color: #e6f7ff;
        color: #000;
        padding: 5px;
        border-radius: 4px;
        display: inline-block;
        position: relative;
        overflow: hidden;
    }

    .progress-message::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 100%;
        background-color: #e6f7ff; /* Progress bar color */
        transform: translateX(-100%);
        animation: progress-animation 3s linear infinite;
    }
    .checkbox-wrapper {
        display: block;
        margin-right: 0px; 
    }

    .checkbox-wrapper input[type="checkbox"] {
        margin-right: 5px;
    }

    #dataDiskSelect {
        border: 1px solid #767676;
        padding: 2px 5px;
        flex: 2;
        overflow-y: auto;
        overflow-x: auto;
        margin: 0 auto;
        white-space: normal;
        max-height: 80px;
    }

    /* Custom dropdown for Data Disks */
    .dd-custom-select {
        position: relative;
        flex: 2;
    }

    .dd-selected-display {
        background-color: #f3f3fd;
        border: 1px solid #767676;
        padding: 2px 8px 2px 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        min-height: 22px;
    }

    .dd-selected-display:hover {
        border-color: #555;
    }

    .dd-selected-display span:first-child {
        font-size: 14px;
        text-align: left;
        flex: 1;
    }

    .dd-dropdown-arrow {
        font-size: 12px;
        font-weight: bold;
        color: #666;
        margin-left: 5px;
    }

    .dd-dropdown-list {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #767676;
        border-top: none;
        max-height: 150px;
        overflow-y: auto;
        z-index: 1000;
        display: none;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        padding: 0;
        margin: 0;
    }

    .dd-dropdown-list * {
        box-sizing: border-box;
    }

    .dd-dropdown-list.open {
        display: block;
    }

    .dd-dropdown-item {
        padding: 3px;
        margin: 0;
        cursor: pointer;
        display: block;
        line-height: 20px;
    }

    .dd-dropdown-item:hover {
        background-color: #f0f0f0;
    }

    .dd-dropdown-item input[type="checkbox"] {
        margin: 0;
        padding: 0;
        vertical-align: middle;
        width: 13px;
        height: 13px;
        display: inline-block;
    }

    .dd-dropdown-item label {
        cursor: pointer;
        margin: 0;
        padding-left: 5px;
        display: inline-block;
        vertical-align: middle;
    }

    /* Custom dropdown for Security Groups */
    .sg-custom-select {
        position: relative;
        flex: 2;
    }

    .sg-selected-display {
        background-color: #f3f3fd;
        border: 1px solid #767676;
        padding: 2px 8px 2px 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        min-height: 22px;
    }

    .sg-selected-display:hover {
        border-color: #555;
    }

    .sg-selected-display span:first-child {
        font-size: 14px;
        text-align: left;
        flex: 1;
    }

    .sg-dropdown-arrow {
        font-size: 12px;
        font-weight: bold;
        color: #666;
        margin-left: 5px;
    }

    .sg-dropdown-list {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #767676;
        border-top: none;
        max-height: 150px;
        overflow-y: auto;
        z-index: 1000;
        display: none;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        padding: 0;
        margin: 0;
    }

    .sg-dropdown-list * {
        box-sizing: border-box;
    }

    .sg-dropdown-list.open {
        display: block;
    }

    .sg-dropdown-item {
        padding: 3px;
        margin: 0;
        cursor: pointer;
        display: block;
        line-height: 20px;
    }

    .sg-dropdown-item:hover {
        background-color: #f0f0f0;
    }

    .sg-dropdown-item input[type="checkbox"] {
        margin: 0;
        padding: 0;
        vertical-align: middle;
        width: 13px;
        height: 13px;
        display: inline-block;
    }

    .sg-dropdown-item label {
        cursor: pointer;
        margin: 0;
        padding-left: 5px;
        display: inline-block;
        vertical-align: middle;
    }

    #dataDiskSelect p, .sg-custom-select p {
        margin: 2px 0;
        font-size: 12px;
    }

    #securityGroupSelect {
        background-color: #f3f3fd;
    }

    @keyframes progress-animation {
        0% {
            transform: translateX(-100%);
        }
        100% {
            transform: translateX(100%);
        }
    }

    /* Image and Spec Selection Overlays */
    .selection-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        justify-content: center;
        align-items: center;
        z-index: 2000;
    }

    .selection-overlay-content {
        background-color: white;
        padding: 20px;
        border-radius: 5px;
        width: 90%;
        max-width: 1200px;
        max-height: 90vh;
        overflow-y: auto;
        position: relative;
    }

    .table-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 100;
        font-size: 14px;
        color: #666;
    }

    .table-loading-overlay.active {
        display: flex;
    }

    .filter-section {
        background: linear-gradient(135deg, #f8f9fa 0%, #f1f3f5 100%);
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 25px;
        border: 1px solid #dee2e6;
    }

    .filter-section h3 {
        color: #495057;
        font-size: 14px;
        font-weight: 600;
        margin: 0 0 15px 0;
        padding-bottom: 10px;
        border-bottom: 1px solid #dee2e6;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .filter-section h3::before {
        content: "üîç";
        font-size: 14px;
    }

    .filter-row {
        display: flex;
        gap: 12px;
        margin-bottom: 12px;
        flex-wrap: wrap;
    }

    .filter-item {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-width: 150px;
    }

    .filter-item label {
        font-size: 12px;
        font-weight: 500;
        margin-bottom: 6px;
        color: #495057;
    }

    .filter-item select,
    .filter-item input {
        padding: 6px 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 12px;
        background-color: white;
    }

    .filter-item select:focus,
    .filter-item input:focus {
        outline: none;
        border-color: #80bdff;
    }

    .filter-item select:disabled {
        background-color: #f0f0f0;
        cursor: not-allowed;
    }

    .filter-buttons {
        display: flex;
        gap: 10px;
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #dee2e6;
    }

    .filter-buttons button {
        flex: 1;
        padding: 8px 16px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 12px;
        font-weight: normal;
        cursor: pointer;
        background-color: white;
    }

    .filter-buttons button:first-child {
        background-color: #e7f3ff;
        color: #0066cc;
        border-color: #99ccff;
    }

    .filter-buttons button:first-child:hover {
        background-color: #cce6ff;
        border-color: #66b3ff;
    }

    .filter-buttons button:last-child {
        background-color: white;
        color: #333;
    }

    .filter-buttons button:last-child:hover {
        background-color: #f8f9fa;
    }

    .selection-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
        font-size: 12px;
    }

    .selection-table th,
    .selection-table td {
        border: 1px solid black;
        padding: 2px 6px;
        text-align: center;
        line-height: 1.2;
    }

    .selection-table th {
        background-color: #f2f2f2;
        color: black;
        font-size: 14px;
        text-align: center;
        position: sticky;
        top: 0;
        z-index: 10;
    }

    .selection-table th:first-child,
    .selection-table td:first-child {
        width: 50px;
    }

    .selection-table th:nth-child(2) {
        max-width: 300px;
        text-align: center;
    }

    .selection-table td:nth-child(2) {
        max-width: 300px;
        white-space: normal;
        word-break: break-all;
        text-align: left;
    }

    .selection-table th:nth-child(3),
    .selection-table td:nth-child(3) {
        width: 80px;
    }

    .selection-table th:nth-child(4),
    .selection-table td:nth-child(4) {
        width: 90px;
    }

    .selection-table th:nth-child(5),
    .selection-table td:nth-child(5) {
        width: 160px;
    }

    .selection-table th:nth-child(6),
    .selection-table td:nth-child(6) {
        width: 90px;
    }

    .selection-table th:nth-child(7),
    .selection-table td:nth-child(7) {
        width: 80px;
    }

    .selection-table th:last-child,
    .selection-table td:last-child {
        width: 70px;
    }

    .selection-table tr:hover {
        background-color: #f5f5f5;
        cursor: pointer;
    }

    .selection-table tr.selected {
        background-color: #fffab6;
    }

    .select-btn {
        background-color: white;
        color: black;
        border: 1px solid #ccc;
        padding: 3px 8px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
    }

    .select-btn:hover {
        background-color: #f0f0f0;
    }

    .clear-filter-btn {
        background-color: white;
        color: black;
        border: 1px solid #ddd;
        padding: 1px 4px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 10px;
        font-weight: normal;
        line-height: 1;
    }

    .clear-filter-btn:hover {
        background-color: #f0f0f0;
        border-color: #ccc;
    }

    .preset-btn {
        background-color: #f0f4ff;
        color: black;
        border: 1px solid #ccc;
        padding: 5px 8px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s ease;
        min-width: 130px;
        text-align: center;
    }

    .preset-btn:hover {
        background-color: #e0e8f8;
        border-color: #ccc;
    }

    .loading-message {
        text-align: center;
        padding: 20px;
        font-size: 14px;
        color: #666;
    }

    #image-list-container,
    #spec-list-container {
        position: relative;
        min-height: 400px;
    }

    .no-data-message {
        text-align: center;
        padding: 20px;
        font-size: 14px;
        color: #999;
    }

    .pagination-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 15px;
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 4px;
    }

    .pagination-info-left {
        font-size: 14px;
        color: #495057;
    }

    .pagination-info-left .total-count {
        font-weight: bold;
        color: #212529;
    }

    .pagination-info-left .data-version {
        color: #6c757d;
        font-size: 13px;
    }

    .pagination-nav-right {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .pagination-controls button {
        padding: 6px 12px;
        border: 1px solid #ccc;
        background-color: white;
        color: #495057;
        border-radius: 3px;
        cursor: pointer;
        font-size: 16px;
    }

    .pagination-controls button:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }

    .pagination-controls button:hover:not(:disabled) {
        background-color: #e9ecef;
        border-color: #adb5bd;
    }

    .pagination-page-info {
        font-size: 14px;
        color: #495057;
        min-width: 70px;
        text-align: center;
    }

    .powered-by-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 11px;
        color: #6c757d;
        margin-left: 15px;
        padding: 3px 8px;
        background-color: #f8f9fa;
        border-radius: 4px;
        border: 1px solid #dee2e6;
    }

    .powered-by-badge::before {
        content: "‚ö°";
        font-size: 13px;
    }

    .powered-by-badge a {
        color: #0066cc;
        text-decoration: none;
        font-weight: 500;
    }

    .powered-by-badge a:hover {
        text-decoration: underline;
    }

    .os-info-display {
        display: none;
        flex: 10;
        gap: 8px;
        align-items: center;
        justify-content: flex-start;
    }

    .os-info-display.active {
        display: flex;
    }

    .os-info-box {
        background-color: #ffffe6;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
        color: #333;
        text-align: center;
        border: 1px solid #ffdd66;
        box-shadow: 0 0 3px rgba(255, 204, 0, 0.3);
        width: 16ch;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .spec-info-display {
        display: none;
        flex: 10;
        gap: 8px;
        align-items: center;
        justify-content: flex-start;
    }

    .spec-info-display.active {
        display: flex;
    }

    .spec-info-box {
        background-color: #f8fcff;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
        color: #333;
        text-align: center;
        border: 1px solid #99ddff;
        box-shadow: 0 0 3px rgba(102, 204, 255, 0.3);
        width: 16ch;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
</style>
</head>
<body>
    <div class="fixed-header">
        <div class="header-container">
            <img src="/spider/adminweb/images/left-menu/vm.png" alt="VM Icon">
            <h1>VM Management</h1>
            <div class="searchContainer">
                <input type="text" id="searchInput" onkeyup="searchKeyword()" placeholder="Search Keyword...">
                <button id="clearSearch" onclick="clearSearchInput()">X</button>
            </div>
        </div>        
        <div class="fixed-action-buttons">
            <input type="checkbox" onclick="toggleSelectAll(this)">
            <button onclick="deleteSelectedVMs()">Delete</button>
        </div>
    </div>

    <div class="content">
        <div class="header-with-progress">
            <button class="add-button" onclick="showOverlay()">+ VM</button>
            <div id="mockButtonsContainer" style="display: flex; align-items: center;"></div>
            <div class="progress-bar-container" id="progressBarContainer">
                <div class="progress-bar" id="progressBar"></div>
                <span id="timeDisplay"></span>
            </div>                       
        </div>
        <table id="vm-table">
            <tr>
                <th class="column-num">#</th>
                <th class="center-align">Name</th>
                <th class="center-align">SSH Access</th>
                <th class="center-align">Status | Actions</th>
                <th class="center-align">Snapshot</th>
                <th class="center-align">Provisioning Info</th>
                <th class="center-align">Tags</th>
                <th class="center-align">Misc</th>
                <th class="check-column">
                    <input type="checkbox" onclick="toggleSelectAll(this)">
                </th>
            </tr>
            {{range $index, $vm := .VMs}}
            <tr>
                <td class="column-num">{{$index | inc}}</td>
                <td class="vm-name-cell">
                    {{$vm.IId.NameId}}<span class="vm-system-id" onclick="showSystemIdOverlay('{{$vm.IId.SystemId}}')">&nbsp;‚Ä¢ {{$vm.IId.SystemId}}</span>
                    <span class="vm-start-time" data-time="{{$vm.StartTime}}"></span>
                </td>    
                <td class="ssh-access-cell">
                    {{if $vm.PublicIP}}
                    ‚Ä¢ Public IP: {{$vm.PublicIP}}
                    <button class="copy-icon-btn" onclick="copyToClipboard('{{$vm.PublicIP}}')">
                        üìã
                    </button>
                    <br> ‚Ä¢ 
                    <div class="ssh-connect-btn" 
                        onclick="openSSHAccess({ vmUserId: '{{$vm.VMUserId}}', publicIP: '{{$vm.PublicIP}}', keyName: '{{$vm.KeyPairIId.NameId}}' });">
                        <span class="ssh-terminal-style">SSH: {{$vm.PublicIP}}</span>
                    </div>
                    {{end}}
                </td>                                      
                <td id="vmcontrol-{{$vm.IId.NameId}}" class="center-align vm-control-buttons">
                    {{if $vm.VMSpecName}}
                        {{if eq (index $.VMStatusMap $vm.IId.NameId) "Running"}}
                            <div style="display: inline-flex; align-items: center;">
                                <span style="margin-right: 8px;">Running &nbsp; |</span>
                                <button class="vm-action-btn" onclick="vmControl('{{$.ConnectionConfig}}', '{{$vm.IId.NameId}}', 'suspend')">‚è∏Ô∏è</button>
                                <button class="vm-action-btn" onclick="vmControl('{{$.ConnectionConfig}}', '{{$vm.IId.NameId}}', 'reboot')">&nbsp;üîÑ</button>
                            </div>
                        {{else if eq (index $.VMStatusMap $vm.IId.NameId) "Suspended"}}
                            <div style="display: inline-flex; align-items: center;">
                                <span style="margin-right: 8px;">Suspended &nbsp; |</span>
                                <button class="vm-action-btn" onclick="vmControl('{{$.ConnectionConfig}}', '{{$vm.IId.NameId}}', 'resume')">‚èØÔ∏è</button>
                            </div>
                        {{else}}
                            <div style="display: inline-flex; align-items: center;">
                                <span style="margin-right: 8px;">{{index $.VMStatusMap $vm.IId.NameId}}</span>
                                
                            </div>
                        {{end}}
                    {{end}}
                </td>                                
                <td class="snapshot-cell">
                    {{if $vm.VMSpecName}}
                    <input type="text" id="snapshot-name-{{$vm.IId.NameId}}" value="myimage-1">
                    <button type="button" onclick="postSnapshotVM('{{$.ConnectionConfig}}', '{{$vm.IId.NameId}}', document.getElementById('snapshot-name-{{$vm.IId.NameId}}').value)">Snap</button>
                    {{end}}
                </td>
                <td class="center-align provisioning-info-cell">
                    {{if $vm.VMSpecName}}
                        <a class="provisioning-info-link" onclick="showProvisioningInfoOverlay({
                            vpcName: '{{$vm.VpcIID.NameId}}',
                            subnetName: '{{$vm.SubnetIID.NameId}}',
                            zone: '{{$vm.Region.Zone}}',
                            securityGroupName: ['{{range $index, $sg := $vm.SecurityGroupIIds}}{{if $index}}, {{end}}{{$sg.NameId}}{{end}}'],
                            keypairName: '{{$vm.KeyPairIId.NameId}}',
                            vmUserId: '{{$vm.VMUserId}}',
                            imageType: '{{$vm.ImageType}}',
                            imageName: '{{$vm.ImageIId.NameId}}',
                            platform: '{{$vm.Platform}}',
                            vmSpecName: '{{$vm.VMSpecName}}',
                            rootDiskType: '{{$vm.RootDiskType}}',
                            rootDiskSize: '{{$vm.RootDiskSize}}',
                            rootDeviceName: '{{$vm.RootDeviceName}}',
                            dataDisks: ['{{range $index, $disk := $vm.DataDiskIIDs}}{{if $index}}, {{end}}{{$disk.NameId}}{{end}}'],
                            networkInterface: '{{$vm.NetworkInterface}}',
                            publicIP: '{{$vm.PublicIP}}',
                            publicDNS: '{{$vm.PublicDNS}}',
                            privateIP: '{{$vm.PrivateIP}}',
                            privateDNS: '{{$vm.PrivateDNS}}'
                        })">View Details</a>                    
                    {{end}}
                </td>
                <td>
                    {{if $vm.VMSpecName}}
                        {{range $tag := $vm.TagList}}
                        <div class="tag-container" onclick="showTagOverlay(event, '{{$tag.Key}}: {{$tag.Value}}', 'VM', '{{$vm.IId.NameId}}')">{{$tag.Key}}: {{$tag.Value}}</div>
                        {{end}}
                        <div class="add-btn-container">
                            <button class="add-btn" onclick="showAddTagOverlay('{{$vm.IId.NameId}}')">+</button>
                        </div>
                    {{end}}
                </td>                
                <td class="center-align misc-cell">
                    <div class="misc-content">{{range $kv := $vm.KeyValueList}}{{$kv.Key}} : {{$kv.Value}}<br>{{end}}
                    </div>
                    {{if $vm.KeyValueList}}
                    <button class="more-btn" onclick="showMiscOverlay(this)" style="display: inline;">more...</button>
                    {{else}}
                    <button class="more-btn" style="display: none;">more...</button>
                    {{end}}
                </td>                              
                <td class="check-column">
                    <input type="checkbox" name="deleteCheckbox" value="{{$vm.IId.NameId}}">
                </td>
            </tr>
            {{end}}
            {{if not .VMs}}
            <tr>
                <td colspan="9" class="center-align">No VMs found for this connection.</td>
            </tr>
            {{end}}
        </table>       
    </div>

    <div id="overlay" class="overlay">
        <div class="overlay-content">
            <button type="button" class="overlay-close-btn" onclick="hideOverlay()">X</button>
            <h2>Add New VM</h2>
            <form id="addVMForm" onsubmit="event.preventDefault(); postVM();">
                <input type="hidden" id="connConfig" value="{{.ConnectionConfig}}">
                <div class="form-group">
                    <label for="vmName">Name:</label>
                    <input type="text" id="vmName" name="vmName" required style="color: #3366CC; font-weight: bold;">
                </div>

                <div class="form-group-container">
                    <div class="form-group">
                        <label for="vpcSelect">VPC:</label>
                        <select id="vpcSelect" name="vpcSelect" required onchange="updateSubnets(); loadSecurityGroups();" style="background-color: #f3f3fd;">
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="subnetSelect">Subnet:</label>
                        <select id="subnetSelect" name="subnetSelect" required onchange="updateSelectedSubnetZone()" style="background-color: #f3f3fd;">
                            <option value="">Please select a VPC first.</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="subnetZone">Subnet Zone:</label>
                        <input type="text" id="subnetZone" readonly disabled style="background-color: #e9ecef; cursor: not-allowed;" placeholder="Select a subnet to see its zone">
                    </div>
                </div>
                
                <div class="form-group-container">
                    <div class="form-group">
                        <label for="securityGroupSelect">Security Groups:</label>
                        <div class="sg-custom-select" id="securityGroupSelectWrapper">
                            <div class="sg-selected-display" id="sgSelectedDisplay" onclick="toggleSGDropdown()">
                                <span id="sgSelectedText">Please select a VPC first.</span>
                                <span class="sg-dropdown-arrow">v</span>
                            </div>
                            <div class="sg-dropdown-list" id="sgDropdownList"></div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="keypairSelect">KeyPair:</label>
                        <select id="keypairSelect" name="keypairSelect" required style="background-color: #f3f3fd; flex: 2;">
                        </select>
                    </div>
                </div>
                
                <div class="form-group-container">
                    <button type="button" class="form-group-recent-btn" onclick="showVMRecentOverlay()" title="View recent VMs with this image and spec">Recent</button>
                    <button type="button" class="form-group-favorite-btn" onclick="showVMFavoriteOverlay()" title="Save/Load favorite image and spec combination">Favorite</button>
                    <div class="form-group" style="margin-bottom: 8px;">
                        <label for="imageType">Image Type:</label>
                        <select id="imageType" name="imageType" required onchange="updateImageNameField()" style="background-color: #ffffe6; flex: 2;">
                            <option value="PublicImage">PublicImage</option>
                            <option value="MyImage">MyImage</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="imageName">VM Image Name:</label>
                        <div id="imageNameField" style="display: flex; flex: 2; align-items: center;">
                            <input type="text" id="imageName" name="imageName" required style="background-color: #ffffe6; flex: 1; border: 1px solid #767676; padding: 2px;">
                            <button type="button" onclick="showImageSelectionOverlay()" style="margin-left: 5px; min-width: 26px; height: 22px; padding: 0 4px; font-size: 12px; line-height: 1;">üîç</button>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="vmSpecName">VM Spec Name:</label>
                        <div style="display: flex; flex: 2; align-items: center;">
                            <input type="text" id="vmSpecName" name="vmSpecName" required style="background-color: #f8fcff; flex: 1; border: 1px solid #767676; padding: 2px;">
                            <button type="button" onclick="showSpecSelectionOverlay()" style="margin-left: 5px; min-width: 26px; height: 22px; padding: 0 4px; font-size: 12px; line-height: 1;">üîç</button>
                        </div>
                    </div>
                    
                    <div class="form-group" id="osInfoFormGroup" style="display: none;">
                        <label>&nbsp;</label>
                        <div class="os-info-display" id="osInfoDisplay"></div>
                    </div>
                    
                    <div class="form-group" id="specInfoFormGroup" style="display: none;">
                        <label>&nbsp;</label>
                        <div class="spec-info-display" id="specInfoDisplay"></div>
                    </div>
                </div>                              

                <div class="form-group-container">
                    <div class="form-group">
                        <label for="rootDiskType">Root Disk Type:</label>
                        <input type="text" id="rootDiskType" name="rootDiskType" value="default" required>
                    </div>

                    <div class="form-group">
                        <label for="rootDiskSize">Root Disk Size:</label>
                        <input type="text" id="rootDiskSize" name="rootDiskSize" placeholder="Size in GB">
                    </div>
                    
                    <div class="form-group">
                        <label for="dataDiskSelect">Data Disk Names:</label>
                        <div class="dd-custom-select" id="dataDiskSelectWrapper">
                            <div class="dd-selected-display" id="ddSelectedDisplay" onclick="toggleDDDropdown()">
                                <span id="ddSelectedText">No zone selected</span>
                                <span class="dd-dropdown-arrow">v</span>
                            </div>
                            <div class="dd-dropdown-list" id="ddDropdownList"></div>
                        </div>
                    </div>
                </div>              
                                
                <div class="form-group-container">
                    <div class="form-group">
                        <label for="vmUserId">VM User ID:</label>
                        <input type="text" id="vmUserId" name="vmUserId" placeholder="Administrator" disabled style="background-color: #e9ecef; cursor: not-allowed;">
                    </div>
                    
                    <div class="form-group">
                        <label for="vmUserPasswd">VM User Password:</label>
                        <input type="password" id="vmUserPasswd" name="vmUserPasswd" placeholder="Windows Only">
                    </div>
                </div>

                <div class="form-group" style="padding-left: 100px;">
                    <label for="vmTags">Tags:</label>
                    <div id="vm-tag-container"></div>
                    <button type="button" onclick="addVMTagField()">+</button>
                </div>
                
                <div class="form-group" style="display: flex; justify-content: center; align-items: center; margin-top: 20px;">
                    <label for="vmCount" style="margin-right: 5px;margin-left: 40px;">#:</label>
                    <input type="number" id="vmCount" name="vmCount" class="vm-count" value="1" min="1" max="10" style="width: 50px; margin-right: 10px;">                
                    <button type="submit">Add VM</button>
                    <button type="button" onclick="hideOverlay()" style="margin-left: 10px;">Cancel</button>
                </div>                
            </form>
        </div>
    </div>

    <div id="tag-overlay" class="tag-overlay">
        <div class="tag-overlay-content"></div>
    </div>

    <div id="add-tag-overlay" class="overlay">
        <div class="add-tag-overlay-content"></div>
    </div>

    <div id="miscOverlay" class="overlay">
        <div class="overlay-content">
            <button class="overlay-close-btn" onclick="closeMiscOverlay()">X</button>
            <div id="miscContent"></div>
        </div>
    </div>

    <div id="provisioningInfoOverlay" class="provisioning-info-overlay">
        <div class="provisioning-info-overlay-content"></div>
    </div>  

    <div id="system-id-overlay" class="system-id-overlay">
        <div class="system-id-overlay-content">
            <button class="overlay-close-btn" onclick="closeSystemIdOverlay()">X</button>
            <h2>System ID (Managed by CSP)</h2>
            <p id="fullSystemId"></p>
            <button class="copy-btn" onclick="copySystemId()">üìã</button>
        </div>
    </div>

    <!-- Image Selection Overlay -->
    <div id="image-selection-overlay" class="selection-overlay">
        <div class="selection-overlay-content">
            <button class="overlay-close-btn" onclick="closeImageSelectionOverlay()">X</button>
            <h2>Select VM Image
                <span id="image-mcinsight-badge" class="powered-by-badge" style="display: none;">Powered by <a href="http://mc-insight.cloud-barista.org" target="_blank">MC-Insight</a></span>
            </h2>
            
            <div class="filter-section">
                <h3>Filters</h3>
                <div class="filter-row">
                    <div class="filter-item">
                        <label>Region:</label>
                        <select id="image-filter-region">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label>Zone:</label>
                        <select id="image-filter-zone">
                            <option value="">All Zones</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <div style="display: flex; align-items: flex-start; gap: 3px;">
                            <label>Image Name:</label>
                            <button onclick="clearFilter('image-name')" class="clear-filter-btn" title="Clear Image Name filter">CLR</button>
                        </div>
                        <input type="text" id="image-filter-name" placeholder="Search by name">
                    </div>
                    <div class="filter-item">
                        <label>OS Architecture:</label>
                        <select id="image-filter-arch">
                            <option value="">All</option>
                            <option value="x86_64">x86_64</option>
                            <option value="arm64">arm64</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label>OS Platform:</label>
                        <select id="image-filter-platform">
                            <option value="">All</option>
                            <option value="linux/unix">Linux/UNIX</option>
                            <option value="windows">Windows</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <div style="display: flex; align-items: flex-start; gap: 3px;">
                            <label>OS Distribution:</label>
                            <button onclick="clearFilter('image-distribution')" class="clear-filter-btn" title="Clear OS Distribution filter">CLR</button>
                        </div>
                        <input type="text" id="image-filter-distribution" placeholder="e.g., ubuntu, centos">
                    </div>
                </div>
                <div class="filter-buttons">
                    <button class="select-btn" onclick="applyImageFilters()">Search</button>
                    <button class="select-btn" onclick="resetImageFilters()">Reset</button>
                </div>
            </div>

            <div class="pagination-controls" id="image-pagination" style="display: none;">
                <div class="pagination-info-left">
                    <span class="total-count" id="image-total-info">Total: 0</span>
                    <span class="data-version" id="image-data-version"></span>
                </div>
                <div class="pagination-nav-right">
                    <button onclick="loadImagePage('prev')" id="image-prev-btn">‚óÄ</button>
                    <span class="pagination-page-info" id="image-page-info">1 / 1</span>
                    <button onclick="loadImagePage('next')" id="image-next-btn">‚ñ∂</button>
                </div>
            </div>

            <div id="image-list-container">
                <div class="loading-message">Press Search to load images</div>
            </div>
        </div>
    </div>

    <!-- VM Spec Selection Overlay -->
    <div id="spec-selection-overlay" class="selection-overlay">
        <div class="selection-overlay-content">
            <button class="overlay-close-btn" onclick="closeSpecSelectionOverlay()">X</button>
            <h2>Select VM Spec
                <span id="spec-mcinsight-badge" class="powered-by-badge" style="display: none;">Powered by <a href="http://mc-insight.cloud-barista.org" target="_blank">MC-Insight</a></span>
            </h2>
            
            <div class="filter-section">
                <div style="display: flex; align-items: center; gap: 8px; padding-bottom: 10px; border-bottom: 1px solid #dee2e6; margin-bottom: 15px; flex-wrap: wrap;">
                    <h3 style="margin: 0; margin-right: 24px; padding: 0; border: none;">Filters</h3>
                    <button class="preset-btn" onclick="applyIntensivePreset('general')" title="Web servers, small applications, general workloads">General Purpose</button>
                    <button class="preset-btn" onclick="applyIntensivePreset('dev')" title="Development, testing, learning environments">Small/Dev</button>
                    <button class="preset-btn" onclick="applyIntensivePreset('high-performance')" title="Large-scale production, enterprise applications">High Perf</button>
                    <button class="preset-btn" onclick="applyIntensivePreset('database')" title="RDBMS, NoSQL databases">Database</button>
                    <button class="preset-btn" onclick="applyIntensivePreset('ai-ml')" title="Deep learning training, large-scale model training">AI/ML Training</button>
                </div>
                <div class="filter-row">
                    <div class="filter-item">
                        <label>Region:</label>
                        <select id="spec-filter-region">
                            <option value="">Loading...</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label>Zone:</label>
                        <select id="spec-filter-zone">
                            <option value="">All Zones</option>
                        </select>
                    </div>
                    <div class="filter-item">
                        <label>Architecture:</label>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span id="spec-os-arch-display" class="os-info-box" style="display: none; height: 28px; line-height: 28px; padding: 0 10px; width: 12ch; font-weight: normal; color: #555;"></span>
                            <input type="checkbox" id="spec-os-arch-filter-enabled" style="margin: 0; display: none;">
                        </div>
                    </div>
                    <div class="filter-item">
                        <div style="display: flex; align-items: flex-start; gap: 3px;">
                            <label>Spec Name:</label>
                            <button onclick="clearFilter('spec-name')" class="clear-filter-btn" title="Clear Spec Name filter">CLR</button>
                        </div>
                        <input type="text" id="spec-filter-name" placeholder="e.g., t2, c5">
                    </div>
                </div>
                <div class="filter-row" style="display: flex; gap: 15px;">
                    <div style="flex: 0.9; display: flex; gap: 15px; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
                        <div class="filter-item" style="flex: 1;">
                            <div style="display: flex; align-items: flex-start; gap: 3px;">
                                <label>vCPU:</label>
                                <button onclick="clearFilter('vcpu')" class="clear-filter-btn" title="Clear vCPU filter">CLR</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <input type="number" id="spec-filter-min-vcpu" min="1" placeholder="2" style="width: 100%;">
                                <span>~</span>
                                <input type="number" id="spec-filter-max-vcpu" min="1" placeholder="16" style="width: 100%;">
                            </div>
                        </div>
                        <div class="filter-item" style="flex: 1;">
                            <div style="display: flex; align-items: flex-start; gap: 3px;">
                                <label>Memory (MiB):</label>
                                <button onclick="clearFilter('mem')" class="clear-filter-btn" title="Clear Memory filter">CLR</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <input type="number" id="spec-filter-min-mem" min="1" placeholder="4096" style="width: 100%;">
                                <span>~</span>
                                <input type="number" id="spec-filter-max-mem" min="1" placeholder="65536" style="width: 100%;">
                            </div>
                        </div>
                    </div>
                    <div style="flex: 1.1; display: flex; gap: 15px; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
                        <div class="filter-item" style="flex: 1;">
                            <div style="display: flex; align-items: flex-start; gap: 3px;">
                                <label>GPU:</label>
                                <button onclick="clearFilter('gpu')" class="clear-filter-btn" title="Clear GPU filter">CLR</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <input type="number" id="spec-filter-min-gpu" min="1" placeholder="1" style="width: 100%;">
                                <span>~</span>
                                <input type="number" id="spec-filter-max-gpu" min="1" placeholder="8" style="width: 100%;">
                            </div>
                        </div>
                        <div class="filter-item" style="flex: 1;">
                            <div style="display: flex; align-items: flex-start; gap: 3px;">
                                <label>GPU Memory (GB):</label>
                                <button onclick="clearFilter('gpu-mem')" class="clear-filter-btn" title="Clear GPU Memory filter">CLR</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <input type="number" id="spec-filter-min-gpu-mem" min="0" placeholder="8" style="width: 100%;">
                                <span>~</span>
                                <input type="number" id="spec-filter-max-gpu-mem" min="0" placeholder="128" style="width: 100%;">
                            </div>
                        </div>
                        <div class="filter-item" style="flex: 1;">
                            <div style="display: flex; align-items: flex-start; gap: 3px;">
                                <label>GPU Model:</label>
                                <button onclick="clearFilter('gpu-model')" class="clear-filter-btn" title="Clear GPU Model filter">CLR</button>
                            </div>
                            <input type="text" id="spec-filter-gpu-model" placeholder="e.g., a100, t4" style="width: 89%;">
                        </div>
                    </div>
                </div>
                <div class="filter-buttons">
                    <button class="select-btn" onclick="applySpecFilters()">Search</button>
                    <button class="select-btn" onclick="resetSpecFilters()">Reset</button>
                </div>
            </div>

            <div class="pagination-controls" id="spec-pagination" style="display: none;">
                <div class="pagination-info-left">
                    <span class="total-count" id="spec-total-info">Total: 0</span>
                    <span class="data-version" id="spec-data-version"></span>
                </div>
                <div class="pagination-nav-right">
                    <button onclick="loadSpecPage('prev')" id="spec-prev-btn">‚óÄ</button>
                    <span class="pagination-page-info" id="spec-page-info">1 / 1</span>
                    <button onclick="loadSpecPage('next')" id="spec-next-btn">‚ñ∂</button>
                </div>
            </div>

            <div id="spec-list-container">
                <div class="loading-message">Press Search to load VM specs</div>
            </div>
        </div>
    </div>

    <!-- Price Info Overlay -->
    <div id="price-info-overlay" class="selection-overlay">
        <div class="selection-overlay-content" style="max-width: 600px;">
            <button class="overlay-close-btn" onclick="closePriceInfoOverlay()">X</button>
            <h2>VM Price Information</h2>
            
            <div style="padding: 20px; max-height: 600px; overflow-y: auto;">
                <div style="margin: 0 0 25px 0; padding: 12px 15px; background-color: #e3f2fd; border-left: 4px solid #2196f3; border-radius: 4px;">
                    <strong style="color: #1565c0;">Data Source:</strong> 
                    <span style="color: #333;">Price information is sourced from <a href="http://mc-insight.cloud-barista.org/" target="_blank" style="color: #1976d2; text-decoration: underline; font-weight: 500;">MC-Insight</a> API and regularly updated to reflect the latest CSP pricing.</span>
                </div>

                <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                    <tr style="border-bottom: 2px solid #ddd;">
                        <th style="text-align: left; padding: 10px; background-color: #f5f5f5; width: 30%;">Category</th>
                        <th style="text-align: left; padding: 10px; background-color: #f5f5f5;">Details</th>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold; vertical-align: top;">Provided VM Price</td>
                        <td style="padding: 10px;">VM Spec-based OnDemand pricing (USD/Hour)<br><span style="font-size: 12px; color: #666;">‚Äª OS/Software license costs not included</span></td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; font-weight: bold; vertical-align: top;">Supported CSPs</td>
                        <td style="padding: 10px;">AWS, Azure, GCP, Alibaba, Tencent, IBM, NCP</td>
                    </tr>
                </table>

                <div style="margin: 20px 0; padding: 12px 15px; background-color: #fff8e1; border-left: 4px solid #ffa726; border-radius: 4px;">
                    <strong style="color: #e65100;">‚ö† Important:</strong> 
                    <span style="color: #333;">Root Disk and Network costs may or may not be included in the price, depending on the CSP.</span>
                </div>

                <h3 style="margin-top: 30px; margin-left: 0;">Reference: CSP Official Pricing Pages</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                    <tr style="border-bottom: 2px solid #ddd;">
                        <th style="text-align: left; padding: 10px; background-color: #f5f5f5; width: 20%;">CSP</th>
                        <th style="text-align: left; padding: 10px; background-color: #f5f5f5;">Official Pricing Page</th>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold;">AWS</td>
                        <td style="padding: 10px;"><a href="https://aws.amazon.com/ec2/pricing/on-demand/" target="_blank" style="color: #007bff; text-decoration: underline;">EC2 On-Demand Pricing</a></td>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold;">Azure</td>
                        <td style="padding: 10px;"><a href="https://azure.microsoft.com/en-us/pricing/details/virtual-machines/linux/" target="_blank" style="color: #007bff; text-decoration: underline;">Virtual Machines Pricing</a></td>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold;">GCP</td>
                        <td style="padding: 10px;"><a href="https://cloud.google.com/compute/all-pricing" target="_blank" style="color: #007bff; text-decoration: underline;">Compute Engine Pricing</a></td>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold;">Alibaba</td>
                        <td style="padding: 10px;"><a href="https://www.alibabacloud.com/en/product/ecs" target="_blank" style="color: #007bff; text-decoration: underline;">Elastic Compute Service</a></td>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold;">Tencent</td>
                        <td style="padding: 10px;"><a href="https://intl.cloud.tencent.com/pricing/cvm" target="_blank" style="color: #007bff; text-decoration: underline;">Cloud Virtual Machine Pricing</a></td>
                    </tr>
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 10px; font-weight: bold;">IBM</td>
                        <td style="padding: 10px;"><a href="https://www.ibm.com/cloud/virtual-servers/pricing" target="_blank" style="color: #007bff; text-decoration: underline;">Virtual Servers Pricing</a></td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; font-weight: bold;">NCP</td>
                        <td style="padding: 10px;"><a href="https://www.ncloud.com/v2/product/compute/server#pricing" target="_blank" style="color: #007bff; text-decoration: underline;">Server Pricing</a></td>
                    </tr>
                </table>
            </div>
        </div>
    </div>

    <!-- VM Recent Overlay -->
    <div id="vm-recent-overlay" class="selection-overlay">
        <div id="recent-overlay-content" class="selection-overlay-content" style="max-width: 1300px;">
            <button class="overlay-close-btn" onclick="closeVMRecentOverlay()">X</button>
            <h2 style="display: flex; justify-content: space-between; align-items: center; margin-top: 35px;">
                <span>Recent VM Creations
                    <span id="recent-mcinsight-badge" class="powered-by-badge" style="display: none;">Powered by <a href="http://mc-insight.cloud-barista.org" target="_blank">MC-Insight</a></span>
                </span>
                <span style="display: flex; align-items: center; gap: 8px; padding: 6px 10px; background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 6px;">
                    <button class="overlay-import-btn" onclick="importRecentData()" title="Import recent VM data from JSON file">Import</button>
                    <button class="overlay-export-btn" onclick="exportRecentData()" title="Export recent VM data to JSON file">Export</button>
                    <label style="font-size: 13px; font-weight: normal; cursor: pointer; margin: 0;">
                        <input type="checkbox" id="export-all-checkbox" onchange="onAllCheckboxChange()" style="margin-right: 4px; cursor: pointer;">
                        All
                    </label>
                </span>
            </h2>
            
            <div id="recent-list-container" style="margin-top: 20px;">
                <div class="loading-message" style="display: none;">Loading recent VM data...</div>
                <table class="selection-table" id="recent-table" style="display: none;">
                    <thead>
                        <tr id="recent-table-header">
                            <th style="width: 30px;">#</th>
                            <th id="recent-csp-header" onclick="sortRecentTable('csp')" style="cursor: pointer; user-select: none; width: 60px; display: none;" title="Click to sort">CSP</th>
                            <th id="recent-region-header" onclick="sortRecentTable('region')" style="cursor: pointer; user-select: none; width: 80px; display: none;" title="Click to sort">Region</th>
                            <th id="recent-zone-header" onclick="sortRecentTable('zone')" style="cursor: pointer; user-select: none; width: 80px; display: none;" title="Click to sort">Zone</th>
                            <th onclick="sortRecentTable('image_name')" style="cursor: pointer; user-select: none; width: 140px; text-align: center;" title="Click to sort">Image Name</th>
                            <th onclick="sortRecentTable('spec_name')" style="cursor: pointer; user-select: none; width: 130px; text-align: center;" title="Click to sort">Spec Name</th>
                            <th onclick="sortRecentTable('os_arch')" style="cursor: pointer; user-select: none; width: 65px;" title="Click to sort">OS Arch</th>
                            <th onclick="sortRecentTable('cpu')" style="cursor: pointer; user-select: none; width: 70px;" title="Click to sort">CPU</th>
                            <th onclick="sortRecentTable('gpu')" style="cursor: pointer; user-select: none; width: 65px;" title="Click to sort">GPU</th>
                            <th onclick="sortRecentTable('price')" style="cursor: pointer; user-select: none; width: 70px;" title="Click to sort">Price/Hr</th>
                            <th onclick="sortRecentTable('avg_time')" style="cursor: pointer; user-select: none; width: 65px;" title="Click to sort">Avg Time</th>
                            <th onclick="sortRecentTable('count')" style="cursor: pointer; user-select: none; width: 45px;" title="Click to sort">Count</th>
                            <th onclick="sortRecentTable('last_created')" style="cursor: pointer; user-select: none; width: 120px;" title="Click to sort">Last Created</th>
                            <th style="width: 80px;">
                                <button id="recent-bulk-star-btn" class="select-btn" style="font-size: 14px; padding: 1px 4px; color: #ffc107; margin-left: 4px;" onclick="bulkToggleRecentFavorite(event)" title="Toggle all as favorite">‚òÖ</button>
                                <button class="select-btn" style="font-size: 14px; padding: 1px 4px; color: #dc3545; margin-left: 2px;" onclick="bulkDeleteRecent(event)" title="Delete all">‚úï</button>
                            </th>
                        </tr>
                    </thead>
                    <tbody id="recent-table-body">
                    </tbody>
                </table>
                <div class="no-data-message" id="recent-no-data" style="display: none;">No recent VM creation records found.</div>
            </div>
        </div>
    </div>

    <!-- VM Favorite Overlay -->
    <div id="vm-favorite-overlay" class="selection-overlay">
        <div id="favorite-overlay-content" class="selection-overlay-content" style="max-width: 1000px;">
            <button class="overlay-close-btn" onclick="closeVMFavoriteOverlay()">X</button>
            <h2 style="display: flex; justify-content: space-between; align-items: center; margin-top: 35px;">
                <span>Favorite VM Configurations</span>
                <span style="display: flex; align-items: center; gap: 8px; padding: 6px 10px; background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 6px;">
                    <button class="overlay-import-btn" onclick="importFavoriteData()" title="Import favorite VM data from JSON file">Import</button>
                    <button class="overlay-export-btn" onclick="exportFavoriteData()" title="Export favorite VM data to JSON file">Export</button>
                    <label style="font-size: 13px; font-weight: normal; cursor: pointer; margin: 0;">
                        <input type="checkbox" id="favorite-all-checkbox" onchange="onFavoriteAllCheckboxChange()" style="margin-right: 4px; cursor: pointer;">
                        All
                    </label>
                </span>
            </h2>
            
            <div id="favorite-list-container" style="margin-top: 20px;">
                <div class="loading-message" style="display: none;">Loading favorite VM configurations...</div>
                <table class="selection-table" id="favorite-table" style="display: none;">
                    <thead>
                        <tr id="favorite-table-header">
                            <th style="width: 30px;">#</th>
                            <th id="favorite-csp-header" onclick="sortFavoriteTable('csp')" style="cursor: pointer; user-select: none; width: 60px; display: none;" title="Click to sort">CSP</th>
                            <th id="favorite-region-header" onclick="sortFavoriteTable('region')" style="cursor: pointer; user-select: none; width: 80px; display: none;" title="Click to sort">Region</th>
                            <th id="favorite-zone-header" onclick="sortFavoriteTable('zone')" style="cursor: pointer; user-select: none; width: 80px; display: none;" title="Click to sort">Zone</th>
                            <th onclick="sortFavoriteTable('image_name')" style="cursor: pointer; user-select: none; width: 140px; text-align: center;" title="Click to sort">Image Name</th>
                            <th onclick="sortFavoriteTable('spec_name')" style="cursor: pointer; user-select: none; width: 130px; text-align: center;" title="Click to sort">Spec Name</th>
                            <th onclick="sortFavoriteTable('os_arch')" style="cursor: pointer; user-select: none; width: 65px;" title="Click to sort">OS Arch</th>
                            <th onclick="sortFavoriteTable('cpu')" style="cursor: pointer; user-select: none; width: 85px;" title="Click to sort">CPU</th>
                            <th onclick="sortFavoriteTable('gpu')" style="cursor: pointer; user-select: none; width: 75px;" title="Click to sort">GPU</th>
                            <th onclick="sortFavoriteTable('price')" style="cursor: pointer; user-select: none; width: 70px;" title="Click to sort">Price/Hr</th>
                            <th onclick="sortFavoriteTable('created_at')" style="cursor: pointer; user-select: none; width: 120px;" title="Click to sort">Added Date</th>
                            <th style="width: 70px;">
                                <button class="select-btn" style="font-size: 14px; padding: 1px 4px; color: #dc3545; margin-left: 4px;" onclick="bulkDeleteFavorite(event)" title="Delete all">‚úï</button>
                            </th>
                        </tr>
                    </thead>
                    <tbody id="favorite-table-body">
                    </tbody>
                </table>
                <div class="no-data-message" id="favorite-no-data" style="display: none;">No favorite VM configurations found.</div>
            </div>
        </div>
    </div>

    <!-- Global Loading Spinner -->
    <div id="global-loading-overlay" class="global-loading-overlay">
        <div class="loading-spinner"></div>
    </div>

</body>
<script>
    // Basic Auth credentials from server
    const API_USERNAME = '{{.APIUsername}}';
    const API_PASSWORD = '{{.APIPassword}}';
    
    // Helper function to create fetch options with Basic Auth if credentials are set
    function createFetchOptions(options = {}) {
        const fetchOptions = { ...options };
        
        // Add Basic Auth header if credentials are provided
        if (API_USERNAME && API_PASSWORD) {
            const credentials = btoa(API_USERNAME + ':' + API_PASSWORD);
            fetchOptions.headers = {
                ...fetchOptions.headers,
                'Authorization': 'Basic ' + credentials
            };
        }
        
        return fetchOptions;
    }
    
    // Override fetch to automatically include Basic Auth
    const originalFetch = window.fetch;
    window.fetch = function(url, options) {
        // Only add auth headers for Spider API calls (not for external URLs)
        if (url.startsWith('/spider/') || url.startsWith('http://' + location.host + '/spider/')) {
            options = createFetchOptions(options);
        }
        return originalFetch(url, options);
    };

    function vmControl(connConfig, vmName, action) {
        const controlCell = document.getElementById(`vmcontrol-${vmName}`);
        const rowElement = controlCell.parentElement;
        const targetState = action === 'suspend' ? 'Suspended' : 'Running';
        let attempts = 0;
        const maxAttempts = 30;

        // Utility function to update UI based on the action
        function updateUI(message) {
            controlCell.innerHTML = `<span class="progress-message">${message}...</span>`;
        }

        // Utility function to handle server response and start checking status
        function handleResponse(response) {
            const status = response.Status;

            // Update UI based on VM status
            switch (status) {
                case "Suspending":
                    updateUI("VM is suspending");
                    break;
                case "Suspended":
                    updateControlCell("Suspended");
                    break;
                case "Resuming":
                    updateUI("VM is resuming");
                    break;
                case "Running":
                    updateControlCell("Running");
                    break;
                case "Rebooting":
                    updateUI("VM is rebooting");
                    break;
                case "Terminating":
                    controlCell.innerHTML = `<span style="color:gray;">VM is terminating...</span>`;
                    break;
                case "Terminated":
                    controlCell.innerHTML = `<span style="color:red;">VM has been terminated</span>`;
                    break;
                case "Failed":
                    controlCell.innerHTML = `<span style="color:red;">VM action failed</span>`;
                    break;
                case "NotExist":
                    controlCell.innerHTML = `<span style="color:red;">VM does not exist</span>`;
                    break;
                default:
                    controlCell.innerHTML = `<span style="color:orange;">Unexpected status: ${status}</span>`;
                    break;
            }

            // Start checking the status after initiating the action
            checkVMStatus();
        }

        // Function to update the entire row with the latest VM information
        function updateVMRow(status) {
            fetch(`/spider/vm/${vmName}?ConnectionName=${connConfig}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(vmData => {
                const sshAccessCell = rowElement.querySelector('.ssh-access-cell');
                const provisioningInfoCell = rowElement.querySelector('.provisioning-info-cell');
                const miscCell = rowElement.querySelector('.misc-cell .misc-content');

                // Update SSH Access
                sshAccessCell.innerHTML = `
                    ‚Ä¢ Public IP: ${vmData.PublicIP}
                    <button class="copy-icon-btn" onclick="copyToClipboard('${vmData.PublicIP}')">üìã</button>
                    <br> ‚Ä¢ 
                    <div class="ssh-connect-btn" 
                        onclick="if ('${vmData.PublicIP}') { openSSHAccess({ vmUserId: '${vmData.VMUserId}', publicIP: '${vmData.PublicIP}', keyName: '${vmData.KeyPairIId.NameId}' }); }">
                        <span class="ssh-terminal-style">SSH: ${vmData.PublicIP}</span>
                    </div>
                `;

                // Update Provisioning Info
                provisioningInfoCell.innerHTML = `
                    <a class="provisioning-info-link" onclick="showProvisioningInfoOverlay({
                        vpcName: '${vmData.VpcIID.NameId}',
                        subnetName: '${vmData.SubnetIID.NameId}',
                        zone: '${vmData.Region.Zone}',
                        securityGroupName: ['${vmData.SecurityGroupIIds.map(sg => sg.NameId).join("', '")}'],
                        keypairName: '${vmData.KeyPairIId.NameId}',
                        vmUserId: '${vmData.VMUserId}',
                        imageType: '${vmData.ImageType}',
                        imageName: '${vmData.ImageIId.NameId}',
                        platform: '${vmData.Platform}',
                        vmSpecName: '${vmData.VMSpecName}',
                        rootDiskType: '${vmData.RootDiskType}',
                        rootDiskSize: '${vmData.RootDiskSize}',
                        rootDeviceName: '${vmData.RootDeviceName}',
                        dataDisks: ['${vmData.DataDiskIIDs.map(disk => disk.NameId).join("', '")}'],
                        networkInterface: '${vmData.NetworkInterface}',
                        publicIP: '${vmData.PublicIP}',
                        publicDNS: '${vmData.PublicDNS}',
                        privateIP: '${vmData.PrivateIP}',
                        privateDNS: '${vmData.PrivateDNS}'
                    })">View Details</a>
                `;

                // Update Misc Information
                miscCell.innerHTML = vmData.KeyValueList.map(kv => `${kv.Key} : ${kv.Value}`).join('<br>');

                // Update Status | Actions Field with the latest status
                updateControlCell(status);
            })
            .catch(() => {
                controlCell.innerHTML = `<span style="color:red;">Failed to update row</span>`;
            });
        }

        // Function to update the Status | Actions cell based on the status
        function updateControlCell(status) {
            if (status === 'Running') {
                controlCell.innerHTML = `
                    <div style="display: inline-flex; align-items: center;">
                        <span style="margin-right: 8px;">Running &nbsp; |</span>
                        <button class="vm-action-btn" onclick="vmControl('${connConfig}', '${vmName}', 'suspend')">‚è∏Ô∏è</button>
                        <button class="vm-action-btn" onclick="vmControl('${connConfig}', '${vmName}', 'reboot')">&nbsp;üîÑ</button>
                    </div>
                `;
            } else if (status === 'Suspended') {
                controlCell.innerHTML = `
                    <div style="display: inline-flex; align-items: center;">
                        <span style="margin-right: 8px;">Suspended &nbsp; |</span>
                        <button class="vm-action-btn" onclick="vmControl('${connConfig}', '${vmName}', 'resume')">‚èØÔ∏è</button>
                    </div>
                `;
            } else {
                controlCell.innerHTML = `
                    <div style="display: inline-flex; align-items: center;">
                        <span style="margin-right: 8px;">${status} |</span>
                    </div>
                `;
            }
        }

        // Function to periodically check the VM status
        function checkVMStatus() {
            attempts++;

            fetch(`/spider/vmstatus/${vmName}?ConnectionName=${connConfig}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                const status = data.Status;
                if (status === targetState) {
                    // Update the entire row with the latest data
                    updateVMRow(status);
                } else if (attempts < maxAttempts) {
                    setTimeout(checkVMStatus, 1000); // Retry after 1 second
                } else {
                    controlCell.innerHTML = `<span style="color:orange;">Still processing, please try refreshing manually.</span>`;
                }
            })
            .catch(() => {
                controlCell.innerHTML = `<span style="color:red;">Failed to update status</span>`;
            });
        }

        // Set message based on the action
        const actionMessages = {
            suspend: "Suspending",
            resume: "Resuming",
            reboot: "Rebooting"
        };
        updateUI(actionMessages[action] || "Processing");

        // Send request to the server
        fetchWithProgress(`/spider/controlvm/${vmName}?action=${action}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ ConnectionName: connConfig })
        })
        .then(response => response.json())
        .then(handleResponse)
        .catch(() => {
            controlCell.innerHTML = `<span style="color:red;">Failed to execute action</span>`;
        });
    }



    function postSnapshotVM(connConfig, vmName, snapshotName) {
        const snapshotData = {
            ConnectionName: connConfig,
            ReqInfo: {
                Name: snapshotName,
                SourceVM: vmName
            }
        };

        fetchWithProgress(`/spider/myimage`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(snapshotData)
        })
        .then(response => response.json().then(data => ({ data, ok: response.ok })))
        .then(({ data, ok }) => {
            if (!ok || data.message) {
                const errorMessage = data.message || "Unknown error";
                showError(`VM Name: ${vmName}: Failed to create snapshot: ${errorMessage}`);
            } else if (data.IId && data.IId.NameId) {
                alert(`Snapshot "${data.IId.NameId}" created successfully. You can check the result in MyImage.`);
            }
        })
        .catch(error => {
            showError(`VM Name: ${vmName}: Error creating snapshot: ${error.message}`);
        });

    }

    function deleteSelectedVMs() {
        const connConfig = document.getElementById('connConfig').value;
        const checkboxes = document.querySelectorAll('input[name="deleteCheckbox"]:checked');
        if (checkboxes.length === 0) {
            alert("Please select VMs to delete.");
            return;
        }

        if (!confirm("Are you sure you want to delete the selected VMs?")) {
            return;
        }

        const deletePromises = Array.from(checkboxes).map(checkbox => {
            const vmName = checkbox.value;
            const data = {
                ConnectionName: connConfig
            };

            return fetchWithProgress(`/spider/vm/${vmName}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            }).then(response => {
                if (!response.ok) {
                    return response.json().then(error => {
                        throw new Error(error.message);
                    });
                }
                return response.json();
            });
        });

        Promise.all(deletePromises)
            .then(() => location.reload())
            .catch(error => {
                alert("Error deleting VMs: " + error.message);
            });
    }

    function toggleSelectAll(source) {
        const checkboxes = document.querySelectorAll('input[name="deleteCheckbox"]');
        for (const checkbox of checkboxes) {
            checkbox.checked = source.checked;
        }
    }

    function deleteVM(vmName) {
        const connConfig = document.getElementById('connConfig').value;
        const data = {
            ConnectionName: connConfig
        };

        fetchWithProgress(`/spider/vm/${vmName}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        })
        .then(response => response.json())
        .then(data => {
            if (data.Result === "true") {
                location.reload();
            } else {
                showError("Failed to delete VM: " + (data.Message || "Unknown error"), "VM Name: " + vmName);
            }
        })
        .catch(error => {
            showError("Error deleting VM: " + error.message, "VM Name: " + vmName);
        });
    }

    function postVM() {
        const vmCount = parseInt(document.getElementById('vmCount').value);
        if (vmCount > 1) {
            if (!confirm(`Are you sure you want to create ${vmCount} VMs?`)) {
                return;
            }
        }

        // Validate that at least one security group is selected
        const selectedSecurityGroups = document.querySelectorAll('.sg-checkbox:checked');
        if (selectedSecurityGroups.length === 0) {
            alert('Please select at least one Security Group.');
            return;
        }

        const connConfig = document.getElementById('connConfig').value;

        const vmPromises = Array.from({ length: vmCount }).map((_, index) => {
            const vmName = vmCount > 1 ? `${document.getElementById('vmName').value}-${index + 1}` : document.getElementById('vmName').value;

            const requestData = {
                ConnectionName: connConfig,
                ReqInfo: {
                    Name: vmName,
                    ImageType: document.getElementById('imageType').value,
                    ImageName: document.getElementById('imageName').value,
                    VMSpecName: document.getElementById('vmSpecName').value,
                    VPCName: document.getElementById('vpcSelect').options[document.getElementById('vpcSelect').selectedIndex].text.split(' ')[0],
                    SubnetName: document.getElementById('subnetSelect').value,
                    SecurityGroupNames: Array.from(document.querySelectorAll('.sg-checkbox:checked')).map(checkbox => checkbox.value),
                    RootDiskType: document.getElementById('rootDiskType').value,
                    RootDiskSize: document.getElementById('rootDiskSize').value || undefined,  
                    DataDiskNames: Array.from(document.querySelectorAll('.dd-checkbox:checked')).map(checkbox => checkbox.value),    
                    KeyPairName: document.getElementById('keypairSelect').value,
                    VMUserId: document.getElementById('vmUserId').value,
                    VMUserPasswd: document.getElementById('vmUserPasswd').value,
                    TagList: Array.from(document.querySelectorAll('.vm-tag-input')).map(tagInput => ({
                        Key: tagInput.querySelector('.vm-tag-key').value.trim(),
                        Value: tagInput.querySelector('.vm-tag-value').value.trim()
                    }))
                }
            };

            return fetchWithProgress('/spider/vm', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            })
            .then(response => response.json().then(data => ({ data, ok: response.ok })))
            .then(({ data, ok }) => {
                if (!ok || data.message) {
                    const errorMessage = data.message || "Unknown error";
                    showError(`VM Name: ${vmName}: Failed to create VM: ${errorMessage}`);
                    return { success: false, vmName };
                } else if (data.IId && data.IId.NameId) {
                    console.log(`VM "${data.IId.NameId}" created successfully.`);
                    return { success: true, vmName };
                }
            })
            .catch(error => {
                showError(`VM Name: ${vmName}: Error creating VM: ${error.message}`);
                return { success: false, vmName };
            });
        });

        Promise.all(vmPromises)
            .then((results) => {
                const successCount = results.filter(r => r && r.success).length;
                if (successCount > 0) {
                    location.reload();
                }
                // If all failed, keep the overlay open for retry
            })
            .catch(error => {
                showError("Error creating VMs: " + error.message, "Multiple VMs");
            });
    }


    function searchKeyword() {
        let input, filter, table, tr, td, i;
        input = document.getElementById('searchInput');
        filter = input.value.toUpperCase().trim(); 
        if (!filter) {
            clearSearchInput();
            return;
        }

        table = document.getElementById('vm-table');
        tr = table.getElementsByTagName('tr');
        
        for (i = 1; i < tr.length; i++) {
            for (let j = 0; j < tr[i].cells.length; j++) {
                td = tr[i].cells[j];
                if (td) {
                    let txtValue = td.textContent || td.innerText;
                    if (txtValue.toUpperCase().indexOf(filter) > -1) {
                        td.classList.add('highlight');
                    } else {
                        td.classList.remove('highlight');
                    }
                }
            }
        }
    }

    function clearSearchInput() {
        document.getElementById("searchInput").value = "";
        let table = document.getElementById('vm-table');
        let tr = table.getElementsByTagName('tr');
        for (let i = 1; i < tr.length; i++) {
            for (let j = 0; j < tr[i].cells.length; j++) {
                tr[i].cells[j].classList.remove('highlight');
            }
        }
    }

    function showOverlay() {
        document.getElementById('overlay').style.display = 'flex';
        document.addEventListener('keydown', handleOverlayEsc);
        clearFormFields();
    }

    function clearFormFields() {
        // Save current zone value before reset
        const subnetZoneInput = document.getElementById('subnetZone');
        const currentZone = subnetZoneInput ? subnetZoneInput.value : '';
        
        // Clear form fields
        document.getElementById('addVMForm').reset();

        // Restore zone value after reset
        if (subnetZoneInput && currentZone) {
            subnetZoneInput.value = currentZone;
        }

        const region = '{{.RegionName}}';
        const vmNameInput = document.getElementById('vmName');
        vmNameInput.value = `${region}-vm-${Math.random().toString(36).substring(2, 5)}`;
        loadSecurityGroups();
        const tagContainer = document.getElementById('vm-tag-container');
        while (tagContainer.firstChild) {
            tagContainer.removeChild(tagContainer.firstChild);
        }
        
    }

    function hideOverlay() {
        document.getElementById('overlay').style.display = 'none';
        document.removeEventListener('keydown', handleOverlayEsc);
        clearFormFields();
    }

    function handleOverlayEsc(event) {
        if (event.key === "Escape") {
            // Don't close Add New VM overlay if Image/Spec/Price selection overlay is open
            const imageOverlay = document.getElementById('image-selection-overlay');
            const specOverlay = document.getElementById('spec-selection-overlay');
            const priceOverlay = document.getElementById('price-info-overlay');
            const recentOverlay = document.getElementById('vm-recent-overlay');
            const favoriteOverlay = document.getElementById('vm-favorite-overlay');
            
            if ((imageOverlay && imageOverlay.style.display === 'flex') ||
                (specOverlay && specOverlay.style.display === 'flex') ||
                (priceOverlay && priceOverlay.style.display === 'flex') ||
                (recentOverlay && recentOverlay.style.display === 'flex') ||
                (favoriteOverlay && favoriteOverlay.style.display === 'flex')) {
                return; // Let the selection overlay handle the ESC key
            }
            
            hideOverlay();
        }
    }

    function addVMTagField() {
        const tagContainer = document.getElementById('vm-tag-container');
        
        const tagInput = document.createElement('div');
        tagInput.className = 'vm-tag-input tag-input-group';
        tagInput.innerHTML = `
            <input type="text" class="vm-tag-key" placeholder="Key" required>
            <input type="text" class="vm-tag-value" placeholder="Value" required>
            <button type="button" onclick="removeTagField(this)">-</button>
        `;
        tagContainer.appendChild(tagInput);
    }

    function removeTagField(button) {
        button.parentElement.remove();
    }

    function showTagOverlay(event, tag, resourceType, resourceName) {
        event.stopPropagation();

        const tagOverlay = document.getElementById('tag-overlay');
        const tagOverlayContent = document.querySelector('.tag-overlay-content');

        tagOverlayContent.innerHTML = `
            <button class="overlay-close-btn" onclick="closeTagOverlay()">X</button>
            <p>${tag}</p>
            <div class="button-group">
                <button onclick="deleteTag('${tag}', '${resourceType}', '${resourceName}')">Delete</button>
                <button onclick="closeTagOverlay()">Cancel</button>
            </div>
        `;

        tagOverlay.style.display = 'flex';

        document.addEventListener('keydown', handleTagOverlayEsc);
        document.addEventListener('click', handleClickOutsideOverlay);
    }

    function closeTagOverlay() {
        const tagOverlay = document.getElementById('tag-overlay');
        tagOverlay.style.display = 'none';
        document.removeEventListener('keydown', handleTagOverlayEsc);
        document.removeEventListener('click', handleClickOutsideOverlay);
    }

    function handleTagOverlayEsc(event) {
        if (event.key === "Escape") {
            closeTagOverlay();
        }
    }

    function handleClickOutsideOverlay(event) {
        const tagOverlay = document.getElementById('tag-overlay');
        if (tagOverlay.style.display === 'flex' && !tagOverlay.contains(event.target)) {
            closeTagOverlay();
        }
    }

    function showError(message, title) {
        alert(`${title}: ${message}`);
    }

    function deleteTag(tag, resourceType, resourceName) {
        const connConfig = document.getElementById('connConfig').value;
        const [tagKey, tagValue] = tag.split(': ');

        const data = {
            ConnectionName: connConfig,
            ReqInfo: {
                ResourceType: resourceType.trim(),
                ResourceName: resourceName.trim()
            }
        };

        fetchWithProgress(`/spider/tag/${tagKey.trim()}`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        }).then(response => {
            if (!response.ok) {
                return response.json().then(error => {
                    throw new Error(error.message);
                });
            }
            return response.json();
        }).then(() => {
            closeTagOverlay();
            location.reload();
        }).catch(error => {
            showError("Error deleting tag: " + error.message, "Resource Name: " + resourceName);
        });
    }

    document.addEventListener('click', (event) => {
        const tagOverlay = document.getElementById('tag-overlay');
        if (tagOverlay && tagOverlay.style.display === 'flex' && !tagOverlay.contains(event.target)) {
            closeTagOverlay();
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        fetch('/spider/connectionconfig/{{.ConnectionConfig}}')
            .then(response => response.json())
            .then(data => {
                const currentProvider = data.ProviderName;
                if (currentProvider === 'MOCK') {
                    const mockButtonsContainer = document.getElementById('mockButtonsContainer');

                    const button10 = document.createElement('button');
                    button10.className = 'mock-add-button add-button';
                    button10.textContent = '+10';
                    button10.onclick = () => createMultipleVMs(10);

                    const button50 = document.createElement('button');
                    button50.className = 'mock-add-button add-button';
                    button50.textContent = '+50';
                    button50.onclick = () => createMultipleVMs(50);

                    mockButtonsContainer.appendChild(button10);
                    mockButtonsContainer.appendChild(button50);
                }
            })
            .catch(error => {
                showError("Error loading connection configuration: " + error.message, "Connection Config Error");
            });
    });

    function createMultipleVMs(count) {
        const connConfigElement = document.getElementById('connConfig').value;

        const fetchVPCAndSubnet = () => {
            return fetch(`/spider/vpc?ConnectionName=${encodeURIComponent(connConfigElement)}`)
                .then(response => response.json())
                .then(data => {
                    if (data.vpc && data.vpc.length > 0) {
                        const firstVPC = data.vpc[0];
                        const vpcName = firstVPC.IId.NameId;
                        const subnetName = firstVPC.SubnetInfoList[0].IId.NameId;
                        return { vpcName, subnetName };
                    } else {
                        throw new Error('No VPCs available.');
                    }
                })
                .catch(error => {
                    console.error('Error fetching VPCs and Subnets:', error);
                    return { vpcName: '', subnetName: '' };
                });
        };

        const fetchFirstResource = (resourceType, urlPath) => {
            return fetch(`/spider/${urlPath}?ConnectionName=${encodeURIComponent(connConfigElement)}`)
                .then(response => response.json())
                .then(data => {
                    if (data[resourceType] && data[resourceType].length > 0) {
                        return data[resourceType][0].IId.NameId;
                    } else {
                        throw new Error(`No ${resourceType} available.`);
                    }
                })
                .catch(error => {
                    console.error(`Error fetching ${resourceType}:`, error);
                    return '';
                });
        };

        Promise.all([
            fetchVPCAndSubnet(),
            fetchFirstResource('securitygroup', 'securitygroup'),
            fetchFirstResource('keypair', 'keypair')
        ])
        .then(([{ vpcName, subnetName }, securityGroupName, keypairName]) => {
            if (!vpcName || !subnetName || !securityGroupName || !keypairName) {
                showError("Missing required resources for VM creation.", "Resource Error");
                throw new Error("Missing required resources for VM creation.");
            }

            const vmPromises = Array.from({ length: count }).map(() => {
                const vmName = `vm-${Math.random().toString(36).substring(2, 7)}`;
                const imageType = 'PublicImage';
                const imageName = 'mock-vmimage-01';
                const vmSpecName = 'mock-vmspec-01';
                const rootDiskType = 'default';
                const rootDiskSize = '50';

                const requestData = {
                    ConnectionName: connConfigElement,
                    ReqInfo: {
                        Name: vmName,
                        ImageType: imageType,
                        ImageName: imageName,
                        VMSpecName: vmSpecName,
                        VPCName: vpcName,
                        SubnetName: subnetName,
                        SecurityGroupNames: [securityGroupName],
                        RootDiskType: rootDiskType,
                        RootDiskSize: rootDiskSize,
                        DataDiskNames: [],
                        KeyPairName: keypairName,
                        TagList: []
                    }
                };

                return fetchWithProgress('/spider/vm', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                }).then(response => {
                    if (!response.ok) {
                        return response.json().then(error => {
                            throw new Error(error.message);
                        });
                    }
                    return response.json();
                });
            });

            return Promise.all(vmPromises);
        })
        .then(() => location.reload())
        .catch(error => {
            showError("Error creating VMs: " + error.message, "VM Creation Error");
        });
    }

    function fetchWithProgress(url, options) {
        showProgressBar();
        
        const startTime = Date.now();
        const timerInterval = 500; 
        let timerId = setInterval(() => {
            const elapsedTime = (Date.now() - startTime) / 1000;
            const timeDisplay = document.getElementById('timeDisplay');
            timeDisplay.textContent = `${(Math.floor(elapsedTime * 2) / 2).toFixed(1)}s`;
        }, timerInterval);

        return fetch(url, options)
            .then(response => {
                clearInterval(timerId); 
                hideProgressBar();
                return response;
            })
            .catch(error => {
                clearInterval(timerId);
                hideProgressBar();
                throw error;
            });
    }

    function showProgressBar() {
        const progressBarContainer = document.getElementById('progressBarContainer');
        const progressBar = document.getElementById('progressBar');
        progressBar.style.width = '0%';
        progressBarContainer.style.display = 'block';

        setTimeout(() => {
            progressBar.style.width = '100%';
        }, 100);
    }

    function hideProgressBar() {
        const progressBarContainer = document.getElementById('progressBarContainer');
        setTimeout(() => {
            progressBarContainer.style.display = 'none';
            document.getElementById('timeDisplay').textContent = ''; 
        }, 500);
    }

    document.addEventListener('DOMContentLoaded', function() {
        const connConfigElement = document.getElementById('connConfig');

        if (connConfigElement) {
            loadVPCs();
            loadKeyPairs();
            //loadSecurityGroups();
        } else {
            console.error("Error: 'connConfig' element not found.");
        }
    });

    function loadVPCs() {
        const connConfigElement = document.getElementById('connConfig');
        
        if (!connConfigElement) {
            console.error("Error: 'connConfig' element is null. Ensure that the element is present in the DOM.");
            return;
        }

        const connConfig = connConfigElement.value;
        const vpcSelect = document.getElementById('vpcSelect');

        if (!vpcSelect) {
            console.error("Error: 'vpcSelect' element is null. Ensure that the element is present in the DOM.");
            return;
        }

        fetch(`/spider/vpc?ConnectionName=${connConfig}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            
            vpcSelect.innerHTML = ''; // Clear existing options

            if (data.vpc && data.vpc.length > 0) {
                data.vpc.forEach((vpc, index) => {
                    const option = document.createElement('option');
                    option.value = JSON.stringify(vpc.SubnetInfoList);
                    option.textContent = `${vpc.IId.NameId} (${vpc.IPv4_CIDR})`;
                    vpcSelect.appendChild(option);
                });
                
                updateSubnets(); // Update subnets based on selected VPC
                loadSecurityGroups(); // Load security groups based on selected VPC
            } else {
                vpcSelect.innerHTML = '<option>No VPCs. Create one.</option>';
            }
        })
        .catch(error => {
            console.error('Error loading VPCs: ' + error.message);
        });
    }

    function updateSubnets() {
        const vpcSelect = document.getElementById('vpcSelect');
        const subnetSelect = document.getElementById('subnetSelect');
        const subnetZoneInput = document.getElementById('subnetZone');

        subnetSelect.innerHTML = '';
        
        if (!vpcSelect.value) {
            subnetSelect.innerHTML = '<option>Please select a VPC first.</option>';
            if (subnetZoneInput) subnetZoneInput.value = '';
            return;
        }
        
        let selectedSubnets;
        try {
            selectedSubnets = JSON.parse(vpcSelect.value);
        } catch (e) {
            subnetSelect.innerHTML = '<option>Error loading subnets</option>';
            if (subnetZoneInput) subnetZoneInput.value = '';
            return;
        }

        if (selectedSubnets && Array.isArray(selectedSubnets) && selectedSubnets.length > 0) {
            selectedSubnets.forEach((subnet, index) => {
                const option = document.createElement('option');
                option.value = subnet.IId.NameId;
                option.textContent = `${subnet.IId.NameId} (${subnet.IPv4_CIDR})`;
                
                // Determine the actual zone name
                let actualZone = subnet.Zone;
                
                // For CSPs like KT where subnet.Zone is a UUID, check KeyValueList for PortalZoneID
                // Only override if subnet.Zone looks like a UUID and PortalZoneID exists
                if (subnet.Zone && subnet.Zone.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)) {
                    if (subnet.KeyValueList) {
                        const portalZoneKV = subnet.KeyValueList.find(kv => kv.Key === 'PortalZoneID');
                        if (portalZoneKV && portalZoneKV.Value) {
                            actualZone = portalZoneKV.Value;
                        }
                    }
                }
                
                // Set zone as data attribute
                if (actualZone) {
                    option.setAttribute('data-zone', actualZone);
                }
                
                subnetSelect.appendChild(option);
            });

            // Explicitly select first subnet
            subnetSelect.selectedIndex = 0;
            
            // Update zone display for first subnet (this will also call loadDataDisks internally)
            updateSelectedSubnetZone();
        } else {
            subnetSelect.innerHTML = '<option>No subnets available for this VPC.</option>';
            if (subnetZoneInput) {
                subnetZoneInput.value = '';
            }
        }
    }

    function updateSelectedSubnetZone() {
        const subnetSelect = document.getElementById('subnetSelect');
        const subnetZoneInput = document.getElementById('subnetZone');
        
        if (!subnetZoneInput) {
            return;
        }
        
        if (!subnetSelect || subnetSelect.options.length === 0) {
            subnetZoneInput.value = '';
            return;
        }
        
        const selectedOption = subnetSelect.options[subnetSelect.selectedIndex];
        
        if (selectedOption) {
            const zone = selectedOption.getAttribute('data-zone') || selectedOption.dataset.zone;
            
            if (zone) {
                // Fetch actual zone Name (converts UUID to zone name for KT, etc.)
                fetchZoneDisplayName(zone).then(actualZoneName => {
                    if (actualZoneName) {
                        subnetZoneInput.value = actualZoneName;
                        loadDataDisks(actualZoneName);
                    } else {
                        subnetZoneInput.value = zone;
                        loadDataDisks(zone);
                    }
                }).catch(() => {
                    subnetZoneInput.value = zone;
                    loadDataDisks(zone);
                });
            } else {
                subnetZoneInput.value = '';
            }
        } else {
            subnetZoneInput.value = '';
        }
    }

    // Cache for zone mapping (UUID -> Zone Name)
    let zoneMapping = {};
    let zoneMappingPromise = null;

    // Load zone mapping once and cache it
    async function loadZoneMapping() {
        if (zoneMappingPromise) {
            return zoneMappingPromise;
        }
        
        zoneMappingPromise = (async () => {
            try {
                const regionId = '{{.Region}}';
                const connConfig = document.getElementById('connConfig').value;
                
                const response = await fetch(`/spider/regionzone/${regionId}?ConnectionName=${connConfig}`);
                const data = await response.json();
                
                if (data && data.ZoneList) {
                    // Build mapping: if subnet.Zone contains UUID, we need to find how to map it
                    // For now, assume only one zone in the list for KT, so we map directly
                    data.ZoneList.forEach(zone => {
                        // Map zone name to itself
                        zoneMapping[zone.Name] = zone.Name;
                        
                        // Check KeyValueList for SystemId or other identifiers
                        if (zone.KeyValueList) {
                            zone.KeyValueList.forEach(kv => {
                                if (kv.Key.toLowerCase().includes('id') || kv.Key.toLowerCase().includes('uuid')) {
                                    zoneMapping[kv.Value] = zone.Name;
                                }
                            });
                        }
                    });
                }
                return zoneMapping;
            } catch (error) {
                console.error('Error loading zone mapping:', error);
                return {};
            }
        })();
        
        return zoneMappingPromise;
    }

    async function fetchZoneDisplayName(zoneName) {
        try {
            // Load zone mapping if not already loaded
            await loadZoneMapping();
            
            // Check if we have a mapping for this zone
            if (zoneMapping[zoneName]) {
                return zoneMapping[zoneName];
            }
            
            return zoneName;
        } catch (error) {
            console.error('Error fetching zone display name:', error);
            return zoneName;
        }
    }

    function loadKeyPairs() {
        const connConfig = document.getElementById('connConfig').value;
        const keypairSelect = document.getElementById('keypairSelect');

        if (!keypairSelect) {
            console.error('KeyPair select element not found');
            return;
        }

        fetch(`/spider/keypair?ConnectionName=${connConfig}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            keypairSelect.innerHTML = ''; // Clear existing options

            if (data.keypair && data.keypair.length > 0) {
                data.keypair.forEach(keypair => {
                    const option = document.createElement('option');
                    option.value = keypair.IId.NameId;
                    option.textContent = keypair.IId.NameId;
                    keypairSelect.appendChild(option);
                });
            } else {
                keypairSelect.innerHTML = '<option>No keypairs available.</option>';
            }
        })
        .catch(error => {
            alert('Error loading keypairs: ' + error.message);
        });
    }

    function loadSecurityGroups() {
        const connConfig = document.getElementById('connConfig').value;
        const sgDropdownList = document.getElementById('sgDropdownList');
        const sgSelectedText = document.getElementById('sgSelectedText');
        const vpcName = document.getElementById('vpcSelect').options[document.getElementById('vpcSelect').selectedIndex].text.split(' ')[0];
        const url = `/spider/securitygroup/vpc/${vpcName}?ConnectionName=${connConfig}`
        
        if (!sgDropdownList) {
            console.error('Security Group dropdown element not found');
            return;
        }

        fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            sgDropdownList.innerHTML = ''; // Clear existing options

            if (data.securitygroup && data.securitygroup.length > 0) {
                data.securitygroup.forEach((sg, index) => {
                    const item = document.createElement('div');
                    item.className = 'sg-dropdown-item';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = sg.IId.NameId;
                    checkbox.id = `sg-${sg.IId.NameId}`;
                    checkbox.className = 'sg-checkbox';
                    // Auto-check first security group
                    if (index === 0) {
                        checkbox.checked = true;
                    }
                    checkbox.onchange = updateSGSelectedDisplay;
                    
                    const label = document.createElement('label');
                    label.htmlFor = `sg-${sg.IId.NameId}`;
                    label.textContent = sg.IId.NameId;
                    
                    item.appendChild(checkbox);
                    item.appendChild(label);
                    sgDropdownList.appendChild(item);
                });
                
                // Update display with initially selected item
                updateSGSelectedDisplay();
            } else {
                sgSelectedText.textContent = 'No security groups available for this VPC';
            }
        })
        .catch(error => {
            alert('Error loading security groups: ' + error.message);
        });
    }

    function toggleSGDropdown() {
        const dropdown = document.getElementById('sgDropdownList');
        dropdown.classList.toggle('open');
    }

    function updateSGSelectedDisplay() {
        const checkboxes = document.querySelectorAll('.sg-checkbox:checked');
        const sgSelectedText = document.getElementById('sgSelectedText');
        
        if (checkboxes.length === 0) {
            sgSelectedText.textContent = 'Select security groups';
        } else if (checkboxes.length === 1) {
            sgSelectedText.textContent = checkboxes[0].value;
        } else {
            sgSelectedText.textContent = `${checkboxes[0].value} (+${checkboxes.length - 1} more)`;
        }
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', function(event) {
        const wrapper = document.getElementById('securityGroupSelectWrapper');
        const dropdown = document.getElementById('sgDropdownList');
        if (wrapper && dropdown && !wrapper.contains(event.target)) {
            dropdown.classList.remove('open');
        }
    });

    function showProvisioningInfoOverlay(vmInfo) {
        const overlay = document.getElementById('provisioningInfoOverlay');
        const overlayContent = document.querySelector('.provisioning-info-overlay-content');
        overlayContent.innerHTML = `
            <button class="overlay-close-btn" onclick="closeProvisioningInfoOverlay()">X</button>
            <h3>VM Provisioning Info</h3>
            <table>
                <tr>
                    <th>VPC/Subnet</th>
                    <td>
                        <ul class="bullet-list">
                            <li>VPC: ${vmInfo.vpcName || 'N/A'}</li>
                            <li>Subnet: ${vmInfo.subnetName || 'N/A'} (${vmInfo.zone || 'N/A'})</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <th>Security Group</th>
                    <td>
                        <ul class="bullet-list">
                            <li>${(vmInfo.securityGroupName && vmInfo.securityGroupName.length > 0) ? vmInfo.securityGroupName.join('</li><li>') : 'N/A'}</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <th>KeyPair</th>
                    <td>
                        <ul class="bullet-list">
                            <li>${vmInfo.keypairName || 'N/A'}</li>
                            <li>VM User: ${vmInfo.vmUserId || 'N/A'}</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <th>Image/Spec</th>
                    <td>
                        <ul class="bullet-list">
                            <li>Image Type: ${vmInfo.imageType || 'N/A'}</li>
                            <li>Image ID: ${vmInfo.imageName || 'N/A'}</li>
                            <li>Platform: ${vmInfo.platform || 'N/A'}</li>
                            <li>Spec: ${vmInfo.vmSpecName || 'N/A'}</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <th>Disk</th>
                    <td>
                        <ul class="bullet-list">
                            <li>Root Disk Type: ${vmInfo.rootDiskType || 'N/A'} (${vmInfo.rootDiskSize || 'N/A'})</li>
                            <li>Root Device: ${vmInfo.rootDeviceName || 'N/A'}</li>
                            <li>Data Disks: ${(vmInfo.dataDisks && vmInfo.dataDisks.length > 0) 
                                    ? vmInfo.dataDisks.join('</li><li>') 
                                    : 'N/A'}
                            </li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <th>Network</th>
                    <td>
                        <ul class="bullet-list">
                            <li>NIC: ${vmInfo.networkInterface || 'N/A'}</li>
                            <li>Public IP: ${vmInfo.publicIP || 'N/A'}</li>
                            <li>Public DNS: ${vmInfo.publicDNS || 'N/A'}</li>
                            <li>Private IP: ${vmInfo.privateIP || 'N/A'}</li>
                            <li>Private DNS: ${vmInfo.privateDNS || 'N/A'}</li>
                        </ul>
                    </td>
                </tr>
            </table>
        `;
        overlay.style.display = 'flex';
        document.addEventListener('keydown', handleProvisioningInfoOverlayEsc);
    }

    function closeProvisioningInfoOverlay() {
        const overlay = document.getElementById('provisioningInfoOverlay');
        overlay.style.display = 'none';
        document.removeEventListener('keydown', handleProvisioningInfoOverlayEsc);
    }

    function handleProvisioningInfoOverlayEsc(event) {
        if (event.key === "Escape") {
            closeProvisioningInfoOverlay();
        }
    }

    function openSSHAccess(vmInfo) {
        let sshOverlay = document.getElementById('ssh-overlay');

        if (!sshOverlay) {
            sshOverlay = document.createElement('div');
            sshOverlay.id = 'ssh-overlay';
            sshOverlay.className = 'overlay';
            sshOverlay.innerHTML = `
                <div class="overlay-content" style="position: relative;">
                    <button class="overlay-close-btn" onclick="closeSSHOverlay()">X</button>
                    <h2>SSH Access</h2>
                    <p>Connect to ${vmInfo.vmUserId}@${vmInfo.publicIP}</p>
                    <form id="ssh-form">
                        <label for="privatekey">Private Key:</label><br>
                        <div id="dropZone" class="drop-zone">Drag & Drop a key file here or paste it manually</div>
                        <textarea id="privatekey" name="privatekey" rows="10" cols="30" required style="background-color: #fff5f5;">Private key for ${vmInfo.keyName}.</textarea><br>
                        <button type="button" onclick="connectSSH('${vmInfo.vmUserId}', '${vmInfo.publicIP}')">Connect</button>
                        <button type="button" onclick="closeSSHOverlay()">Cancel</button>
                    </form>
                    <div id="terminal" style="display:none;"></div>
                </div>
            `;
            document.body.appendChild(sshOverlay);
            setupDropZone();
        } else {
            sshOverlay.querySelector('#privatekey').value = `Private key for ${vmInfo.keyName}.`;
            sshOverlay.querySelector('p').textContent = `Connect to ${vmInfo.vmUserId}@${vmInfo.publicIP}`;
            sshOverlay.querySelector('#terminal').style.display = 'none';
            sshOverlay.querySelector('#ssh-form').style.display = 'block';
            sshOverlay.querySelector('button[onclick^="connectSSH"]').onclick = function() {
                connectSSH(vmInfo.vmUserId, vmInfo.publicIP);
            };
        }

        sshOverlay.style.display = 'flex';

        document.addEventListener('keydown', handleSSHOverlayEsc);
    }

    function closeSSHOverlay() {
        const sshOverlay = document.getElementById('ssh-overlay');
        sshOverlay.style.display = 'none';
        document.removeEventListener('keydown', handleSSHOverlayEsc);
    }

    function handleSSHOverlayEsc(event) {
        if (event.key === "Escape") {
            closeSSHOverlay();
        }
    }

    function connectSSH(user, ip) {
        const privateKey = document.getElementById('privatekey').value;
        const terminalDiv = document.getElementById('terminal');

        const sshForm = document.getElementById('ssh-form');
        sshForm.style.display = 'none';
        terminalDiv.style.display = 'block';

        if (terminalDiv._initialized) {
            terminalDiv.innerHTML = '';
        }

        const term = new Terminal({
            cursorBlink: true,
            cols: 100,
            rows: 30,
            scrollback: 5000
        });

        term.open(terminalDiv);
        terminalDiv._initialized = true;
        const socket = new WebSocket("ws://" + location.host + "/spider/adminweb/sshwebterminal/ws?user=" + encodeURIComponent(user) + "&ip=" + encodeURIComponent(ip) + "&privatekey=" + encodeURIComponent(privateKey));

        socket.onopen = function() {
            term.write('Connected to SSH...\r\n');
        };

        socket.onmessage = function(event) {
            const message = event.data;

            if (message.startsWith("Failed")) {
                alert(message); 
            } else {
                processLargeData(message, term);
            }
        };

        term.onData(function(data) {
            socket.send(data);
        });

        socket.onclose = function () {
            term.write('Connection closed.\r\n');
            closeSSHConnection(socket, term);
        };

        socket.onerror = function (error) {
            alert("Failed to connect to the SSH server. Please check your private key and try again. Error: " + (error.message || error));
            closeSSHConnection(socket, term);
        };

        function closeSSHConnection(socket, term) {
            if (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING) {
                socket.close();
            }
            term.dispose();
            closeSSHOverlay();
        }
    }

    function processLargeData(data, term) {
        const chunkSize = 1024;
        for (let i = 0; i < data.length; i += chunkSize) {
            term.write(data.substring(i, i + chunkSize));
        }
    }


    function setupDropZone() {
        const dropZone = document.getElementById('dropZone');
        const textArea = document.getElementById('privatekey');

        dropZone.addEventListener('dragover', function(event) {
            event.stopPropagation();
            event.preventDefault();
            event.dataTransfer.dropEffect = 'copy';
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', function() {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', function(event) {
            event.stopPropagation();
            event.preventDefault();
            dropZone.classList.remove('dragover');

            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    textArea.value = event.target.result;
                };
                reader.readAsText(files[0]);
            }
        });
    }


    function copyToClipboard(text) {
        const tempInput = document.createElement('input');
        tempInput.style.position = 'absolute';
        tempInput.style.left = '-9999px';
        tempInput.value = text;
        document.body.appendChild(tempInput);
        tempInput.select();
        try {
            document.execCommand('copy');
        } catch (err) {
            alert('Failed to copy text: ', err);
        }
        document.body.removeChild(tempInput);
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        const timeElements = document.querySelectorAll('.vm-start-time');

        timeElements.forEach(function(element) {
            const originalTime = element.getAttribute('data-time');
            const formattedTime = formatTime(originalTime);
            element.innerHTML = '&nbsp;‚Ä¢ ' + formattedTime;
        });

        function formatTime(originalTime) {
            const parts = originalTime.split(" ");
            const date = parts[0];
            const time = parts[1].slice(0, 5);
            const timezone = parts[3];
            return `${date} ${time} ${timezone}`;
        }
    });

    function loadDataDisks(zone) {
        const connConfig = document.getElementById('connConfig').value;
        const ddDropdownList = document.getElementById('ddDropdownList');
        const ddSelectedText = document.getElementById('ddSelectedText');

        if (!ddDropdownList) {
            console.error('Data Disk dropdown element not found');
            return;
        }

        fetch(`/spider/disk?ConnectionName=${connConfig}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            ddDropdownList.innerHTML = '';
            
            const filteredDisks = data.disk.filter(disk => disk.Zone === zone && disk.Status === "Available");
            
            if (filteredDisks.length > 0){
                filteredDisks.forEach(disk => {
                    const item = document.createElement('div');
                    item.className = 'dd-dropdown-item';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = disk.IId.NameId;
                    checkbox.id = `disk-${disk.IId.NameId}`;
                    checkbox.className = 'dd-checkbox';
                    checkbox.onchange = updateDDSelectedDisplay;
                    
                    const label = document.createElement('label');
                    label.htmlFor = `disk-${disk.IId.NameId}`;
                    label.textContent = `${disk.IId.NameId} (${disk.DiskSize} GB)`;
                    
                    item.appendChild(checkbox);
                    item.appendChild(label);
                    ddDropdownList.appendChild(item);
                });
                
                updateDDSelectedDisplay();
            } else {
                ddSelectedText.textContent = 'No disks available in the same zone';
            }
        }).catch(error =>{
            alert("Error loading data disks: " + error.message);
        });
    }

    function toggleDDDropdown() {
        const dropdown = document.getElementById('ddDropdownList');
        dropdown.classList.toggle('open');
    }

    function updateDDSelectedDisplay() {
        const checkboxes = document.querySelectorAll('.dd-checkbox:checked');
        const ddSelectedText = document.getElementById('ddSelectedText');
        
        if (checkboxes.length === 0) {
            ddSelectedText.textContent = 'Select data disks';
        } else if (checkboxes.length === 1) {
            ddSelectedText.textContent = checkboxes[0].nextElementSibling.textContent;
        } else {
            const firstName = checkboxes[0].nextElementSibling.textContent.split(' ')[0];
            ddSelectedText.textContent = `${firstName} (+${checkboxes.length - 1} more)`;
        }
    }

    // Close dropdown when clicking outside
    document.addEventListener('click', function(event) {
        const wrapper = document.getElementById('dataDiskSelectWrapper');
        const dropdown = document.getElementById('ddDropdownList');
        if (wrapper && dropdown && !wrapper.contains(event.target)) {
            dropdown.classList.remove('open');
        }
    });

    document.getElementById('subnetSelect').addEventListener('change', function() {
        const selectedZone = this.options[this.selectedIndex].dataset.zone;
        loadDataDisks(selectedZone);
    });

    function showMiscOverlay(button) {
        const miscContent = button.previousElementSibling.innerHTML;
        document.getElementById('miscContent').innerHTML = `<div>${miscContent}</div>`;
        document.getElementById('miscOverlay').style.display = 'flex';
        document.addEventListener('keydown', handleMiscOverlayEsc);
    }

    function closeMiscOverlay() {
        document.getElementById('miscOverlay').style.display = 'none';
        document.removeEventListener('keydown', handleMiscOverlayEsc);
    }

    function handleMiscOverlayEsc(event) {
        if (event.key === "Escape") {
            closeMiscOverlay();
        }
    }

    function updateImageNameField() {
        const imageType = document.getElementById('imageType').value;
        const imageNameField = document.getElementById('imageNameField');
        const rootDiskTypeField = document.getElementById('rootDiskType');
        const rootDiskSizeField = document.getElementById('rootDiskSize');
        
        if (imageType === 'MyImage') {
            rootDiskTypeField.value = '';
            rootDiskSizeField.value = '';
            rootDiskTypeField.disabled = true;
            rootDiskSizeField.disabled = true;
            fetchMyImages();
        } else if (imageType === 'PublicImage') {
            rootDiskTypeField.value = 'default';
            rootDiskTypeField.disabled = false;
            rootDiskSizeField.disabled = false;
            imageNameField.innerHTML = `
                <input type="text" id="imageName" name="imageName" required style="background-color: #f7f7e6; flex: 1; border: 1px solid #767676; padding: 2px;" readonly>
                <button type="button" onclick="showImageSelectionOverlay()" style="margin-left: 5px; min-width: 26px; height: 22px; padding: 0 4px; font-size: 12px; line-height: 1;">üîç</button>
            `;
        }
    }

    function fetchMyImages() {
        const connConfig = document.getElementById('connConfig').value;
        
        fetch(`/spider/myimage?ConnectionName=${connConfig}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            const imageNameField = document.getElementById('imageNameField');
            const images = data.myImage || [];
            
            if (images.length > 0) {
                imageNameField.innerHTML = `
                    <select id="imageName" name="imageName" required style="background-color: #f7f7e6;">
                        ${images.map(image => `<option value="${image.IId.NameId}">${image.IId.NameId} (${image.Status})</option>`).join('')}
                    </select>
                `;
            } else {
                imageNameField.innerHTML = '<p>No available MyImages</p>';
            }
        })
        .catch(error => {
            alert('Error fetching MyImages: ' + error.message);
        });
    }

    function showAddTagOverlay(vmName) {
        const addTagOverlay = document.getElementById('add-tag-overlay');
        const addTagOverlayContent = document.querySelector('.add-tag-overlay-content');
        addTagOverlayContent.innerHTML = `
            <button type="button" class="overlay-close-btn" onclick="closeAddTagOverlay()">X</button>
            <div class="tag-overlay-input-group">
                <label for="tagOverlayTagKey">Tag Key:</label>
                <input type="text" id="tagOverlayTagKey" name="tagKey" required>
            </div>
            <div class="tag-overlay-input-group">
                <label for="tagOverlayTagValue">Tag Value:</label>
                <input type="text" id="tagOverlayTagValue" name="tagValue" required>
            </div>
            <div class="tag-overlay-button-group">
                <button onclick="addTag('${vmName}')">Add</button>
                <button onclick="closeAddTagOverlay()">Cancel</button>
            </div>
        `;
        addTagOverlay.style.display = 'flex';
        document.addEventListener('keydown', handleAddTagOverlayEsc);
    }

    function closeAddTagOverlay() {
        const addTagOverlay = document.getElementById('add-tag-overlay');
        addTagOverlay.style.display = 'none';
        document.removeEventListener('keydown', handleAddTagOverlayEsc);
    }

    function handleAddTagOverlayEsc(event) {
        if (event.key === "Escape") {
            closeAddTagOverlay();
        }
    }
    
    function addTag(vmName) {
        const tagKey = document.getElementById('tagOverlayTagKey').value;
        const tagValue = document.getElementById('tagOverlayTagValue').value;
        const connConfig = document.getElementById('connConfig').value;

        const data = {
            ConnectionName: connConfig,
            ReqInfo: {
                ResourceType: 'VM',
                ResourceName: vmName,
                Tag: { Key: tagKey, Value: tagValue }
            }
        };

        fetchWithProgress('/spider/tag', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(data)
        }).then(response => {
            if (!response.ok) {
                return response.json().then(error => {
                    throw new Error(error.message);
                });
            }
            return response.json();
        }).then(() => {
            closeAddTagOverlay();
            location.reload();
        }).catch(error => {
            showError("Error adding tag: " + error.message, "VM Name: " + keyPairName);
        });
    }

    function showSystemIdOverlay(systemId) {
        const overlay = document.getElementById('system-id-overlay');
        const fullSystemIdElement = document.getElementById('fullSystemId');
        fullSystemIdElement.textContent = systemId;

        overlay.style.display = 'block';
        document.addEventListener('keydown', handleSystemIdOverlayEsc);
    }

    function closeSystemIdOverlay() {
        const overlay = document.getElementById('system-id-overlay');
        overlay.style.display = 'none';
        document.removeEventListener('keydown', handleSystemIdOverlayEsc);
    }

    function handleSystemIdOverlayEsc(event) {
        if (event.key === "Escape") {
            closeSystemIdOverlay();
        }
    }

    function copySystemId() {
        const fullSystemIdElement = document.getElementById('fullSystemId');
        const range = document.createRange();
        range.selectNode(fullSystemIdElement);
        const selection = window.getSelection();

        selection.removeAllRanges();
        selection.addRange(range);

        try {
            document.execCommand('copy');
            closeSystemIdOverlay();
        } catch (err) {
            console.error('Error copying SystemId: ', err);
        }

        selection.removeAllRanges();
    }

    // MC-Insight API Configuration (via Spider Proxy)
    const MC_INSIGHT_API_BASE = '/spider/mcinsight';
    const ITEMS_PER_PAGE = 50;

    let currentImagePage = 0;
    let currentSpecPage = 0;
    let imageFilters = {};
    let specFilters = {};
    let imageTotalCount = 0;
    let specTotalCount = 0;
    let imageSortField = 'image_id';
    let imageSortOrder = 'asc';
    let specSortField = 'name';
    let specSortOrder = 'asc';
    
    // OpenStack data cache (fetched from Spider API)
    let openstackAllImages = [];
    let openstackAllSpecs = [];
    let currentImageData = []; // Store current page image data for selection
    let currentSpecData = []; // Store current page spec data for selection
    let selectedOSArch = ''; // Store selected OS architecture from image selection

    // Check if MC-Insight API Token is configured
    async function checkMCInsightToken() {
        try {
            const response = await fetch(`${MC_INSIGHT_API_BASE}/vm-image/filters`);
            return response.status !== 503;
        } catch (error) {
            return false;
        }
    }

    function showTokenWarning(containerId) {
        const container = document.getElementById(containerId);
        container.innerHTML = `
            <div style="
                background: #fff3cd;
                border: 2px solid #ffc107;
                border-radius: 8px;
                padding: 20px 30px;
                margin: 20px auto;
                max-width: 600px;
                box-shadow: 0 4px 12px rgba(255, 193, 7, 0.2);
            ">
                <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <span style="font-size: 32px; margin-right: 15px;">‚ö†Ô∏è</span>
                    <h3 style="margin: 0; color: #856404; font-size: 18px;">MC-Insight API Token Required</h3>
                </div>
                <div style="color: #856404; line-height: 1.6;">
                    <p style="margin: 10px 0;">To search multi-cloud metadata using MC-Insight, you need to configure the MC-Insight API Token.</p>
                    <p style="margin: 10px 0;">Please follow these steps:</p>
                    <ol style="margin: 10px 0; padding-left: 20px;">
                        <li>Get token from <strong>MC-Insight service administrator</strong></li>
                        <li>Set the <code style="background: #fff; padding: 2px 6px; border-radius: 3px; border: 1px solid #ddd;">MC_INSIGHT_API_TOKEN</code> value in <code style="background: #fff; padding: 2px 6px; border-radius: 3px; border: 1px solid #ddd;">./setup.env</code></li>
                        <li>Restart CB-Spider</li>
                    </ol>
                </div>
            </div>
        `;
    }

    // Helper function to get CSP and Region info from connection config
    async function getConnectionInfo() {
        try {
            const connConfig = document.getElementById('connConfig').value;
            const connData = await fetch(`/spider/connectionconfig/${connConfig}`).then(r => r.json());
            const providerName = connData.ProviderName.toLowerCase();
            const regionName = connData.RegionName;
            
            // Get Region details to find actual CSP region name
            const regionData = await fetch(`/spider/region/${regionName}`).then(r => r.json());
            
            // Extract actual CSP region from KeyValueInfoList
            let cspRegion = '';
            if (regionData && regionData.KeyValueInfoList) {
                const regionEntry = regionData.KeyValueInfoList.find(kv => kv.Key === 'Region');
                if (regionEntry) {
                    cspRegion = regionEntry.Value;
                }
            }
            
            // Get zone from currently selected subnet's data-zone attribute
            let zoneName = '';
            const subnetSelect = document.getElementById('subnetSelect');
            if (subnetSelect && subnetSelect.selectedIndex >= 0) {
                const selectedOption = subnetSelect.options[subnetSelect.selectedIndex];
                zoneName = selectedOption.getAttribute('data-zone') || selectedOption.dataset.zone || '';
            }
            
            return { csp: providerName, region: cspRegion, zone: zoneName };
        } catch (error) {
            console.error('Error getting connection info:', error);
            throw error;
        }
    }

    // Helper function to get CSP name from connection config (backward compatibility)
    function getCSPFromConnection() {
        return getConnectionInfo().then(info => info.csp);
    }

    // ==================== IMAGE SELECTION FUNCTIONS ====================

    function showImageSelectionOverlay() {
        // Check if subnet is selected
        const subnetSelect = document.getElementById('subnetSelect');
        
        if (!subnetSelect.value || subnetSelect.value === '') {
            alert('Please select a Subnet first. The Zone will be determined from the selected Subnet.');
            return;
        }
        
        const overlay = document.getElementById('image-selection-overlay');
        overlay.style.display = 'flex';
        document.addEventListener('keydown', handleImageSelectionOverlayEsc);
        
        // Set Image Name filter from Add New VM form if it has a value
        const currentImageName = document.getElementById('imageName');
        const imageFilterName = document.getElementById('image-filter-name');
        if (currentImageName && currentImageName.value && imageFilterName) {
            imageFilterName.value = currentImageName.value.trim();
        }
        
        // Get current connection info and set filters
        getConnectionInfo().then(info => {
            if (!info.zone) {
                alert('Cannot determine Zone from selected Subnet. Please select a valid Subnet.');
                closeImageSelectionOverlay();
                return;
            }
            
            // For OpenStack and MOCK, skip MC-Insight token check and load filters directly
            if (info.csp.toLowerCase() === 'openstack' || info.csp.toLowerCase() === 'mock') {
                loadImageFilterOptions(info.csp, info.region, info.zone);
                
                // Add Enter key event listeners to filter inputs
                ['image-filter-name', 'image-filter-distribution'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('keypress', function(event) {
                            if (event.key === 'Enter') {
                                event.preventDefault();
                                applyImageFilters();
                            }
                        });
                    }
                });
                return;
            }
            
            // For other CSPs, check if MC-Insight token is configured
            checkMCInsightToken().then(hasToken => {
                if (!hasToken) {
                    showTokenWarning('image-list-container');
                    document.getElementById('image-pagination').style.display = 'none';
                    return;
                }
                
                loadImageFilterOptions(info.csp, info.region, info.zone);
                
                // Add Enter key event listeners to filter inputs
                ['image-filter-name', 'image-filter-distribution'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('keypress', function(event) {
                            if (event.key === 'Enter') {
                                event.preventDefault();
                                applyImageFilters();
                            }
                        });
                    }
                });
            });
        }).catch(error => {
            console.error('Error loading connection info:', error);
            alert('Failed to load connection information');
            closeImageSelectionOverlay();
        });
    }

    function closeImageSelectionOverlay() {
        const overlay = document.getElementById('image-selection-overlay');
        overlay.style.display = 'none';
        document.removeEventListener('keydown', handleImageSelectionOverlayEsc);
    }

    function handleImageSelectionOverlayEsc(event) {
        if (event.key === 'Escape') {
            const priceOverlay = document.getElementById('price-info-overlay');
            // Don't close if Price Info overlay is open (it should close first)
            if (priceOverlay && priceOverlay.style.display === 'flex') {
                return;
            }
            event.stopImmediatePropagation();
            closeImageSelectionOverlay();
        }
    }

    function loadImageFilterOptions(csp, currentRegion, currentZone) {
        // ==================== OPENSTACK & MOCK: EXTRACT FROM CACHED DATA ====================
        if (csp.toLowerCase() === 'openstack' || csp.toLowerCase() === 'mock') {
            const regionSelect = document.getElementById('image-filter-region');
            const zoneSelect = document.getElementById('image-filter-zone');
            const archSelect = document.getElementById('image-filter-arch');
            const platformSelect = document.getElementById('image-filter-platform');
            
            // Set region and zone from connection (locked)
            regionSelect.innerHTML = `<option value="${currentRegion}">${currentRegion}</option>`;
            regionSelect.disabled = true;
            regionSelect.style.backgroundColor = '#f0f0f0';
            
            zoneSelect.innerHTML = `<option value="${currentZone}">${currentZone}</option>`;
            zoneSelect.disabled = true;
            zoneSelect.style.backgroundColor = '#f0f0f0';
            
            // Save current filter values to restore after repopulating
            const savedArchValue = archSelect.value;
            const savedPlatformValue = platformSelect.value;
            
            // If we have cached images, extract unique values for filters
            if (openstackAllImages.length > 0) {
                // Extract unique architectures
                const uniqueArchs = [...new Set(openstackAllImages.map(img => img.os_architecture).filter(v => v && v !== 'NA'))];
                archSelect.innerHTML = '<option value="">All</option>';
                uniqueArchs.forEach(arch => {
                    const option = document.createElement('option');
                    option.value = arch;
                    option.textContent = arch;
                    archSelect.appendChild(option);
                });
                // Restore saved value if it exists in options
                archSelect.value = savedArchValue || '';
                
                // Extract unique platforms
                const uniquePlatforms = [...new Set(openstackAllImages.map(img => img.os_platform).filter(v => v && v !== 'na'))];
                platformSelect.innerHTML = '<option value="">All</option>';
                uniquePlatforms.forEach(platform => {
                    const option = document.createElement('option');
                    option.value = platform;
                    option.textContent = platform.charAt(0).toUpperCase() + platform.slice(1);
                    platformSelect.appendChild(option);
                });
                // Restore saved value if it exists in options
                platformSelect.value = savedPlatformValue || '';
            } else {
                // Set defaults while data is loading
                archSelect.innerHTML = '<option value="">All</option>';
                archSelect.value = savedArchValue || '';
                platformSelect.innerHTML = '<option value="">All</option>';
                platformSelect.value = savedPlatformValue || '';
            }
            
            // Set filters with locked region/zone
            imageFilters = {
                region: currentRegion,
                zone: currentZone
            };
            
            // Set initial message - data loads when Search is clicked
            document.getElementById('image-list-container').innerHTML = '<div class="loading-message">Press Search to load images</div>';
            document.getElementById('image-pagination').style.display = 'none';
            return;
        }
        
        // ==================== NON-OPENSTACK: USE MC-INSIGHT FILTER API ====================
        // Show MC-Insight badge for non-OpenStack CSPs
        const badge = document.getElementById('image-mcinsight-badge');
        if (badge) badge.style.display = '';
        
        fetch(`/spider/mcinsight/vm-image/filters`)
        .then(response => response.json())
        .then(data => {
            
            const regionSelect = document.getElementById('image-filter-region');
            const zoneSelect = document.getElementById('image-filter-zone');
            const archSelect = document.getElementById('image-filter-arch');
            const platformSelect = document.getElementById('image-filter-platform');
            
            regionSelect.innerHTML = '';
            zoneSelect.innerHTML = '';
            
            // Try NCP first, fallback to NCPVPC if not found
            let actualCsp = csp;
            if (csp.toLowerCase() === 'ncp' && (!data.cloud_hierarchy || !data.cloud_hierarchy[csp])) {
                actualCsp = 'ncpvpc';
                console.log('NCP not found in filters, using NCPVPC');
            }
            // Try NHN first, fallback to nhncloud if not found
            if (csp.toLowerCase() === 'nhn' && (!data.cloud_hierarchy || !data.cloud_hierarchy[csp])) {
                actualCsp = 'nhncloud';
                console.log('NHN not found in filters, using nhncloud');
            }
            // Try KT first, fallback to ktvpc if not found
            if (csp.toLowerCase() === 'kt' && (!data.cloud_hierarchy || !data.cloud_hierarchy[csp])) {
                actualCsp = 'ktvpc';
                console.log('KT not found in filters, using ktvpc');
            }
            
            // Populate Region/Zone (cloud_hierarchy)
            if (data.cloud_hierarchy && data.cloud_hierarchy[actualCsp]) {
                const regions = Object.keys(data.cloud_hierarchy[actualCsp]);
                
                regions.forEach(region => {
                    const option = document.createElement('option');
                    option.value = region;
                    option.textContent = region;
                    if (region === currentRegion) {
                        option.selected = true;
                    }
                    regionSelect.appendChild(option);
                });
                
                regionSelect.disabled = true;
                regionSelect.style.backgroundColor = '#f0f0f0';
                
                const zones = data.cloud_hierarchy[actualCsp][currentRegion];
                
                if (zones && zones.length > 0) {
                    zones.forEach(zone => {
                        const option = document.createElement('option');
                        option.value = zone;
                        option.textContent = zone;
                        if (zone === currentZone) {
                            option.selected = true;
                        }
                        zoneSelect.appendChild(option);
                    });
                    
                    zoneSelect.disabled = true;
                    zoneSelect.style.backgroundColor = '#f0f0f0';
                }
            }
            
            // Save current filter values to restore after repopulating
            const savedArchValue = archSelect.value;
            const savedPlatformValue = platformSelect.value;
            
            // Populate OS Architecture options dynamically
            if (data.os_architecture) {
                archSelect.innerHTML = '<option value="">All</option>';
                data.os_architecture.filter(val => val !== '~null').forEach(arch => {
                    const option = document.createElement('option');
                    option.value = arch;
                    option.textContent = arch;
                    archSelect.appendChild(option);
                });
                // Restore saved value if it exists in options
                archSelect.value = savedArchValue || '';
            }
            
            // Populate OS Platform options dynamically
            if (data.os_platform) {
                platformSelect.innerHTML = '<option value="">All</option>';
                data.os_platform.filter(val => val !== '~null').forEach(platform => {
                    const option = document.createElement('option');
                    option.value = platform;
                    option.textContent = platform.charAt(0).toUpperCase() + platform.slice(1);
                    platformSelect.appendChild(option);
                });
                // Restore saved value if it exists in options
                platformSelect.value = savedPlatformValue || '';
            }
            
        })
        .catch(error => {
            console.error('Error loading image filters:', error);
            alert('Failed to load image filters');
        });
    }

    function loadImageZones(csp, zones) {
        // This function is no longer needed as zones are loaded and locked in loadImageFilterOptions
    }

    function applyImageFilters() {
        currentImagePage = 0;
        imageFilters = {
            region: document.getElementById('image-filter-region').value,
            zone: document.getElementById('image-filter-zone').value,
            os_architecture: document.getElementById('image-filter-arch').value,
            os_platform: document.getElementById('image-filter-platform').value,
            os_distribution: document.getElementById('image-filter-distribution').value.trim(),
            image_name: document.getElementById('image-filter-name').value.trim()
        };
        loadImages();
    }

    function resetImageFilters() {
        // Region and Zone are locked, so we don't reset them
        // Reset to initial values
        document.getElementById('image-filter-arch').value = '';
        document.getElementById('image-filter-platform').value = '';
        document.getElementById('image-filter-distribution').value = '';
        document.getElementById('image-filter-name').value = '';
        
        // Keep region and zone filters but reset others
        imageFilters = {
            region: document.getElementById('image-filter-region').value,
            zone: document.getElementById('image-filter-zone').value
        };
        currentImagePage = 0;
        imageSortField = 'image_id';
        imageSortOrder = 'asc';
        document.getElementById('image-list-container').innerHTML = '<div class="loading-message">Press Search to load images</div>';
        document.getElementById('image-pagination').style.display = 'none';
    }

    // ==================== OPENSTACK SPIDER API FUNCTIONS ====================
    
    async function loadImagesFromSpider(connectionName) {
        const url = `/spider/vmimage?ConnectionName=${encodeURIComponent(connectionName)}`;
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Spider API error: ${response.status}`);
        }
        const data = await response.json();
        
        // Transform Spider API format to MC-Insight format
        // Spider returns: {image: [{IId, Name, OSArchitecture, OSPlatform, OSDistribution, OSDiskType, OSDiskSizeGB, ImageStatus, KeyValueList}]}
        const transformedImages = (data.image || []).map(img => {
            // Parse disk size
            let diskSize = -1;
            if (img.OSDiskSizeGB && img.OSDiskSizeGB !== 'NA' && img.OSDiskSizeGB !== '0') {
                const parsed = parseInt(img.OSDiskSizeGB);
                if (!isNaN(parsed) && parsed > 0) diskSize = parsed;
            }
            
            return {
                image_id: img.IId?.NameId || img.Name || 'Unknown',
                system_id: img.IId?.SystemId || img.Name || '',
                os_architecture: img.OSArchitecture && img.OSArchitecture !== 'NA' ? img.OSArchitecture : 'NA',
                os_platform: img.OSPlatform && img.OSPlatform !== 'NA' ? img.OSPlatform.toLowerCase() : 'na',
                os_distribution: img.OSDistribution && img.OSDistribution !== 'NA' ? img.OSDistribution : 'NA',
                os_disk_type: img.OSDiskType && img.OSDiskType !== 'NA' ? img.OSDiskType : 'NA',
                os_disk_size_gb: diskSize,
                image_status: img.ImageStatus || 'NA'
            };
        });
        
        return transformedImages;
    }
    
    async function loadSpecsFromSpider(connectionName) {
        const url = `/spider/vmspec?ConnectionName=${encodeURIComponent(connectionName)}`;
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Spider API error: ${response.status}`);
        }
        const data = await response.json();
        
        // Transform Spider API format to MC-Insight format
        // Spider returns: {vmspec: [{Region, Name, VCpu: {Count, ClockGHz}, MemSizeMiB, DiskSizeGB, Gpu, KeyValueList}]}
        const transformedSpecs = (data.vmspec || []).map(spec => {
            // Parse Memory (MiB)
            let memSizeMib = -1;
            if (spec.MemSizeMiB) {
                const parsed = parseInt(spec.MemSizeMiB);
                if (!isNaN(parsed) && parsed > 0) memSizeMib = parsed;
            }
            
            // Parse Disk (GB)
            let diskSizeGb = -1;
            if (spec.DiskSizeGB) {
                const parsed = parseInt(spec.DiskSizeGB);
                if (!isNaN(parsed) && parsed > 0) diskSizeGb = parsed;
            }
            
            // Parse vCPU Count
            let vcpuCount = -1;
            if (spec.VCpu?.Count) {
                const parsed = parseInt(spec.VCpu.Count);
                if (!isNaN(parsed) && parsed > 0) vcpuCount = parsed;
            }
            
            // Parse vCPU Clock
            let vcpuClockGhz = 'NA';
            if (spec.VCpu?.ClockGHz && spec.VCpu.ClockGHz !== '-1') {
                vcpuClockGhz = spec.VCpu.ClockGHz;
            }
            
            return {
                name: spec.Name || 'Unknown',
                vcpu_count: vcpuCount,
                vcpu_clock_ghz: vcpuClockGhz,
                mem_size_mib: memSizeMib,
                disk_size_gb: diskSizeGb,
                gpu_count: spec.Gpu?.length > 0 ? spec.Gpu[0].Count : -1,
                gpu_mem_size_gb: spec.Gpu?.length > 0 && spec.Gpu[0].MemSizeGB ? parseInt(spec.Gpu[0].MemSizeGB) : -1,
                gpu_model: spec.Gpu?.length > 0 ? spec.Gpu[0].Model : 'NA',
                price_per_hour: null  // OpenStack doesn't have price info - use null to display as NA
            };
        });
        
        return transformedSpecs;
    }
    
    function extractKeyValue(keyValueList, key) {
        if (!keyValueList || !Array.isArray(keyValueList)) return null;
        const item = keyValueList.find(kv => kv.Key === key);
        return item ? item.Value : null;
    }
    
    function filterOpenStackImages(images, filters) {
        return images.filter(img => {
            // Apply filters
            if (filters.os_architecture && img.os_architecture !== filters.os_architecture) return false;
            if (filters.os_platform && img.os_platform !== filters.os_platform.toLowerCase()) return false;
            if (filters.os_distribution && !img.os_distribution.toLowerCase().includes(filters.os_distribution.toLowerCase())) return false;
            if (filters.image_name && !img.image_id.toLowerCase().includes(filters.image_name.toLowerCase())) return false;
            return true;
        });
    }
    
    function filterOpenStackSpecs(specs, filters) {
        return specs.filter(spec => {
            // Apply name filter
            if (filters.name && !spec.name.toLowerCase().includes(filters.name.toLowerCase())) return false;
            
            // Apply vCPU filter
            if (filters.min_vcpu_count !== undefined && filters.min_vcpu_count !== '' && spec.vcpu_count < parseInt(filters.min_vcpu_count)) return false;
            if (filters.max_vcpu_count !== undefined && filters.max_vcpu_count !== '' && spec.vcpu_count > parseInt(filters.max_vcpu_count)) return false;
            
            // Apply memory filter (filters use MiB, spec uses MiB - direct comparison)
            if (filters.min_mem_size_mib !== undefined && filters.min_mem_size_mib !== '' && spec.mem_size_mib > 0) {
                if (spec.mem_size_mib < parseInt(filters.min_mem_size_mib)) return false;
            }
            if (filters.max_mem_size_mib !== undefined && filters.max_mem_size_mib !== '' && spec.mem_size_mib > 0) {
                if (spec.mem_size_mib > parseInt(filters.max_mem_size_mib)) return false;
            }
            
            // Apply GPU count filter (exclude NA when filter is set)
            if (filters.min_gpu_count !== undefined && filters.min_gpu_count !== '') {
                if (spec.gpu_count <= 0) return false;  // Exclude NA (-1) or 0
                if (spec.gpu_count < parseInt(filters.min_gpu_count)) return false;
            }
            if (filters.max_gpu_count !== undefined && filters.max_gpu_count !== '') {
                if (spec.gpu_count <= 0) return false;  // Exclude NA (-1) or 0
                if (spec.gpu_count > parseInt(filters.max_gpu_count)) return false;
            }
            
            // Apply GPU memory filter (exclude NA when filter is set)
            if (filters.min_gpu_mem_size_gb !== undefined && filters.min_gpu_mem_size_gb !== '') {
                if (spec.gpu_mem_size_gb <= 0) return false;  // Exclude NA (-1) or 0
                if (spec.gpu_mem_size_gb < parseInt(filters.min_gpu_mem_size_gb)) return false;
            }
            if (filters.max_gpu_mem_size_gb !== undefined && filters.max_gpu_mem_size_gb !== '') {
                if (spec.gpu_mem_size_gb <= 0) return false;  // Exclude NA (-1) or 0
                if (spec.gpu_mem_size_gb > parseInt(filters.max_gpu_mem_size_gb)) return false;
            }
            
            // Apply GPU model filter (exclude NA when filter is set)
            if (filters.gpu_model && filters.gpu_model !== '') {
                if (spec.gpu_model === 'NA' || !spec.gpu_model) return false;  // Exclude NA
                if (!spec.gpu_model.toLowerCase().includes(filters.gpu_model.toLowerCase())) return false;
            }
            
            return true;
        });
    }
    
    function sortOpenStackData(data, field, order) {
        return [...data].sort((a, b) => {
            let aVal = a[field];
            let bVal = b[field];
            
            // Handle NA values
            if (aVal === 'NA' || aVal === -1) aVal = order === 'asc' ? Infinity : -Infinity;
            if (bVal === 'NA' || bVal === -1) bVal = order === 'asc' ? Infinity : -Infinity;
            
            // Convert to numbers if needed
            if (typeof aVal === 'string' && !isNaN(aVal)) aVal = parseFloat(aVal);
            if (typeof bVal === 'string' && !isNaN(bVal)) bVal = parseFloat(bVal);
            
            // String comparison (case-insensitive)
            if (typeof aVal === 'string') aVal = aVal.toLowerCase();
            if (typeof bVal === 'string') bVal = bVal.toLowerCase();
            
            if (aVal < bVal) return order === 'asc' ? -1 : 1;
            if (aVal > bVal) return order === 'asc' ? 1 : -1;
            return 0;
        });
    }

    function loadImages() {
        getCSPFromConnection().then(csp => {
            // ==================== OPENSTACK & MOCK: USE SPIDER API ====================
            if (csp.toLowerCase() === 'openstack' || csp.toLowerCase() === 'mock') {
                // Hide MC-Insight badge for OpenStack and MOCK
                const badge = document.getElementById('image-mcinsight-badge');
                if (badge) badge.style.display = 'none';
                
                const container = document.getElementById('image-list-container');
                let loadingOverlay = container.querySelector('.table-loading-overlay');
                if (!loadingOverlay) {
                    loadingOverlay = document.createElement('div');
                    loadingOverlay.className = 'table-loading-overlay';
                    loadingOverlay.textContent = 'Loading...';
                    container.appendChild(loadingOverlay);
                }
                loadingOverlay.classList.add('active');
                
                // Get current connection name
                const connectionName = document.getElementById('connConfig').value;
                
                // Load images from Spider API (only once, then cache)
                if (openstackAllImages.length === 0) {
                    loadImagesFromSpider(connectionName)
                        .then(images => {
                            openstackAllImages = images;
                            
                            // Apply filters and sorting
                            let filteredImages = filterOpenStackImages(openstackAllImages, imageFilters);
                            filteredImages = sortOpenStackData(filteredImages, imageSortField, imageSortOrder);
                            
                            // Update total count
                            imageTotalCount = filteredImages.length;
                            
                            // Paginate
                            const startIdx = currentImagePage * ITEMS_PER_PAGE;
                            const endIdx = startIdx + ITEMS_PER_PAGE;
                            const pageImages = filteredImages.slice(startIdx, endIdx);
                            
                            displayImages(pageImages);
                            updateImagePagination('Spider-OpenStack');
                            loadingOverlay.classList.remove('active');
                        })
                        .catch(error => {
                            console.error('Error loading OpenStack images:', error);
                            loadingOverlay.classList.remove('active');
                            container.innerHTML = `
                                <div class="no-data-message">
                                    <p><strong>Error loading OpenStack images</strong></p>
                                    <p style="font-size: 12px; color: #666;">${error.message}</p>
                                    <button class="select-btn" onclick="openstackAllImages = []; loadImages();" style="margin-top: 10px;">Retry</button>
                                </div>
                            `;
                        });
                } else {
                    // Use cached data
                    let filteredImages = filterOpenStackImages(openstackAllImages, imageFilters);
                    filteredImages = sortOpenStackData(filteredImages, imageSortField, imageSortOrder);
                    
                    imageTotalCount = filteredImages.length;
                    const startIdx = currentImagePage * ITEMS_PER_PAGE;
                    const endIdx = startIdx + ITEMS_PER_PAGE;
                    const pageImages = filteredImages.slice(startIdx, endIdx);
                    
                    displayImages(pageImages);
                    updateImagePagination('Spider-OpenStack');
                    loadingOverlay.classList.remove('active');
                }
                return;
            }
            
            // ==================== NON-OPENSTACK: USE MC-INSIGHT API ====================
            // Show MC-Insight badge for non-OpenStack CSPs
            const badge = document.getElementById('image-mcinsight-badge');
            if (badge) badge.style.display = '';
            
            const params = new URLSearchParams({
                csp: csp,
                skip: currentImagePage * ITEMS_PER_PAGE,
                limit: ITEMS_PER_PAGE
            });

            // Add filters if they exist
            Object.keys(imageFilters).forEach(key => {
                if (imageFilters[key]) {
                    params.append(key, imageFilters[key]);
                }
            });

            // Add sort parameter if set
            if (imageSortField) {
                const sortParam = imageSortOrder === 'desc' ? `-${imageSortField}` : imageSortField;
                params.append('sort', sortParam);
            }

            const container = document.getElementById('image-list-container');
            
            // Show loading overlay instead of replacing content
            let loadingOverlay = container.querySelector('.table-loading-overlay');
            if (!loadingOverlay) {
                loadingOverlay = document.createElement('div');
                loadingOverlay.className = 'table-loading-overlay';
                loadingOverlay.textContent = 'Loading...';
                container.appendChild(loadingOverlay);
            }
            loadingOverlay.classList.add('active');

            const apiUrl = `${MC_INSIGHT_API_BASE}/vm-image?${params.toString()}`;

            fetch(apiUrl, {
                method: 'GET',
                headers: {
                    'accept': 'application/json'
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // If NCP returns no results, try with NCPVPC
                if ((data.total === 0 || !data.items || data.items.length === 0) && csp.toLowerCase() === 'ncp') {
                    console.log('NCP returned no results, trying NCPVPC...');
                    params.set('csp', 'ncpvpc');
                    const fallbackUrl = `${MC_INSIGHT_API_BASE}/vm-image?${params.toString()}`;
                    return fetch(fallbackUrl, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json'
                        }
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    });
                }
                // If NHN returns no results, try with nhncloud
                if ((data.total === 0 || !data.items || data.items.length === 0) && csp.toLowerCase() === 'nhn') {
                    console.log('NHN returned no results, trying nhncloud...');
                    params.set('csp', 'nhncloud');
                    const fallbackUrl = `${MC_INSIGHT_API_BASE}/vm-image?${params.toString()}`;
                    return fetch(fallbackUrl, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json'
                        }
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    });
                }
                // If KT returns no results, try with ktvpc
                if ((data.total === 0 || !data.items || data.items.length === 0) && csp.toLowerCase() === 'kt') {
                    console.log('KT returned no results, trying ktvpc...');
                    params.set('csp', 'ktvpc');
                    const fallbackUrl = `${MC_INSIGHT_API_BASE}/vm-image?${params.toString()}`;
                    return fetch(fallbackUrl, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json'
                        }
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    });
                }
                return data;
            })
            .then(data => {
                imageTotalCount = data.total || 0;
                displayImages(data.items || []);
                updateImagePagination(data.data_version);
                loadingOverlay.classList.remove('active');
            })
            .catch(error => {
                console.error('Error loading images:', error);
                const errorMsg = error.message || error.toString();
                loadingOverlay.classList.remove('active');
                
                // Check if it's a token configuration error (503 Service Unavailable)
                if (errorMsg.includes('503')) {
                    container.innerHTML = `
                        <div class="no-data-message">
                            <p><strong>MC-Insight API Token Required</strong></p>
                            <p style="font-size: 12px; color: #666; margin-top: 10px;">
                                To search multi-cloud metadata using MC-Insight, you need to configure the MC-Insight API Token.<br>
                                Please set the <code>MC_INSIGHT_API_TOKEN</code> value in <code>./setup.env</code> and restart CB-Spider.
                            </p>
                        </div>
                    `;
                } else {
                    container.innerHTML = `
                        <div class="no-data-message">
                            <p><strong>Error loading images</strong></p>
                            <p style="font-size: 12px; color: #666;">${errorMsg}</p>
                            <button class="select-btn" onclick="applyImageFilters()" style="margin-top: 10px;">Retry</button>
                        </div>
                    `;
                }
            });
        }).catch(error => {
            console.error('Error getting CSP:', error);
            const container = document.getElementById('image-list-container');
            container.innerHTML = `<div class="no-data-message">Error loading connection configuration: ${error.message}</div>`;
        });
    }

    function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
            // Show a brief feedback
            const tooltip = document.createElement('div');
            tooltip.textContent = 'Copied!';
            tooltip.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #495057; color: white; padding: 10px 20px; border-radius: 4px; z-index: 10000; font-size: 14px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);';
            document.body.appendChild(tooltip);
            setTimeout(() => tooltip.remove(), 1000);
        }).catch(err => {
            console.error('Failed to copy:', err);
            alert('Failed to copy to clipboard');
        });
    }

    function displayImages(images) {
        const container = document.getElementById('image-list-container');
        
        if (images.length === 0) {
            container.innerHTML = '<div class="no-data-message">No images found matching the filters.</div>';
            return;
        }

        // Helper function to display value or NA
        const displayValue = (value) => {
            if (value === -1 || value === '-' || value === '-1') return '<span style="color: #999;">NA</span>';
            if (value === null || value === undefined || value === '') return '<span style="color: #999;">NA</span>';
            return value;
        };

        // Helper function to create sortable header
        const createSortableHeader = (label, field) => {
            const isActive = imageSortField === field;
            const arrow = isActive ? (imageSortOrder === 'asc' ? ' ‚ñ≤' : ' ‚ñº') : '';
            return `<th onclick="sortImages('${field}')" style="cursor: pointer; user-select: none;" title="Click to sort">${label}${arrow}</th>`;
        };

        let tableHTML = `
            <table class="selection-table">
                <thead>
                    <tr>
                        <th>#</th>
                        ${createSortableHeader('Name', 'image_id')}
                        ${createSortableHeader('OS Arch', 'os_architecture')}
                        ${createSortableHeader('OS Platform', 'os_platform')}
                        ${createSortableHeader('OS Distribution', 'os_distribution')}
                        ${createSortableHeader('Disk Type', 'os_disk_type')}
                        ${createSortableHeader('Disk Size (GB)', 'os_disk_size_gb')}
                        ${createSortableHeader('Status', 'image_status')}
                    </tr>
                </thead>
                <tbody>
        `;

        images.forEach((image, index) => {
            const rowNumber = currentImagePage * ITEMS_PER_PAGE + index + 1;
            tableHTML += `
                <tr>
                    <td style="color: #6c757d;">${rowNumber}</td>
                    <td style="font-family: monospace;"><a href="javascript:void(0)" onclick='selectImage("${image.image_id}")' title="Click to select this image" style="cursor: pointer; color: #007bff; text-decoration: underline;">${image.image_id}</a></td>
                    <td>${image.os_architecture === 'NA' ? '<span style="color: #999;">NA</span>' : displayValue(image.os_architecture)}</td>
                    <td>${image.os_platform === 'na' ? '<span style="color: #999;">NA</span>' : displayValue(image.os_platform)}</td>
                    <td>${displayValue(image.os_distribution)}</td>
                    <td>${image.os_disk_type === 'NA' ? '<span style="color: #999;">NA</span>' : displayValue(image.os_disk_type)}</td>
                    <td>${image.os_disk_size_gb === 0 ? '0' : (image.os_disk_size_gb > 0 ? image.os_disk_size_gb.toLocaleString() : '<span style="color: #999;">NA</span>')}</td>
                    <td>${displayValue(image.image_status)}</td>
                </tr>
            `;
        });

        tableHTML += '</tbody></table>';
        container.innerHTML = tableHTML;
        
        // Store current image data for selectImage() function
        currentImageData = images;
    }

    function sortImages(field) {
        if (imageSortField === field) {
            // Toggle sort order if clicking the same field
            imageSortOrder = imageSortOrder === 'asc' ? 'desc' : 'asc';
        } else {
            // Set new field and default to ascending
            imageSortField = field;
            imageSortOrder = 'asc';
        }
        // Reset to first page when sorting changes
        currentImagePage = 0;
        loadImages();
    }

    function selectImage(imageId) {
        document.getElementById('imageName').value = imageId;
        
        // Find the selected image data
        const selectedImage = currentImageData.find(img => img.image_id === imageId);
        
        // Update OS information display
        const osInfoDisplay = document.getElementById('osInfoDisplay');
        if (selectedImage && osInfoDisplay) {
            const osArch = (selectedImage.os_architecture && selectedImage.os_architecture !== 'NA' && selectedImage.os_architecture !== '-') ? selectedImage.os_architecture : '-';
            const osPlatform = (selectedImage.os_platform && selectedImage.os_platform !== 'na' && selectedImage.os_platform !== 'NA' && selectedImage.os_platform !== '-') ? selectedImage.os_platform : '-';
            const osDistribution = (selectedImage.os_distribution && selectedImage.os_distribution !== 'NA' && selectedImage.os_distribution !== '-') ? selectedImage.os_distribution : '-';
            
            // Store selected OS Arch globally (only if it has value)
            selectedOSArch = (osArch !== '-') ? osArch : '';
            
            // Clear previous content
            osInfoDisplay.innerHTML = '';
            
            // Always create boxes, even if values are "-"
            const archBox = document.createElement('span');
            archBox.className = 'os-info-box';
            archBox.textContent = osArch;
            archBox.title = osArch;
            osInfoDisplay.appendChild(archBox);
            
            const platformBox = document.createElement('span');
            platformBox.className = 'os-info-box';
            platformBox.textContent = osPlatform;
            platformBox.title = osPlatform;
            osInfoDisplay.appendChild(platformBox);
            
            const distBox = document.createElement('span');
            distBox.className = 'os-info-box';
            distBox.textContent = osDistribution;
            distBox.title = osDistribution;
            osInfoDisplay.appendChild(distBox);
            
            // Show the form group and display
            document.getElementById('osInfoFormGroup').style.display = '';
            osInfoDisplay.classList.add('active');
        }
        
        closeImageSelectionOverlay();
    }

    function loadImagePage(direction) {
        if (direction === 'next' && (currentImagePage + 1) * ITEMS_PER_PAGE < imageTotalCount) {
            currentImagePage++;
            loadImages();
        } else if (direction === 'prev' && currentImagePage > 0) {
            currentImagePage--;
            loadImages();
        }
    }

    function updateImagePagination(dataVersion) {
        const pagination = document.getElementById('image-pagination');
        const pageInfo = document.getElementById('image-page-info');
        const totalInfo = document.getElementById('image-total-info');
        const versionInfo = document.getElementById('image-data-version');
        const prevBtn = document.getElementById('image-prev-btn');
        const nextBtn = document.getElementById('image-next-btn');

        const totalPages = Math.ceil(imageTotalCount / ITEMS_PER_PAGE);
        pageInfo.textContent = `${currentImagePage + 1} / ${totalPages}`;
        totalInfo.textContent = `Total: ${imageTotalCount.toLocaleString()}`;
        
        if (dataVersion) {
            let formattedDate = dataVersion;
            try {
                // Parse format: YYYYMMDD-HHMMSS
                const match = dataVersion.match(/(\d{4})(\d{2})(\d{2})-(\d{2})(\d{2})(\d{2})/);
                if (match) {
                    const year = match[1];
                    const month = parseInt(match[2]) - 1; // 0-based
                    const day = match[3];
                    const hour = match[4];
                    const minute = match[5];
                    const second = match[6];
                    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    formattedDate = `${months[month]} ${parseInt(day)}, ${year}, ${hour}:${minute}:${second}`;
                }
            } catch (e) {
                // If parsing fails, use the raw value
            }
            versionInfo.textContent = ` (data_ver: ${formattedDate})`;
        }

        prevBtn.disabled = currentImagePage === 0;
        nextBtn.disabled = (currentImagePage + 1) * ITEMS_PER_PAGE >= imageTotalCount;

        pagination.style.display = imageTotalCount > 0 ? 'flex' : 'none';
    }

    // ==================== VM SPEC SELECTION FUNCTIONS ====================

    function showSpecSelectionOverlay() {
        // Check if subnet is selected
        const subnetSelect = document.getElementById('subnetSelect');
        
        if (!subnetSelect.value || subnetSelect.value === '') {
            alert('Please select a Subnet first. The Zone will be determined from the selected Subnet.');
            return;
        }
        
        const overlay = document.getElementById('spec-selection-overlay');
        overlay.style.display = 'flex';
        document.addEventListener('keydown', handleSpecSelectionOverlayEsc);
        
        // Set Spec Name filter from Add New VM form if it has a value
        const currentSpecName = document.getElementById('vmSpecName');
        const specFilterName = document.getElementById('spec-filter-name');
        if (currentSpecName && currentSpecName.value && specFilterName) {
            specFilterName.value = currentSpecName.value.trim();
        }
        
        // Display selected OS Arch if available
        const osArchDisplay = document.getElementById('spec-os-arch-display');
        const osArchCheckbox = document.getElementById('spec-os-arch-filter-enabled');
        
        if (selectedOSArch) {
            osArchDisplay.textContent = selectedOSArch;
            if (selectedOSArch.length > 16) {
                osArchDisplay.title = selectedOSArch;
            }
            osArchDisplay.style.display = 'inline-block';
            osArchCheckbox.style.display = 'inline-block';
            osArchCheckbox.checked = true; // Default checked
        } else {
            osArchDisplay.style.display = 'none';
            osArchCheckbox.style.display = 'none';
        }
        
        // Get current connection info and set filters
        getConnectionInfo().then(info => {
            if (!info.zone) {
                alert('Cannot determine Zone from selected Subnet. Please select a valid Subnet.');
                closeSpecSelectionOverlay();
                return;
            }
            
            // For OpenStack and MOCK, skip MC-Insight token check and load filters directly
            if (info.csp.toLowerCase() === 'openstack' || info.csp.toLowerCase() === 'mock') {
                loadSpecFilterOptions(info.csp, info.region, info.zone);
                
                // Add focus event listeners to set placeholder as initial value for number inputs
                const numberInputs = [
                    { id: 'spec-filter-min-vcpu', defaultValue: '2' },
                    { id: 'spec-filter-max-vcpu', defaultValue: '16' },
                    { id: 'spec-filter-min-mem', defaultValue: '4096' },
                    { id: 'spec-filter-max-mem', defaultValue: '65536' },
                    { id: 'spec-filter-min-gpu', defaultValue: '1' },
                    { id: 'spec-filter-max-gpu', defaultValue: '8' },
                    { id: 'spec-filter-min-gpu-mem', defaultValue: '8' },
                    { id: 'spec-filter-max-gpu-mem', defaultValue: '128' }
                ];
                
                numberInputs.forEach(input => {
                    const element = document.getElementById(input.id);
                    if (element) {
                        element.addEventListener('focus', function() {
                            if (this.value === '') {
                                this.value = input.defaultValue;
                            }
                        });
                        
                        // Add custom step behavior for memory inputs (*2, /2)
                        if (input.id.includes('-mem')) {
                            let isTyping = false;
                            let previousValue = null;
                            let isComposing = false;
                            
                            // Block IME (Korean, etc.) input
                            element.addEventListener('compositionstart', function() {
                                isComposing = true;
                            });
                            
                            element.addEventListener('compositionend', function() {
                                isComposing = false;
                                this.value = this.value.replace(/[^0-9]/g, '');
                            });
                            
                            element.addEventListener('focus', function() {
                                previousValue = parseInt(this.value) || parseInt(input.defaultValue);
                            });
                            
                            // Detect direct keyboard number input
                            element.addEventListener('keydown', function(event) {
                                // Block all non-numeric keys except special keys
                                if (isComposing) {
                                    event.preventDefault();
                                    return;
                                }
                                
                                // Arrow keys - apply *2, /2
                                if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                                    event.preventDefault();
                                    const currentValue = parseInt(this.value) || parseInt(input.defaultValue);
                                    if (event.key === 'ArrowUp') {
                                        this.value = currentValue * 2;
                                    } else {
                                        const newValue = Math.floor(currentValue / 2);
                                        this.value = newValue > 0 ? newValue : 1;
                                    }
                                    previousValue = parseInt(this.value);
                                    return;
                                }
                                
                                // Number keys, backspace, delete - mark as typing
                                if ((event.key >= '0' && event.key <= '9') || 
                                    event.key === 'Backspace' || 
                                    event.key === 'Delete') {
                                    isTyping = true;
                                }
                            });
                            
                            // Handle spinner clicks and other value changes
                            element.addEventListener('input', function() {
                                // Block non-numeric characters (including Korean)
                                const cleaned = this.value.replace(/[^0-9]/g, '');
                                if (this.value !== cleaned) {
                                    this.value = cleaned;
                                    previousValue = parseInt(this.value) || 0;
                                    return;
                                }
                                
                                if (isTyping) {
                                    // Direct keyboard input - allow normal behavior
                                    isTyping = false;
                                    previousValue = parseInt(this.value);
                                    return;
                                }
                                
                                // Spinner click or other change - apply *2, /2
                                const currentValue = parseInt(this.value);
                                if (!isNaN(currentValue) && previousValue !== null && currentValue !== previousValue) {
                                    if (currentValue > previousValue) {
                                        this.value = previousValue * 2;
                                    } else if (currentValue < previousValue) {
                                        const newValue = Math.floor(previousValue / 2);
                                        this.value = newValue > 0 ? newValue : 1;
                                    }
                                    previousValue = parseInt(this.value);
                                }
                            });
                            
                            element.addEventListener('wheel', function(event) {
                                event.preventDefault();
                                const currentValue = parseInt(this.value) || parseInt(input.defaultValue);
                                if (event.deltaY < 0) {
                                    this.value = currentValue * 2;
                                } else {
                                    const newValue = Math.floor(currentValue / 2);
                                    this.value = newValue > 0 ? newValue : 1;
                                }
                                previousValue = parseInt(this.value);
                            });
                        } else {
                            // For non-memory inputs, block non-numeric characters
                            let isComposing = false;
                            
                            element.addEventListener('compositionstart', function() {
                                isComposing = true;
                            });
                            
                            element.addEventListener('compositionend', function() {
                                isComposing = false;
                                this.value = this.value.replace(/[^0-9]/g, '');
                            });
                            
                            element.addEventListener('keydown', function(event) {
                                if (isComposing) {
                                    event.preventDefault();
                                    return;
                                }
                            });
                            
                            element.addEventListener('input', function() {
                                this.value = this.value.replace(/[^0-9]/g, '');
                            });
                        }
                    }
                });
                
                // Add validation for max fields to ensure max >= min
                const maxFieldValidations = [
                    { maxId: 'spec-filter-max-vcpu', minId: 'spec-filter-min-vcpu', isMemory: false },
                    { maxId: 'spec-filter-max-mem', minId: 'spec-filter-min-mem', isMemory: true },
                    { maxId: 'spec-filter-max-gpu', minId: 'spec-filter-min-gpu', isMemory: false },
                    { maxId: 'spec-filter-max-gpu-mem', minId: 'spec-filter-min-gpu-mem', isMemory: true }
                ];
                
                maxFieldValidations.forEach(validation => {
                    const maxElement = document.getElementById(validation.maxId);
                    const minElement = document.getElementById(validation.minId);
                    
                    if (maxElement && minElement) {
                        const validateMaxValue = function() {
                            const currentValue = this.value.trim();
                            
                            // Only validate if there's a value entered
                            if (currentValue === '') return;
                            
                            const maxValue = parseInt(currentValue);
                            const minValue = parseInt(minElement.value);
                            
                            // If max < min, set to min value (without alert)
                            if (!isNaN(maxValue) && !isNaN(minValue) && maxValue < minValue) {
                                this.value = minValue;
                            }
                        };
                        
                        // Validate on blur (when user finishes typing and clicks away)
                        maxElement.addEventListener('blur', validateMaxValue);
                        
                        // Validate on wheel (after value changes)
                        maxElement.addEventListener('wheel', function(event) {
                            setTimeout(() => validateMaxValue.call(this), 0);
                        });
                        
                        // For memory inputs, add validation after arrow key handling
                        if (validation.isMemory) {
                            const originalKeydownHandler = maxElement.onkeydown;
                            maxElement.addEventListener('keydown', function(event) {
                                if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                                    setTimeout(() => validateMaxValue.call(this), 0);
                                }
                            });
                        }
                    }
                });
                
                // Add Enter key event listeners to filter inputs
                ['spec-filter-name', 'spec-filter-gpu-model', 'spec-filter-min-vcpu', 'spec-filter-max-vcpu', 'spec-filter-min-mem', 'spec-filter-max-mem', 'spec-filter-min-gpu', 'spec-filter-max-gpu', 'spec-filter-min-gpu-mem', 'spec-filter-max-gpu-mem'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('keypress', function(event) {
                            if (event.key === 'Enter') {
                                event.preventDefault();
                                applySpecFilters();
                            }
                        });
                    }
                });
                return;
            }
            
            // For other CSPs, check if MC-Insight token is configured
            checkMCInsightToken().then(hasToken => {
                if (!hasToken) {
                    showTokenWarning('spec-list-container');
                    document.getElementById('spec-pagination').style.display = 'none';
                    return;
                }
                
                loadSpecFilterOptions(info.csp, info.region, info.zone);
                
                // Add the same event listeners for MC-Insight based CSPs
                const numberInputs = [
                    { id: 'spec-filter-min-vcpu', defaultValue: '2' },
                    { id: 'spec-filter-max-vcpu', defaultValue: '16' },
                    { id: 'spec-filter-min-mem', defaultValue: '4096' },
                    { id: 'spec-filter-max-mem', defaultValue: '65536' },
                    { id: 'spec-filter-min-gpu', defaultValue: '1' },
                    { id: 'spec-filter-max-gpu', defaultValue: '8' },
                    { id: 'spec-filter-min-gpu-mem', defaultValue: '8' },
                    { id: 'spec-filter-max-gpu-mem', defaultValue: '128' }
                ];
                
                numberInputs.forEach(input => {
                    const element = document.getElementById(input.id);
                    if (element) {
                        element.addEventListener('focus', function() {
                            if (this.value === '') {
                                this.value = input.defaultValue;
                            }
                        });
                        
                        // Add custom step behavior for memory inputs (*2, /2)
                        if (input.id.includes('-mem')) {
                            let isTyping = false;
                            let previousValue = null;
                            let isComposing = false;
                            
                            // Block IME (Korean, etc.) input
                            element.addEventListener('compositionstart', function() {
                                isComposing = true;
                            });
                            
                            element.addEventListener('compositionend', function() {
                                isComposing = false;
                                this.value = this.value.replace(/[^0-9]/g, '');
                            });
                            
                            element.addEventListener('focus', function() {
                                previousValue = parseInt(this.value) || parseInt(input.defaultValue);
                            });
                            
                            // Detect direct keyboard number input
                            element.addEventListener('keydown', function(event) {
                                // Block all non-numeric keys except special keys
                                if (isComposing) {
                                    event.preventDefault();
                                    return;
                                }
                                
                                // Arrow keys - apply *2, /2
                                if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                                    event.preventDefault();
                                    const currentValue = parseInt(this.value) || parseInt(input.defaultValue);
                                    if (event.key === 'ArrowUp') {
                                        this.value = currentValue * 2;
                                    } else {
                                        const newValue = Math.floor(currentValue / 2);
                                        this.value = newValue > 0 ? newValue : 1;
                                    }
                                    previousValue = parseInt(this.value);
                                    return;
                                }
                                
                                // Number keys, backspace, delete - mark as typing
                                if ((event.key >= '0' && event.key <= '9') || 
                                    event.key === 'Backspace' || 
                                    event.key === 'Delete') {
                                    isTyping = true;
                                }
                            });
                            
                            // Handle spinner clicks and other value changes
                            element.addEventListener('input', function() {
                                // Block non-numeric characters (including Korean)
                                const cleaned = this.value.replace(/[^0-9]/g, '');
                                if (this.value !== cleaned) {
                                    this.value = cleaned;
                                    previousValue = parseInt(this.value) || 0;
                                    return;
                                }
                                
                                if (isTyping) {
                                    // Direct keyboard input - allow normal behavior
                                    isTyping = false;
                                    previousValue = parseInt(this.value);
                                    return;
                                }
                                
                                // Spinner click or other change - apply *2, /2
                                const currentValue = parseInt(this.value);
                                if (!isNaN(currentValue) && previousValue !== null && currentValue !== previousValue) {
                                    if (currentValue > previousValue) {
                                        this.value = previousValue * 2;
                                    } else {
                                        const newValue = Math.floor(previousValue / 2);
                                        this.value = newValue > 0 ? newValue : 1;
                                    }
                                    previousValue = parseInt(this.value);
                                }
                            });
                        } else {
                            // For non-memory inputs (vCPU, GPU count)
                            element.addEventListener('compositionstart', function() {
                                isComposing = true;
                            });
                            
                            element.addEventListener('compositionend', function() {
                                isComposing = false;
                                this.value = this.value.replace(/[^0-9]/g, '');
                            });
                            
                            element.addEventListener('keydown', function(event) {
                                if (isComposing) {
                                    event.preventDefault();
                                    return;
                                }
                            });
                            
                            element.addEventListener('input', function() {
                                this.value = this.value.replace(/[^0-9]/g, '');
                            });
                        }
                    }
                });
                
                // Add validation for max fields to ensure max >= min
                const maxFieldValidations = [
                    { maxId: 'spec-filter-max-vcpu', minId: 'spec-filter-min-vcpu', isMemory: false },
                    { maxId: 'spec-filter-max-mem', minId: 'spec-filter-min-mem', isMemory: true },
                    { maxId: 'spec-filter-max-gpu', minId: 'spec-filter-min-gpu', isMemory: false },
                    { maxId: 'spec-filter-max-gpu-mem', minId: 'spec-filter-min-gpu-mem', isMemory: true }
                ];
                
                maxFieldValidations.forEach(validation => {
                    const maxElement = document.getElementById(validation.maxId);
                    const minElement = document.getElementById(validation.minId);
                    
                    if (maxElement && minElement) {
                        const validateMaxValue = function() {
                            const maxValue = parseInt(this.value) || 0;
                            const minValue = parseInt(minElement.value) || 0;
                            
                            if (maxValue > 0 && minValue > 0 && maxValue < minValue) {
                                this.value = minValue;
                            }
                        };
                        
                        maxElement.addEventListener('blur', validateMaxValue);
                        maxElement.addEventListener('change', validateMaxValue);
                    }
                });
                
                // Add Enter key event listeners to filter inputs
                ['spec-filter-name', 'spec-filter-gpu-model', 'spec-filter-min-vcpu', 'spec-filter-max-vcpu', 'spec-filter-min-mem', 'spec-filter-max-mem', 'spec-filter-min-gpu', 'spec-filter-max-gpu', 'spec-filter-min-gpu-mem', 'spec-filter-max-gpu-mem'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('keypress', function(event) {
                            if (event.key === 'Enter') {
                                event.preventDefault();
                                applySpecFilters();
                            }
                        });
                    }
                });
            });
        }).catch(error => {
            console.error('Error loading connection info:', error);
            alert('Failed to load connection information');
            closeSpecSelectionOverlay();
        });
    }

    function closeSpecSelectionOverlay() {
        const overlay = document.getElementById('spec-selection-overlay');
        overlay.style.display = 'none';
        document.removeEventListener('keydown', handleSpecSelectionOverlayEsc);
    }

    function showPriceInfoOverlay() {
        document.removeEventListener('keydown', handlePriceInfoOverlayEsc); // Prevent duplicate handlers
        document.getElementById('price-info-overlay').style.display = 'flex';
        document.addEventListener('keydown', handlePriceInfoOverlayEsc);
    }

    function closePriceInfoOverlay() {
        document.getElementById('price-info-overlay').style.display = 'none';
        document.removeEventListener('keydown', handlePriceInfoOverlayEsc);
    }

    function handlePriceInfoOverlayEsc(event) {
        if (event.key === 'Escape') {
            const priceOverlay = document.getElementById('price-info-overlay');
            
            // If price info overlay is visible, close it immediately
            if (priceOverlay.style.display === 'flex') {
                event.stopImmediatePropagation();
                closePriceInfoOverlay();
            }
        }
    }

    function handleSpecSelectionOverlayEsc(event) {
        if (event.key === 'Escape') {
            const priceOverlay = document.getElementById('price-info-overlay');
            // Don't close if Price Info overlay is open (it should close first)
            if (priceOverlay && priceOverlay.style.display === 'flex') {
                return;
            }
            event.stopImmediatePropagation();
            closeSpecSelectionOverlay();
        }
    }

    function loadSpecFilterOptions(csp, currentRegion, currentZone) {
        // ==================== OPENSTACK & MOCK: SIMPLE REGION/ZONE SETUP ====================
        if (csp.toLowerCase() === 'openstack' || csp.toLowerCase() === 'mock') {
            const regionSelect = document.getElementById('spec-filter-region');
            const zoneSelect = document.getElementById('spec-filter-zone');
            
            // Set region and zone from connection (locked)
            regionSelect.innerHTML = `<option value="${currentRegion}">${currentRegion}</option>`;
            regionSelect.disabled = true;
            regionSelect.style.backgroundColor = '#f0f0f0';
            
            zoneSelect.innerHTML = `<option value="${currentZone}">${currentZone}</option>`;
            zoneSelect.disabled = true;
            zoneSelect.style.backgroundColor = '#f0f0f0';
            
            // Set filters with locked region/zone
            specFilters = {
                region: currentRegion,
                zone: currentZone
            };
            
            // Set initial message - data loads when Search is clicked
            document.getElementById('spec-list-container').innerHTML = '<div class="loading-message">Press Search to load VM specs</div>';
            document.getElementById('spec-pagination').style.display = 'none';
            return;
        }
        
        // ==================== NON-OPENSTACK: USE MC-INSIGHT FILTER API ====================
        // Show MC-Insight badge for non-OpenStack CSPs
        const badge = document.getElementById('spec-mcinsight-badge');
        if (badge) badge.style.display = '';
        
        fetch(`/spider/mcinsight/vm-spec/filters`)
        .then(response => response.json())
        .then(data => {
            
            const regionSelect = document.getElementById('spec-filter-region');
            const zoneSelect = document.getElementById('spec-filter-zone');
            
            regionSelect.innerHTML = '';
            zoneSelect.innerHTML = '';
            
            // Try NCP first, fallback to NCPVPC if not found
            let actualCsp = csp;
            if (csp.toLowerCase() === 'ncp' && (!data.cloud_hierarchy || !data.cloud_hierarchy[csp])) {
                actualCsp = 'ncpvpc';
                console.log('NCP not found in filters, using NCPVPC');
            }
            // Try NHN first, fallback to nhncloud if not found
            if (csp.toLowerCase() === 'nhn' && (!data.cloud_hierarchy || !data.cloud_hierarchy[csp])) {
                actualCsp = 'nhncloud';
                console.log('NHN not found in filters, using nhncloud');
            }
            // Try KT first, fallback to ktvpc if not found
            if (csp.toLowerCase() === 'kt' && (!data.cloud_hierarchy || !data.cloud_hierarchy[csp])) {
                actualCsp = 'ktvpc';
                console.log('KT not found in filters, using ktvpc');
            }
            
            // Populate Region/Zone (cloud_hierarchy)
            if (data.cloud_hierarchy && data.cloud_hierarchy[actualCsp]) {
                const regions = Object.keys(data.cloud_hierarchy[actualCsp]);
                
                regions.forEach(region => {
                    const option = document.createElement('option');
                    option.value = region;
                    option.textContent = region;
                    if (region === currentRegion) {
                        option.selected = true;
                    }
                    regionSelect.appendChild(option);
                });
                
                regionSelect.disabled = true;
                regionSelect.style.backgroundColor = '#f0f0f0';
                
                const zones = data.cloud_hierarchy[actualCsp][currentRegion];
                
                if (zones && zones.length > 0) {
                    zones.forEach(zone => {
                        const option = document.createElement('option');
                        option.value = zone;
                        option.textContent = zone;
                        if (zone === currentZone) {
                            option.selected = true;
                        }
                        zoneSelect.appendChild(option);
                    });
                    
                    zoneSelect.disabled = true;
                    zoneSelect.style.backgroundColor = '#f0f0f0';
                }
            }
            
        })
        .catch(error => {
            console.error('Error loading spec filters:', error);
            alert('Failed to load spec filters');
        });
    }

    function loadSpecZones(csp, zones) {
        // This function is no longer needed as zones are loaded and locked in loadSpecFilterOptions
    }

    function applySpecFilters() {
        currentSpecPage = 0;
        specFilters = {
            name: document.getElementById('spec-filter-name').value.trim(),
            region: document.getElementById('spec-filter-region').value,
            zone: document.getElementById('spec-filter-zone').value,
            gpu_model: document.getElementById('spec-filter-gpu-model').value.trim(),
            min_vcpu_count: document.getElementById('spec-filter-min-vcpu').value,
            max_vcpu_count: document.getElementById('spec-filter-max-vcpu').value,
            min_mem_size_mib: document.getElementById('spec-filter-min-mem').value,
            max_mem_size_mib: document.getElementById('spec-filter-max-mem').value,
            min_gpu_count: document.getElementById('spec-filter-min-gpu').value,
            max_gpu_count: document.getElementById('spec-filter-max-gpu').value,
            min_gpu_mem_size_gb: document.getElementById('spec-filter-min-gpu-mem').value,
            max_gpu_mem_size_gb: document.getElementById('spec-filter-max-gpu-mem').value
        };
        
        // Add OS Arch filter if checkbox is enabled
        const osArchCheckbox = document.getElementById('spec-os-arch-filter-enabled');
        const osArchDisplay = document.getElementById('spec-os-arch-display');
        if (osArchCheckbox && osArchCheckbox.checked && osArchDisplay) {
            specFilters.os_arch = osArchDisplay.textContent.trim();
        }
        
        loadSpecs();
    }

    function clearFilter(filterType) {
        switch(filterType) {
            case 'vcpu':
                document.getElementById('spec-filter-min-vcpu').value = '';
                document.getElementById('spec-filter-max-vcpu').value = '';
                break;
            case 'mem':
                document.getElementById('spec-filter-min-mem').value = '';
                document.getElementById('spec-filter-max-mem').value = '';
                break;
            case 'gpu':
                document.getElementById('spec-filter-min-gpu').value = '';
                document.getElementById('spec-filter-max-gpu').value = '';
                break;
            case 'gpu-mem':
                document.getElementById('spec-filter-min-gpu-mem').value = '';
                document.getElementById('spec-filter-max-gpu-mem').value = '';
                break;
            case 'gpu-model':
                document.getElementById('spec-filter-gpu-model').value = '';
                break;
            case 'spec-name':
                document.getElementById('spec-filter-name').value = '';
                break;
            case 'image-name':
                document.getElementById('image-filter-name').value = '';
                break;
            case 'image-distribution':
                document.getElementById('image-filter-distribution').value = '';
                break;
        }
    }

    // Apply workload preset filters
    function applyIntensivePreset(type) {
        // Clear filter input fields only (don't reset table)
        document.getElementById('spec-filter-name').value = '';
        document.getElementById('spec-filter-gpu-model').value = '';
        document.getElementById('spec-filter-min-vcpu').value = '';
        document.getElementById('spec-filter-max-vcpu').value = '';
        document.getElementById('spec-filter-min-mem').value = '';
        document.getElementById('spec-filter-max-mem').value = '';
        document.getElementById('spec-filter-min-gpu').value = '';
        document.getElementById('spec-filter-max-gpu').value = '';
        document.getElementById('spec-filter-min-gpu-mem').value = '';
        document.getElementById('spec-filter-max-gpu-mem').value = '';
        
        switch(type) {
            case 'general':
                // General Purpose: vCPU 2-4, Memory 4-8 GiB
                document.getElementById('spec-filter-min-vcpu').value = '2';
                document.getElementById('spec-filter-max-vcpu').value = '4';
                document.getElementById('spec-filter-min-mem').value = '4096';  // 4 GiB
                document.getElementById('spec-filter-max-mem').value = '8192';  // 8 GiB
                break;
            
            case 'dev':
                // Small/Dev: vCPU 1-2, Memory 1-4 GiB
                document.getElementById('spec-filter-min-vcpu').value = '1';
                document.getElementById('spec-filter-max-vcpu').value = '2';
                document.getElementById('spec-filter-min-mem').value = '1024';  // 1 GiB
                document.getElementById('spec-filter-max-mem').value = '4096';  // 4 GiB
                break;
            
            case 'high-performance':
                // High Performance: vCPU ‚â•16, Memory ‚â•64 GiB
                document.getElementById('spec-filter-min-vcpu').value = '16';
                document.getElementById('spec-filter-min-mem').value = '65536';  // 64 GiB
                break;
            
            case 'database':
                // Database: vCPU 4-8, Memory ‚â•16 GiB
                document.getElementById('spec-filter-min-vcpu').value = '4';
                document.getElementById('spec-filter-max-vcpu').value = '8';
                document.getElementById('spec-filter-min-mem').value = '16384';  // 16 GiB
                break;
            
            case 'ai-ml':
                // AI/ML Training: vCPU ‚â•8, Memory ‚â•32 GiB, GPU ‚â•2, GPU Mem ‚â•16 GB
                document.getElementById('spec-filter-min-vcpu').value = '8';
                document.getElementById('spec-filter-min-mem').value = '32768';  // 32 GiB
                document.getElementById('spec-filter-min-gpu').value = '2';
                document.getElementById('spec-filter-min-gpu-mem').value = '16';  // 16 GB
                break;
        }
    }

    function resetSpecFilters() {
        // Region and Zone are locked, so we don't reset them
        document.getElementById('spec-filter-name').value = '';
        document.getElementById('spec-filter-gpu-model').value = '';
        document.getElementById('spec-filter-min-vcpu').value = '';
        document.getElementById('spec-filter-max-vcpu').value = '';
        document.getElementById('spec-filter-min-mem').value = '';
        document.getElementById('spec-filter-max-mem').value = '';
        document.getElementById('spec-filter-min-gpu').value = '';
        document.getElementById('spec-filter-max-gpu').value = '';
        document.getElementById('spec-filter-min-gpu-mem').value = '';
        document.getElementById('spec-filter-max-gpu-mem').value = '';
        
        // Keep region and zone filters but reset others
        specFilters = {
            region: document.getElementById('spec-filter-region').value,
            zone: document.getElementById('spec-filter-zone').value
        };
        currentSpecPage = 0;
        specSortField = 'name';
        specSortOrder = 'asc';
        document.getElementById('spec-list-container').innerHTML = '<div class="loading-message">Press Search to load VM specs</div>';
        document.getElementById('spec-pagination').style.display = 'none';
    }

    // Convert Spider Arch type to CSP-specific key_value_json search values
    function convertArchToCSPValues(spiderArch, csp) {
        const cspLower = csp.toLowerCase();
        
        // Return array of search values (for multiple mappings)
        switch(spiderArch) {
            case 'arm64':
                if (cspLower === 'aws') return ['arm64'];
                if (cspLower === 'alibaba') return ['ARM'];
                if (cspLower === 'tencent') return ['Ampere Altra'];
                break;
            
            case 'arm64_mac':
                if (cspLower === 'aws') return ['arm64_mac'];
                break;
            
            case 'x86_32':
                if (cspLower === 'aws') return ['i386'];
                if (cspLower === 'alibaba') return ['X86'];
                break;
            
            case 'x86_64':
                if (cspLower === 'aws') return ['x86_64', 'i386'];
                if (cspLower === 'alibaba') return ['X86'];
                if (cspLower === 'tencent') return ['AMD', 'Intel'];
                if (cspLower === 'ibm') return ['amd64'];
                if (cspLower === 'ncp' || cspLower === 'ncpvpc') return ['X86_64'];
                break;
            
            case 'x86_64_mac':
                if (cspLower === 'aws') return ['x86_64_mac'];
                break;
            
            // Handle combined display like "x86_32, x86_64"
            case 'x86_32, x86_64':
                if (cspLower === 'aws') return ['i386'];
                if (cspLower === 'alibaba') return ['X86'];
                break;
        }
        
        return [];
    }

    function loadSpecs() {
        getCSPFromConnection().then(csp => {
            // ==================== OPENSTACK & MOCK: USE SPIDER API ====================
            if (csp.toLowerCase() === 'openstack' || csp.toLowerCase() === 'mock') {
                // Hide MC-Insight badge for OpenStack and MOCK
                const badge = document.getElementById('spec-mcinsight-badge');
                if (badge) badge.style.display = 'none';
                
                const container = document.getElementById('spec-list-container');
                let loadingOverlay = container.querySelector('.table-loading-overlay');
                if (!loadingOverlay) {
                    loadingOverlay = document.createElement('div');
                    loadingOverlay.className = 'table-loading-overlay';
                    loadingOverlay.textContent = 'Loading specs...';
                    container.appendChild(loadingOverlay);
                }
                loadingOverlay.classList.add('active');
                
                // Get current connection name
                const connectionName = document.getElementById('connConfig').value;
                
                // Load specs from Spider API (only once, then cache)
                if (openstackAllSpecs.length === 0) {
                    loadSpecsFromSpider(connectionName)
                        .then(specs => {
                            openstackAllSpecs = specs;
                            
                            // Apply filters and sorting
                            let filteredSpecs = filterOpenStackSpecs(openstackAllSpecs, specFilters);
                            filteredSpecs = sortOpenStackData(filteredSpecs, specSortField, specSortOrder);
                            
                            // Update total count
                            specTotalCount = filteredSpecs.length;
                            
                            // Paginate
                            const startIdx = currentSpecPage * ITEMS_PER_PAGE;
                            const endIdx = startIdx + ITEMS_PER_PAGE;
                            const pageSpecs = filteredSpecs.slice(startIdx, endIdx);
                            
                            displaySpecs(pageSpecs);
                            updateSpecPagination('Spider-OpenStack');
                            loadingOverlay.classList.remove('active');
                        })
                        .catch(error => {
                            console.error('Error loading OpenStack specs:', error);
                            loadingOverlay.classList.remove('active');
                            container.innerHTML = `
                                <div class="no-data-message">
                                    <p><strong>Error loading OpenStack specs</strong></p>
                                    <p style="font-size: 12px; color: #666;">${error.message}</p>
                                    <button class="select-btn" onclick="openstackAllSpecs = []; loadSpecs();" style="margin-top: 10px;">Retry</button>
                                </div>
                            `;
                        });
                } else {
                    // Use cached data
                    let filteredSpecs = filterOpenStackSpecs(openstackAllSpecs, specFilters);
                    filteredSpecs = sortOpenStackData(filteredSpecs, specSortField, specSortOrder);
                    
                    specTotalCount = filteredSpecs.length;
                    const startIdx = currentSpecPage * ITEMS_PER_PAGE;
                    const endIdx = startIdx + ITEMS_PER_PAGE;
                    const pageSpecs = filteredSpecs.slice(startIdx, endIdx);
                    
                    displaySpecs(pageSpecs);
                    updateSpecPagination('Spider-OpenStack');
                    loadingOverlay.classList.remove('active');
                }
                return;
            }
            
            // ==================== NON-OPENSTACK: USE MC-INSIGHT API ====================
            // Show MC-Insight badge for non-OpenStack CSPs
            const badge = document.getElementById('spec-mcinsight-badge');
            if (badge) badge.style.display = '';
            
            // Check if OS Arch filter is enabled
            const osArchValues = specFilters.os_arch ? convertArchToCSPValues(specFilters.os_arch, csp) : [];
            
            // If OS Arch filter exists and has multiple values, need multiple API calls
            if (osArchValues.length > 0) {
                loadSpecsWithArchFilter(csp, osArchValues);
            } else {
                loadSpecsWithoutArchFilter(csp);
            }
        }).catch(error => {
            console.error('Error getting CSP:', error);
            const container = document.getElementById('spec-list-container');
            container.innerHTML = `<div class=\"no-data-message\">Connection ConfigÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${error.message}</div>`;
        });
    }

    // Load specs without OS Arch filter (original logic)
    function loadSpecsWithoutArchFilter(csp) {
            
            // If sorting by price, fetch all data for client-side sorting
            const isPriceSorting = specSortField === 'price_per_hour';
            
            const params = new URLSearchParams({
                csp: csp,
                skip: isPriceSorting ? 0 : currentSpecPage * ITEMS_PER_PAGE,
                limit: isPriceSorting ? 10000 : ITEMS_PER_PAGE
            });

            // Add filters if they exist
            Object.keys(specFilters).forEach(key => {
                if (specFilters[key]) {
                    params.append(key, specFilters[key]);
                }
            });

            // Add sort parameter if set (except for price_per_hour which is client-side sorted)
            if (specSortField && specSortField !== 'price_per_hour') {
                const sortParam = specSortOrder === 'desc' ? `-${specSortField}` : specSortField;
                params.append('sort', sortParam);
            }

            const container = document.getElementById('spec-list-container');
            
            // Show loading overlay instead of replacing content
            let loadingOverlay = container.querySelector('.table-loading-overlay');
            if (!loadingOverlay) {
                loadingOverlay = document.createElement('div');
                loadingOverlay.className = 'table-loading-overlay';
                loadingOverlay.textContent = 'Loading specs and prices...';
                container.appendChild(loadingOverlay);
            }
            loadingOverlay.classList.add('active');

            const apiUrl = `${MC_INSIGHT_API_BASE}/vm-spec?${params.toString()}`;

            // Fetch specs first
            fetch(apiUrl, {
                method: 'GET',
                headers: {
                    'accept': 'application/json'
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(specData => {
                // If NCP returns no results, try with NCPVPC
                if ((specData.total === 0 || !specData.items || specData.items.length === 0) && csp.toLowerCase() === 'ncp') {
                    console.log('NCP returned no results, trying NCPVPC...');
                    params.set('csp', 'ncpvpc');
                    const fallbackUrl = `${MC_INSIGHT_API_BASE}/vm-spec?${params.toString()}`;
                    return fetch(fallbackUrl, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json'
                        }
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(fallbackData => {
                        return { ...fallbackData, usedFallback: true, fallbackCsp: 'ncpvpc' };
                    });
                }
                // If NHN returns no results, try with nhncloud
                if ((specData.total === 0 || !specData.items || specData.items.length === 0) && csp.toLowerCase() === 'nhn') {
                    console.log('NHN returned no results, trying nhncloud...');
                    params.set('csp', 'nhncloud');
                    const fallbackUrl = `${MC_INSIGHT_API_BASE}/vm-spec?${params.toString()}`;
                    return fetch(fallbackUrl, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json'
                        }
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(fallbackData => {
                        return { ...fallbackData, usedFallback: true, fallbackCsp: 'nhncloud' };
                    });
                }
                // If KT returns no results, try with ktvpc
                if ((specData.total === 0 || !specData.items || specData.items.length === 0) && csp.toLowerCase() === 'kt') {
                    console.log('KT returned no results, trying ktvpc...');
                    params.set('csp', 'ktvpc');
                    const fallbackUrl = `${MC_INSIGHT_API_BASE}/vm-spec?${params.toString()}`;
                    return fetch(fallbackUrl, {
                        method: 'GET',
                        headers: {
                            'accept': 'application/json'
                        }
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(fallbackData => {
                        return { ...fallbackData, usedFallback: true, fallbackCsp: 'ktvpc' };
                    });
                }
                return specData;
            })
            .then(specData => {
                specTotalCount = specData.total || 0;
                const specs = specData.items || [];
                const actualCsp = specData.usedFallback ? specData.fallbackCsp : csp;
                
                // Build price API parameters based on filters
                const priceParams = new URLSearchParams({
                    csp: actualCsp,
                    skip: 0,
                    limit: 10000  // Get all prices to match with specs
                });
                
                // Add region/zone filters if they exist
                if (specFilters.region) priceParams.append('region', specFilters.region);
                if (specFilters.zone) priceParams.append('zone', specFilters.zone);
                
                const priceApiUrl = `${MC_INSIGHT_API_BASE}/price-info?${priceParams.toString()}`;
                
                // Fetch price data
                return fetch(priceApiUrl, {
                    method: 'GET',
                    headers: {
                        'accept': 'application/json'
                    }
                })
                .then(priceResponse => {
                    if (!priceResponse.ok) {
                        console.warn('Failed to fetch price info, displaying specs without prices');
                        return { specs: specs, prices: [] };
                    }
                    return priceResponse.json();
                })
                .then(priceData => {
                    return { 
                        specs: specs, 
                        prices: priceData.items || [],
                        dataVersion: specData.data_version
                    };
                })
                .catch(priceError => {
                    console.warn('Error fetching prices:', priceError);
                    return { 
                        specs: specs, 
                        prices: [],
                        dataVersion: specData.data_version
                    };
                });
            })
            .then(combinedData => {
                // Merge specs with price data
                let specsWithPrices = mergeSpecsWithPrices(combinedData.specs, combinedData.prices);
                
                // If sorting by price, do client-side sorting and pagination
                if (specSortField === 'price_per_hour') {
                    specsWithPrices.sort((a, b) => {
                        const priceA = a.price_per_hour !== null && a.price_per_hour !== undefined ? parseFloat(a.price_per_hour) : Infinity;
                        const priceB = b.price_per_hour !== null && b.price_per_hour !== undefined ? parseFloat(b.price_per_hour) : Infinity;
                        
                        if (specSortOrder === 'asc') {
                            return priceA - priceB;
                        } else {
                            return priceB - priceA;
                        }
                    });
                    
                    // Apply pagination to sorted data
                    const start = currentSpecPage * ITEMS_PER_PAGE;
                    const end = start + ITEMS_PER_PAGE;
                    specsWithPrices = specsWithPrices.slice(start, end);
                }
                
                displaySpecs(specsWithPrices);
                updateSpecPagination(combinedData.dataVersion);
                loadingOverlay.classList.remove('active');
            })
            .catch(error => {
                console.error('Error loading specs:', error);
                const errorMsg = error.message || error.toString();
                loadingOverlay.classList.remove('active');
                
                // Check if it's a token configuration error (503 Service Unavailable)
                if (errorMsg.includes('503')) {
                    container.innerHTML = `
                        <div class="no-data-message">
                            <p><strong>MC-Insight API Token Required</strong></p>
                            <p style="font-size: 12px; color: #666; margin-top: 10px;">
                                To search multi-cloud metadata using MC-Insight, you need to configure the MC-Insight API Token.<br>
                                Please set the <code>MC_INSIGHT_API_TOKEN</code> value in <code>./setup.env</code> and restart CB-Spider.
                            </p>
                        </div>
                    `;
                } else {
                    container.innerHTML = `
                        <div class="no-data-message">
                            <p><strong>Error loading VM specs</strong></p>
                            <p style="font-size: 12px; color: #666;">${errorMsg}</p>
                            <button class="select-btn" onclick="applySpecFilters()" style="margin-top: 10px;">Retry</button>
                        </div>
                    `;
                }
            });
    }

    // Load specs with OS Arch filter (multiple API calls for multiple arch values)
    async function loadSpecsWithArchFilter(csp, archValues) {
        const container = document.getElementById('spec-list-container');
        
        // Show loading overlay
        let loadingOverlay = container.querySelector('.table-loading-overlay');
        if (!loadingOverlay) {
            loadingOverlay = document.createElement('div');
            loadingOverlay.className = 'table-loading-overlay';
            loadingOverlay.textContent = `Loading specs for ${archValues.length} architecture value(s)...`;
            container.appendChild(loadingOverlay);
        }
        loadingOverlay.classList.add('active');

        try {
            // Create filters object without os_arch
            const baseFilters = { ...specFilters };
            delete baseFilters.os_arch;

            // Fetch specs for each arch value
            const fetchPromises = archValues.map(async (archValue) => {
                const params = new URLSearchParams({
                    csp: csp,
                    skip: 0,
                    limit: 10000  // Fetch all for merging
                });

                // Add base filters
                Object.keys(baseFilters).forEach(key => {
                    if (baseFilters[key]) {
                        params.append(key, baseFilters[key]);
                    }
                });

                // Add search_text filter for this arch value
                params.append('search_text', archValue);

                const apiUrl = `${MC_INSIGHT_API_BASE}/vm-spec?${params.toString()}`;

                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: { 'accept': 'application/json' }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                return await response.json();
            });

            // Wait for all API calls to complete
            const results = await Promise.all(fetchPromises);

            // Merge all results and remove duplicates by spec name
            const allSpecs = [];
            const seenNames = new Set();
            let dataVersion = null;

            results.forEach(result => {
                if (result.items && result.items.length > 0) {
                    // Extract data_ver from first result
                    if (!dataVersion && result.data_ver) {
                        dataVersion = result.data_ver;
                    }
                    result.items.forEach(spec => {
                        if (!seenNames.has(spec.name)) {
                            seenNames.add(spec.name);
                            allSpecs.push(spec);
                        }
                    });
                }
            });

            // Update total count
            specTotalCount = allSpecs.length;

            // Apply sorting
            if (specSortField && specSortField !== 'price_per_hour') {
                allSpecs.sort((a, b) => {
                    let valA = a[specSortField];
                    let valB = b[specSortField];
                    
                    // Handle null/undefined
                    if (valA === null || valA === undefined || valA === -1) valA = specSortOrder === 'asc' ? Infinity : -Infinity;
                    if (valB === null || valB === undefined || valB === -1) valB = specSortOrder === 'asc' ? Infinity : -Infinity;
                    
                    if (typeof valA === 'string') {
                        return specSortOrder === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                    } else {
                        return specSortOrder === 'asc' ? valA - valB : valB - valA;
                    }
                });
            }

            // Fetch prices for all specs
            const priceParams = new URLSearchParams({
                csp: csp,
                skip: 0,
                limit: 10000
            });

            if (specFilters.region) priceParams.append('region', specFilters.region);
            if (specFilters.zone) priceParams.append('zone', specFilters.zone);

            const priceApiUrl = `${MC_INSIGHT_API_BASE}/price-info?${priceParams.toString()}`;

            fetch(priceApiUrl, {
                method: 'GET',
                headers: { 'accept': 'application/json' }
            })
            .then(priceResponse => priceResponse.ok ? priceResponse.json() : { items: [] })
            .then(priceData => {
                // Merge specs with prices
                let specsWithPrices = mergeSpecsWithPrices(allSpecs, priceData.items || []);

                // Apply price sorting if needed
                if (specSortField === 'price_per_hour') {
                    specsWithPrices.sort((a, b) => {
                        const priceA = a.price_per_hour !== null && a.price_per_hour !== undefined ? parseFloat(a.price_per_hour) : Infinity;
                        const priceB = b.price_per_hour !== null && b.price_per_hour !== undefined ? parseFloat(b.price_per_hour) : Infinity;
                        return specSortOrder === 'asc' ? priceA - priceB : priceB - priceA;
                    });
                }

                // Apply pagination
                const start = currentSpecPage * ITEMS_PER_PAGE;
                const end = start + ITEMS_PER_PAGE;
                const pageSpecs = specsWithPrices.slice(start, end);

                displaySpecs(pageSpecs);
                updateSpecPagination(dataVersion);
                loadingOverlay.classList.remove('active');
            })
            .catch(priceError => {
                console.warn('Error fetching prices:', priceError);
                
                // Display specs without prices
                const start = currentSpecPage * ITEMS_PER_PAGE;
                const end = start + ITEMS_PER_PAGE;
                const pageSpecs = allSpecs.slice(start, end);

                displaySpecs(pageSpecs);
                updateSpecPagination(dataVersion);
                loadingOverlay.classList.remove('active');
            });

        } catch (error) {
            console.error('Error loading specs with arch filter:', error);
            loadingOverlay.classList.remove('active');
            
            const errorMsg = error.message || error.toString();
            if (errorMsg.includes('503')) {
                container.innerHTML = `
                    <div class="no-data-message">
                        <p><strong>MC-Insight API Token Required</strong></p>
                        <p style="font-size: 12px; color: #666; margin-top: 10px;">
                            To search multi-cloud metadata using MC-Insight, you need to configure the MC-Insight API Token.<br>
                            Please set the <code>MC_INSIGHT_API_TOKEN</code> value in <code>./setup.env</code> and restart CB-Spider.
                        </p>
                    </div>
                `;
            } else {
                container.innerHTML = `
                    <div class="no-data-message">
                        <p><strong>Error loading VM specs</strong></p>
                        <p style="font-size: 12px; color: #666;">${errorMsg}</p>
                        <button class="select-btn" onclick="applySpecFilters()" style="margin-top: 10px;">Retry</button>
                    </div>
                `;
            }
        }
    }

    function mergeSpecsWithPrices(specs, prices) {
        // Create a map of name -> price info for quick lookup
        const priceMap = {};
        prices.forEach(price => {
            const key = price.name;
            if (!priceMap[key] || (priceMap[key].price > price.price)) {
                // Keep the lowest price (typically on-demand Linux)
                priceMap[key] = price;
            }
        });
        
        // Merge price info with specs
        return specs.map(spec => {
            const priceInfo = priceMap[spec.name];
            return {
                ...spec,
                price_per_hour: priceInfo ? priceInfo.price : null,
                price_currency: priceInfo ? priceInfo.currency : null,
                price_description: priceInfo ? priceInfo.price_description : null,
                unit: priceInfo ? priceInfo.unit : null
            };
        });
    }

    // Extract OS Architecture from key_value_json and map to Spider Arch type
    function extractOSArch(spec) {
        const csp = spec.csp ? spec.csp.toLowerCase() : '';
        
        if (!spec.key_value_json) {
            return 'NA';
        }
        
        try {
            const keyValueData = JSON.parse(spec.key_value_json);
            
            // AWS: Extract from ProcessorInfo -> SupportedArchitectures
            if (csp === 'aws') {
                const processorInfo = keyValueData.ProcessorInfo;
                if (processorInfo) {
                    // ProcessorInfo can be a string like "{SupportedArchitectures:[x86_64],...}"
                    if (typeof processorInfo === 'string') {
                        const match = processorInfo.match(/SupportedArchitectures:\[([^\]]+)\]/);
                        if (match) {
                            const archList = match[1].split(',').map(a => a.trim());
                            
                            // Check for [i386,x86_64] combination (supports both x86_32 and x86_64)
                            if (archList.includes('i386') && archList.includes('x86_64')) {
                                return 'x86_32, x86_64';
                            }
                            
                            // Single architecture mappings
                            const arch = archList[0];
                            if (arch === 'arm64') return 'arm64';
                            if (arch === 'arm64_mac') return 'arm64_mac';
                            if (arch === 'x86_64') return 'x86_64';
                            if (arch === 'x86_64_mac') return 'x86_64_mac';
                        }
                    }
                }
            }
            
            // Alibaba: Extract from InstanceTypeFamily or CpuArchitecture
            else if (csp === 'alibaba') {
                const cpuArch = keyValueData.CpuArchitecture || keyValueData.cpu_architecture;
                if (cpuArch) {
                    const archStr = cpuArch.toString().toLowerCase();
                    if (archStr.includes('arm')) return 'arm64';
                    if (archStr.includes('x86')) return 'x86_64';
                }
            }
            
            // Tencent: Extract from InstanceFamily or CPU info
            else if (csp === 'tencent') {
                const cpuType = keyValueData.CPU || keyValueData.InstanceFamily;
                if (cpuType) {
                    const cpuStr = cpuType.toString().toLowerCase();
                    if (cpuStr.includes('ampere') || cpuStr.includes('altra')) return 'arm64';
                    if (cpuStr.includes('amd') || cpuStr.includes('intel')) return 'x86_64';
                }
            }
            
            // IBM: Extract from Architecture
            else if (csp === 'ibm') {
                const arch = keyValueData.Architecture || keyValueData.architecture;
                if (arch) {
                    const archStr = arch.toString().toLowerCase();
                    if (archStr === 'amd64') return 'x86_64';
                }
            }
            
            // NCP/NCPVPC: Extract from architecture or cpu_architecture
            else if (csp === 'ncp' || csp === 'ncpvpc') {
                const arch = keyValueData.architecture || keyValueData.cpu_architecture;
                if (arch) {
                    const archStr = arch.toString().toUpperCase();
                    if (archStr === 'X86_64') return 'x86_64';
                }
            }
            
        } catch (e) {
            console.warn('Error parsing key_value_json for OS Arch:', e);
        }
        
        return 'NA';
    }

    function displaySpecs(specs) {
        const container = document.getElementById('spec-list-container');
        
        if (specs.length === 0) {
            container.innerHTML = '<div class="no-data-message">No VM specs found matching the filters.</div>';
            return;
        }

        // Helper function to display value or NA
        const displayValue = (value) => {
            if (value === -1 || value === '-' || value === '-1' || !value || value === 0) return '<span style="color: #999;">NA</span>';
            return value;
        };
        
        const displayNumeric = (value) => {
            if (value === -1 || value === '-' || value === '-1' || !value) return '<span style="color: #999;">NA</span>';
            return typeof value === 'number' ? value.toLocaleString() : value;
        };

        // Helper function to create sortable header
        const createSortableSpecHeader = (label, field, style = '') => {
            const isActive = specSortField === field;
            const arrow = isActive ? (specSortOrder === 'asc' ? ' ‚ñ≤' : ' ‚ñº') : '';
            const baseStyle = 'cursor: pointer; user-select: none;';
            const finalStyle = style ? `${baseStyle} ${style}` : baseStyle;
            return `<th onclick="sortSpecs('${field}')" style="${finalStyle}" title="Click to sort">${label}${arrow}</th>`;
        };

        let tableHTML = `
            <table class="selection-table">
                <colgroup>
                    <col style="width: 40px;">
                    <col style="width: 180px;">
                    <col style="width: 70px;">
                    <col style="width: 110px;">
                    <col style="width: 85px;">
                    <col style="width: 50px;">
                    <col style="width: 90px;">
                    <col style="width: 150px;">
                    <col style="width: 130px;">
                </colgroup>
                <thead>
                    <tr>
                        <th>#</th>
                        ${createSortableSpecHeader('Name', 'name')}
                        <th style="width: 80px;">OS Arch</th>
                        ${createSortableSpecHeader('vCPU', 'vcpu_count')}
                        ${createSortableSpecHeader('Memory (MiB)', 'mem_size_mib')}
                        ${createSortableSpecHeader('Disk (GB)', 'disk_size_gb')}
                        ${createSortableSpecHeader('GPU', 'gpu_count', 'background-color: #e8f4f8;')}
                        ${createSortableSpecHeader('Memory (GB)', 'gpu_mem_size_gb', 'background-color: #e8f4f8;')}
                        ${createSortableSpecHeader('Model', 'gpu_model', 'background-color: #e8f4f8;')}
                        <th onclick="sortSpecsByPrice()" style="cursor: pointer; user-select: none; background-color: #fff4e6;" title="Click to sort">
                            Price/Hour${specSortField === 'price_per_hour' ? (specSortOrder === 'asc' ? ' ‚ñ≤' : ' ‚ñº') : ''}
                            <span onclick="event.stopPropagation(); showPriceInfoOverlay()" style="cursor: pointer; color: #007bff; font-weight: bold; margin-left: 5px;" title="Click for price info details">‚ìò</span>
                        </th>
                    </tr>
                </thead>
                <tbody>
        `;

        specs.forEach((spec, index) => {
            const rowNumber = currentSpecPage * ITEMS_PER_PAGE + index + 1;
            
            // Extract OS Architecture
            const osArch = extractOSArch(spec);
            const osArchDisplay = osArch === 'NA' 
                ? '<span style="color: #999;">NA</span>' 
                : `<span style="color: #333; font-weight: 500;">${osArch}</span>`;
            
            // Format vCPU with clock
            let vcpuDisplay = displayNumeric(spec.vcpu_count);
            if (spec.vcpu_clock_ghz && spec.vcpu_clock_ghz !== -1 && spec.vcpu_clock_ghz !== '-' && spec.vcpu_clock_ghz !== 'NA') {
                vcpuDisplay += ` <span style="color: #666;">(${spec.vcpu_clock_ghz}GHz)</span>`;
            }
            
            // Format price display
            let priceDisplay = '<span style="color: #999;">NA</span>';
            if (spec.price_per_hour !== null && spec.price_per_hour !== undefined) {
                const priceValue = parseFloat(spec.price_per_hour);
                if (!isNaN(priceValue)) {
                    priceDisplay = `$${priceValue.toFixed(4)}`;
                    // Add On-Demand or Spot type if available
                    const details = [];
                    if (spec.price_description) {
                        const desc = spec.price_description.toLowerCase();
                        if (desc.includes('on-demand') || desc.includes('ondemand')) details.push('On-Demand');
                        else if (desc.includes('spot')) details.push('Spot');
                    }
                    if (details.length > 0) {
                        priceDisplay += ` <span style="color: #999; font-size: 0.85em;">(${details.join(', ')})</span>`;
                    }
                }
            }
            
            // Format GPU Model display
            let gpuModelDisplay = spec.gpu_model === 'NA' || !spec.gpu_model 
                ? '<span style="color: #999;">NA</span>' 
                : spec.gpu_model;
            
            tableHTML += `
                <tr>
                    <td style="color: #6c757d;">${rowNumber}</td>
                    <td><a href="javascript:void(0)" onclick='selectSpec("${spec.name}")' title="Click to select this spec" style="cursor: pointer; color: #007bff; text-decoration: underline;">${spec.name}</a></td>
                    <td style="text-align: center;">${osArchDisplay}</td>
                    <td>${vcpuDisplay}</td>
                    <td>${displayNumeric(spec.mem_size_mib)}</td>
                    <td>${displayNumeric(spec.disk_size_gb)}</td>
                    <td>${spec.gpu_count > 0 ? spec.gpu_count : '<span style="color: #999;">NA</span>'}</td>
                    <td>${displayNumeric(spec.gpu_mem_size_gb)}</td>
                    <td>${gpuModelDisplay}</td>
                    <td>${priceDisplay}</td>
                </tr>
            `;
        });

        tableHTML += '</tbody></table>';
        container.innerHTML = tableHTML;
        
        // Store current spec data for selectSpec() function
        currentSpecData = specs;
    }

    function sortSpecs(field) {
        if (specSortField === field) {
            // Toggle sort order if clicking the same field
            specSortOrder = specSortOrder === 'asc' ? 'desc' : 'asc';
        } else {
            // Set new field and default to ascending
            specSortField = field;
            specSortOrder = 'asc';
        }
        // Reset to first page when sorting changes
        currentSpecPage = 0;
        loadSpecs();
    }

    function selectSpec(specName) {
        document.getElementById('vmSpecName').value = specName;
        
        // Find the selected spec data
        const selectedSpec = currentSpecData.find(spec => spec.name === specName);
        
        // Update Spec information display
        const specInfoDisplay = document.getElementById('specInfoDisplay');
        if (selectedSpec && specInfoDisplay) {
            // Clear previous content
            specInfoDisplay.innerHTML = '';
            
            // Box 1: CPU / Memory - Always display
            const cpuMemBox = document.createElement('span');
            cpuMemBox.className = 'spec-info-box';
            
            const hasCPU = selectedSpec.vcpu_count && selectedSpec.vcpu_count !== -1 && selectedSpec.vcpu_count !== '-';
            const hasMemory = selectedSpec.mem_size_mib && selectedSpec.mem_size_mib !== -1 && selectedSpec.mem_size_mib !== '-';
            
            const cpuValue = hasCPU ? selectedSpec.vcpu_count : '-';
            const memValue = hasMemory ? Math.round(selectedSpec.mem_size_mib / 1024) : '-';
            const cpuMemText = `CPU: ${cpuValue}/${memValue} GiB`;
            
            cpuMemBox.textContent = cpuMemText;
            cpuMemBox.title = cpuMemText;
            specInfoDisplay.appendChild(cpuMemBox);
            
            // Box 2: GPU / GPU Memory - Always display
            const gpuBox = document.createElement('span');
            gpuBox.className = 'spec-info-box';
            
            const hasGPU = selectedSpec.gpu_count && selectedSpec.gpu_count > 0;
            const hasGPUMem = selectedSpec.gpu_mem_size_gb && selectedSpec.gpu_mem_size_gb !== -1 && selectedSpec.gpu_mem_size_gb !== '-';
            
            let gpuText;
            if (!hasGPU && !hasGPUMem) {
                // Both values missing
                gpuText = 'GPU: -';
            } else {
                // At least one value exists
                const gpuValue = hasGPU ? selectedSpec.gpu_count : '-';
                const gpuMemValue = hasGPUMem ? selectedSpec.gpu_mem_size_gb : '-';
                gpuText = `GPU: ${gpuValue}/${gpuMemValue} GB`;
            }
            
            gpuBox.textContent = gpuText;
            gpuBox.title = gpuText;
            specInfoDisplay.appendChild(gpuBox);
            
            // Box 3: Price - Always display
            const priceBox = document.createElement('span');
            priceBox.className = 'spec-info-box';
            
            let priceText = '$-';
            if (selectedSpec.price_per_hour !== null && selectedSpec.price_per_hour !== undefined) {
                const priceValue = parseFloat(selectedSpec.price_per_hour);
                if (!isNaN(priceValue)) {
                    priceText = `$${priceValue.toFixed(4)}/H`;
                }
            }
            
            priceBox.textContent = priceText;
            priceBox.title = priceText;
            specInfoDisplay.appendChild(priceBox);
            
            // Show the form group and display
            document.getElementById('specInfoFormGroup').style.display = '';
            specInfoDisplay.classList.add('active');
        }
        
        closeSpecSelectionOverlay();
    }

    function sortSpecsByPrice() {
        if (specSortField === 'price_per_hour') {
            // Toggle sort order if clicking the same field
            specSortOrder = specSortOrder === 'asc' ? 'desc' : 'asc';
        } else {
            // Set new field and default to ascending
            specSortField = 'price_per_hour';
            specSortOrder = 'asc';
        }
        // Reset to first page when sorting changes
        currentSpecPage = 0;
        loadSpecs();
    }

    function loadSpecPage(direction) {
        if (direction === 'next' && (currentSpecPage + 1) * ITEMS_PER_PAGE < specTotalCount) {
            currentSpecPage++;
            loadSpecs();
        } else if (direction === 'prev' && currentSpecPage > 0) {
            currentSpecPage--;
            loadSpecs();
        }
    }

    function updateSpecPagination(dataVersion) {
        const pagination = document.getElementById('spec-pagination');
        const pageInfo = document.getElementById('spec-page-info');
        const totalInfo = document.getElementById('spec-total-info');
        const versionInfo = document.getElementById('spec-data-version');
        const prevBtn = document.getElementById('spec-prev-btn');
        const nextBtn = document.getElementById('spec-next-btn');

        const totalPages = Math.ceil(specTotalCount / ITEMS_PER_PAGE);
        pageInfo.textContent = `${currentSpecPage + 1} / ${totalPages}`;
        totalInfo.textContent = `Total: ${specTotalCount.toLocaleString()}`;
        
        if (dataVersion) {
            let formattedDate = dataVersion;
            try {
                // Parse format: YYYYMMDD-HHMMSS
                const match = dataVersion.match(/(\d{4})(\d{2})(\d{2})-(\d{2})(\d{2})(\d{2})/);
                if (match) {
                    const year = match[1];
                    const month = parseInt(match[2]) - 1; // 0-based
                    const day = match[3];
                    const hour = match[4];
                    const minute = match[5];
                    const second = match[6];
                    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    formattedDate = `${months[month]} ${parseInt(day)}, ${year}, ${hour}:${minute}:${second}`;
                }
            } catch (e) {
                // If parsing fails, use the raw value
            }
            versionInfo.textContent = ` (data_ver: ${formattedDate})`;
        }

        prevBtn.disabled = currentSpecPage === 0;
        nextBtn.disabled = (currentSpecPage + 1) * ITEMS_PER_PAGE >= specTotalCount;

        pagination.style.display = specTotalCount > 0 ? 'flex' : 'none';
    }

    // ==================== VM RECENT AND FAVORITE FUNCTIONS ====================
    
    let recentData = [];
    let recentSortField = 'last_created';
    let recentSortOrder = 'desc';
    let recentDataBackup = []; // Backup for restoring when unchecking All
    
    let favoriteData = [];
    let favoriteSortField = 'created_at';
    let favoriteSortOrder = 'desc';
    let favoriteDataBackup = []; // Backup for restoring when unchecking All
    
    // Handle All checkbox change
    async function onAllCheckboxChange() {
        const checkbox = document.getElementById('export-all-checkbox');
        const isAllMode = checkbox.checked;
        
        // Show loading overlay
        const loadingOverlay = document.getElementById('global-loading-overlay');
        loadingOverlay.style.display = 'flex';
        
        try {
            // Show/hide CSP, Region, Zone columns
            const cspHeader = document.getElementById('recent-csp-header');
            const regionHeader = document.getElementById('recent-region-header');
            const zoneHeader = document.getElementById('recent-zone-header');
            
            if (cspHeader) cspHeader.style.display = isAllMode ? '' : 'none';
            if (regionHeader) regionHeader.style.display = isAllMode ? '' : 'none';
            if (zoneHeader) zoneHeader.style.display = isAllMode ? '' : 'none';
            
            // Resize overlay content
            const overlayContent = document.getElementById('recent-overlay-content');
            if (overlayContent) {
                overlayContent.style.maxWidth = isAllMode ? '90vw' : '1300px';
            }
            
            // Disable/enable bulk star button
            const bulkStarBtn = document.getElementById('recent-bulk-star-btn');
            if (bulkStarBtn) {
                bulkStarBtn.disabled = isAllMode;
                bulkStarBtn.style.opacity = isAllMode ? '0.3' : '1';
                bulkStarBtn.style.cursor = isAllMode ? 'not-allowed' : 'pointer';
            }
            
            if (isAllMode) {
                // Backup current connection data before loading all
                recentDataBackup = [...recentData];
                // Check mode: Load all data
                await loadVMRecentList();
            } else {
                // Uncheck mode: Restore backed up data
                recentData = [...recentDataBackup];
                recentDataBackup = [];
                renderRecentTable();
            }
        } finally {
            // Hide loading overlay
            loadingOverlay.style.display = 'none';
        }
    }
    
    // Show VM Recent Overlay
    async function showVMRecentOverlay() {
        // 1. Show loading spinner
        const loadingOverlay = document.getElementById('global-loading-overlay');
        loadingOverlay.style.display = 'flex';
        
        try {
            // 2. Initialize All checkbox state and column visibility
            const checkbox = document.getElementById('export-all-checkbox');
            const isAllMode = checkbox?.checked || false;
            
            const cspHeader = document.getElementById('recent-csp-header');
            const regionHeader = document.getElementById('recent-region-header');
            const zoneHeader = document.getElementById('recent-zone-header');
            
            if (cspHeader) cspHeader.style.display = isAllMode ? '' : 'none';
            if (regionHeader) regionHeader.style.display = isAllMode ? '' : 'none';
            if (zoneHeader) zoneHeader.style.display = isAllMode ? '' : 'none';
            
            const overlayContent = document.getElementById('recent-overlay-content');
            if (overlayContent) {
                overlayContent.style.maxWidth = isAllMode ? '90vw' : '1300px';
            }
            
            // Initialize bulk star button state
            const bulkStarBtn = document.getElementById('recent-bulk-star-btn');
            if (bulkStarBtn) {
                bulkStarBtn.disabled = isAllMode;
                bulkStarBtn.style.opacity = isAllMode ? '0.3' : '1';
                bulkStarBtn.style.cursor = isAllMode ? 'not-allowed' : 'pointer';
            }
            
            // 3. Fetch data
            await loadVMRecentList();
            
            // 4. Show overlay
            document.getElementById('vm-recent-overlay').style.display = 'flex';
            document.addEventListener('keydown', handleVMRecentOverlayEsc);
        } catch (error) {
            console.error('Error loading recent VM data:', error);
            alert('Failed to load recent VM data: ' + error.message);
        } finally {
            // Hide loading spinner
            loadingOverlay.style.display = 'none';
        }
    }
    
    // Close VM Recent Overlay
    function closeVMRecentOverlay() {
        document.getElementById('vm-recent-overlay').style.display = 'none';
        document.removeEventListener('keydown', handleVMRecentOverlayEsc);
    }

    function handleVMRecentOverlayEsc(event) {
        if (event.key === 'Escape') {
            event.stopImmediatePropagation();
            closeVMRecentOverlay();
        }
    }
    
    // Load VM Recent List
    async function loadVMRecentList() {
        const loadingMsg = document.querySelector('#recent-list-container .loading-message');
        const table = document.getElementById('recent-table');
        const tbody = document.getElementById('recent-table-body');
        const noDataMsg = document.getElementById('recent-no-data');
        
        loadingMsg.style.display = 'block';
        table.style.display = 'none';
        noDataMsg.style.display = 'none';
        tbody.innerHTML = '';
        
        try {
            const connConfig = document.getElementById('connConfig').value;
            
            // Get connection info for CSP, Region, Zone
            const connInfo = await getConnectionInfo();
            
            // Show/hide MC-Insight badge based on CSP
            const recentBadge = document.getElementById('recent-mcinsight-badge');
            if (connInfo.csp.toUpperCase() === 'OPENSTACK' || connInfo.csp.toUpperCase() === 'MOCK' || connInfo.csp.toUpperCase() === 'CLOUDTWIN') {
                recentBadge.style.display = 'none';
            } else {
                recentBadge.style.display = 'inline';
            }
            
            // Check if All mode is enabled
            const isAllMode = document.getElementById('export-all-checkbox')?.checked || false;
            
            const params = new URLSearchParams({
                CSP: isAllMode ? '' : (connInfo.csp || ''),
                Region: isAllMode ? '' : (connInfo.region || ''),
                Zone: isAllMode ? '' : (connInfo.zone || ''),
                Limit: isAllMode ? '1000' : '10',
                SortBy: recentSortField === 'last_created' ? 'last_created_at' : 'creation_count',
                SortOrder: recentSortOrder
            });
            
            const response = await fetch(`/spider/vm/imagespecrecent?${params}`);
            if (!response.ok) {
                throw new Error('Failed to fetch recent VM data');
            }
            
            const recentList = await response.json();
            loadingMsg.style.display = 'none';
            
            if (!recentList || recentList.length === 0) {
                noDataMsg.style.display = 'block';
                recentData = [];
                return;
            }
            
            // Store data and fetch MC-Insight info
            // In All mode, preserve existing connection data and only add new items
            const existingDataMap = new Map();
            if (isAllMode && recentData.length > 0) {
                // Keep existing data with metadata
                recentData.forEach(item => {
                    const key = `${item.CSP}|${item.Region}|${item.Zone}|${item.ImageName}|${item.SpecName}`;
                    existingDataMap.set(key, item);
                });
            } else {
                // Clear data in non-All mode
                recentData = [];
            }
            
            const newData = [];
            
            // Fetch MC-Insight data in parallel for better performance
            if (!isAllMode) {
                const fetchPromises = recentList.map(async (record) => {
                    // Use DB stored data for all fields including price
                    let osArch = record.OSArch || '-';
                    let osPlatform = record.OsPlatform || '-';
                    let osDistribution = record.OsDistribution || '-';
                    let cpuInfo = record.CPUInfo || '-';
                    let gpuInfo = record.GPUInfo || '-';
                    let priceDisplay = record.PriceInfo || '$-';
                    
                    return { record, osArch, osPlatform, osDistribution, cpuInfo, gpuInfo, priceDisplay };
                });
                
                const results = await Promise.all(fetchPromises);
                
                // Process results
                for (const { record, osArch, osPlatform, osDistribution, cpuInfo, gpuInfo, priceDisplay } of results) {
                    // Check if favorited
                    const isFavorite = await checkIfFavorite(record.CSP, record.Region, record.Zone, record.ImageName, record.SpecName);
                    
                    const itemData = {
                        ...record,
                        osArch,
                        osPlatform,
                        osDistribution,
                        cpuInfo,
                        gpuInfo,
                        priceDisplay,
                        isFavorite
                    };
                    
                    newData.push(itemData);
                }
            } else {
                // In All mode, just process without MC-Insight data
                for (let i = 0; i < recentList.length; i++) {
                    const record = recentList[i];
                    
                    // Use DB stored data
                    const osArch = record.OSArch || '-';
                    const osPlatform = record.OsPlatform || '-';
                    const osDistribution = record.OsDistribution || '-';
                    const cpuInfo = record.CPUInfo || '-';
                    const gpuInfo = record.GPUInfo || '-';
                    const priceDisplay = record.PriceInfo || '$-';
                    
                    // Check if favorited
                    const isFavorite = await checkIfFavorite(record.CSP, record.Region, record.Zone, record.ImageName, record.SpecName);
                    
                    const itemData = {
                        ...record,
                        osArch,
                        osPlatform,
                        osDistribution,
                        cpuInfo,
                        gpuInfo,
                        priceDisplay,
                        isFavorite
                    };
                    
                    // Check if this item already exists in All mode
                    const key = `${record.CSP}|${record.Region}|${record.Zone}|${record.ImageName}|${record.SpecName}`;
                    if (existingDataMap.has(key)) {
                        // Use existing data with metadata
                        newData.push(existingDataMap.get(key));
                        existingDataMap.delete(key); // Remove from map to avoid duplicates
                    } else {
                        // Add new data
                        newData.push(itemData);
                    }
                }
            }
            
            // Combine remaining existing data (in case some items were removed from backend)
            if (isAllMode && existingDataMap.size > 0) {
                existingDataMap.forEach(item => newData.push(item));
            }
            
            recentData = newData;
            
            renderRecentTable();
        } catch (error) {
            console.error('Error loading recent VM list:', error);
            loadingMsg.style.display = 'none';
            noDataMsg.textContent = 'Error loading recent VM data: ' + error.message;
            noDataMsg.style.display = 'block';
        }
    }
    
    // Render Recent Table
    function renderRecentTable() {
        const tbody = document.getElementById('recent-table-body');
        const table = document.getElementById('recent-table');
        tbody.innerHTML = '';
        
        const isAllMode = document.getElementById('export-all-checkbox')?.checked || false;
        
        // Sort data: existing items first, new items last (in All mode)
        let sortedData = [...recentData];
        if (isAllMode && recentDataBackup.length > 0) {
            sortedData.sort((a, b) => {
                const keyA = `${a.CSP}|${a.Region}|${a.Zone}|${a.ImageName}|${a.SpecName}`;
                const keyB = `${b.CSP}|${b.Region}|${b.Zone}|${b.ImageName}|${b.SpecName}`;
                const isNewA = !recentDataBackup.some(item => 
                    `${item.CSP}|${item.Region}|${item.Zone}|${item.ImageName}|${item.SpecName}` === keyA
                );
                const isNewB = !recentDataBackup.some(item => 
                    `${item.CSP}|${item.Region}|${item.Zone}|${item.ImageName}|${item.SpecName}` === keyB
                );
                // Existing items (false) come before new items (true)
                return isNewA - isNewB;
            });
        }
        
        sortedData.forEach((record, i) => {
            const row = document.createElement('tr');
            
            // Check if this is a newly added item (not in backup)
            let isNewItem = false;
            if (isAllMode && recentDataBackup.length > 0) {
                const key = `${record.CSP}|${record.Region}|${record.Zone}|${record.ImageName}|${record.SpecName}`;
                isNewItem = !recentDataBackup.some(item => 
                    `${item.CSP}|${item.Region}|${item.Zone}|${item.ImageName}|${item.SpecName}` === key
                );
            }
            
            // Apply darker background to new items
            if (isNewItem) {
                row.style.backgroundColor = '#d0d0d0'; // Darker gray background
            }
            
            // Disable row selection in All mode
            if (!isAllMode) {
                row.style.cursor = 'pointer';
                row.onclick = function(e) {
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                        return;
                    }
                    selectRecentConfig(record.ImageName, record.SpecName);
                };
            } else {
                row.style.cursor = 'not-allowed';
                row.style.opacity = '0.8';
            }
            
            const starIcon = record.isFavorite ? '‚òÖ' : '‚òÜ';
            const starColor = record.isFavorite ? '#ffc107' : '#666';
            const starDisabled = isAllMode ? 'disabled' : '';
            const starOpacity = isAllMode ? 'opacity: 0.3; cursor: not-allowed;' : '';
            const starOnclick = isAllMode ? '' : `onclick="toggleFavoriteFromRecent(this, ${i})"`;
            
            // Build row HTML based on All mode
            let rowHTML = `<td style="text-align: center;">${i + 1}</td>`;
            
            if (isAllMode) {
                rowHTML += `
                    <td style="text-align: center;">${record.CSP || '-'}</td>
                    <td style="text-align: center;">${record.Region || '-'}</td>
                    <td style="text-align: center;">${record.Zone || '-'}</td>
                `;
            }
            
            rowHTML += `
                <td style="text-align: center; color: #0066cc;">${record.ImageName}</td>
                <td style="text-align: center; color: #0066cc;">${record.SpecName}</td>
                <td>${record.osArch}</td>
                <td>${record.cpuInfo}</td>
                <td>${record.gpuInfo}</td>
                <td>${record.priceDisplay}</td>
                <td>${record.AvgCreationTime.toFixed(2)} s</td>
                <td>${record.CreationCount}</td>
                <td>${formatDateTime(record.LastCreatedAt)}</td>
                <td style="text-align: center;">
                    <button class="select-btn" style="font-size: 14px; padding: 1px 4px; color: ${starColor}; ${starOpacity}" ${starDisabled} ${starOnclick}>${starIcon}</button>
                    <button class="select-btn" style="font-size: 14px; padding: 1px 4px; color: #dc3545; margin-left: 2px;" onclick="deleteRecentRecord(${i})" title="Delete">‚úï</button>
                </td>
            `;
            
            row.innerHTML = rowHTML;
            tbody.appendChild(row);
        });
        
        updateRecentTableHeaders();
        table.style.display = 'table';
    }
    
    // Fetch image info from MC-Insight
    async function fetchImageInfoForRecent(connInfo, zone, imageName) {
        try {
            // Use Spider API for OpenStack and Mock
            if (connInfo.csp.toUpperCase() === 'OPENSTACK' || connInfo.csp.toUpperCase() === 'MOCK' || connInfo.csp.toUpperCase() === 'CLOUDTWIN') {
                const connectionName = document.getElementById('connConfig').value;
                const response = await fetch(`/spider/vmimage?ConnectionName=${encodeURIComponent(connectionName)}`);
                if (!response.ok) return null;
                
                const data = await response.json();
                const image = data.image?.find(img => img.IId?.NameId === imageName);
                if (!image) return null;
                
                // Transform Spider API format to MC-Insight format
                return {
                    os_architecture: image.OSArchitecture || 'NA',
                    os_platform: image.OSPlatform || 'NA',
                    os_distribution: image.OSDistribution || 'NA'
                };
            }
            
            // Use MC-Insight API for other CSPs
            const params = new URLSearchParams({
                csp: connInfo.csp.toLowerCase(),
                image_id: imageName,
                page: '0',
                limit: '1'
            });
            
            // Add region and zone as individual parameters
            if (connInfo.region) params.append('region', connInfo.region);
            if (zone) params.append('zone', zone);
            
            const apiUrl = `${MC_INSIGHT_API_BASE}/vm-image?${params}`;
            console.log(`[Recent-Image] Fetching: ${apiUrl}`);
            let response = await fetch(apiUrl);
            if (!response.ok) {
                // Retry with alternative CSP names for NCP, NHN, KT
                const cspLower = connInfo.csp.toLowerCase();
                let altCsp = null;
                if (cspLower === 'ncp') {
                    altCsp = 'ncpvpc';
                } else if (cspLower === 'nhn') {
                    altCsp = 'nhncloud';
                } else if (cspLower === 'kt') {
                    altCsp = 'ktvpc';
                }
                
                if (altCsp) {
                    console.log(`${connInfo.csp} failed, trying ${altCsp}...`);
                    params.set('csp', altCsp);
                    const altUrl = `${MC_INSIGHT_API_BASE}/vm-image?${params}`;
                    response = await fetch(altUrl);
                    if (!response.ok) return null;
                } else {
                    return null;
                }
            }
            
            const data = await response.json();
            
            // Check if we need to retry with alternative CSP name
            if ((!data.items || data.items.length === 0) && data.total === 0) {
                const cspLower = connInfo.csp.toLowerCase();
                let altCsp = null;
                if (cspLower === 'ncp') {
                    altCsp = 'ncpvpc';
                } else if (cspLower === 'nhn') {
                    altCsp = 'nhncloud';
                } else if (cspLower === 'kt') {
                    altCsp = 'ktvpc';
                }
                
                if (altCsp) {
                    console.log(`${connInfo.csp} returned no results, trying ${altCsp}...`);
                    params.set('csp', altCsp);
                    const altUrl = `${MC_INSIGHT_API_BASE}/vm-image?${params}`;
                    const altResponse = await fetch(altUrl);
                    if (altResponse.ok) {
                        const altData = await altResponse.json();
                        return altData.items?.[0] || null;
                    }
                }
            }
            
            const imageData = data.items?.[0] || null;
            return imageData;
        } catch (error) {
            console.error('Error fetching image info:', error);
            return null;
        }
    }
    
    // Fetch spec info from MC-Insight
    async function fetchSpecInfoForRecent(connInfo, zone, specName) {
        try {
            // Use Spider API for OpenStack and Mock
            if (connInfo.csp.toUpperCase() === 'OPENSTACK' || connInfo.csp.toUpperCase() === 'MOCK' || connInfo.csp.toUpperCase() === 'CLOUDTWIN') {
                const connectionName = document.getElementById('connConfig').value;
                const response = await fetch(`/spider/vmspec?ConnectionName=${encodeURIComponent(connectionName)}`);
                if (!response.ok) return null;
                
                const data = await response.json();
                const spec = data.vmspec?.find(s => s.Name === specName);
                if (!spec) return null;
                
                // Transform Spider API format to MC-Insight format
                let memSizeMiB = -1;
                if (spec.MemSizeMiB) {
                    const parsed = parseInt(spec.MemSizeMiB);
                    if (!isNaN(parsed) && parsed > 0) {
                        memSizeMiB = parsed;
                    }
                }
                
                let vcpuCount = -1;
                if (spec.VCpu?.Count) {
                    const parsed = parseInt(spec.VCpu.Count);
                    if (!isNaN(parsed) && parsed > 0) {
                        vcpuCount = parsed;
                    }
                }
                
                let gpuCount = -1;
                let gpuMemSizeGb = -1;
                let gpuModel = 'NA';
                
                if (spec.Gpu && spec.Gpu.length > 0) {
                    // GPU Count
                    if (spec.Gpu[0].Count) {
                        const parsed = parseInt(spec.Gpu[0].Count);
                        if (!isNaN(parsed) && parsed > 0) {
                            gpuCount = parsed;
                        }
                    }
                    
                    // GPU Model
                    if (spec.Gpu[0].Model && spec.Gpu[0].Model !== 'NA' && spec.Gpu[0].Model !== '-1') {
                        gpuModel = spec.Gpu[0].Model;
                    }
                    
                    // GPU Memory
                    if (spec.Gpu[0].MemSizeGB) {
                        const parsed = parseInt(spec.Gpu[0].MemSizeGB);
                        if (!isNaN(parsed) && parsed > 0) {
                            gpuMemSizeGb = parsed;
                        }
                    }
                }
                
                return {
                    vcpu_count: vcpuCount,
                    mem_size_mib: memSizeMiB,
                    gpu_count: gpuCount,
                    gpu_mem_size_gb: gpuMemSizeGb,
                    gpu_model: gpuModel,
                    price_per_hour: null  // Spider API doesn't provide price
                };
            }
            
            // Use MC-Insight API for other CSPs
            const params = new URLSearchParams({
                csp: connInfo.csp.toLowerCase(),
                name: specName,
                page: '0',
                limit: '1'
            });
            
            // Add region and zone as individual parameters
            if (connInfo.region) params.append('region', connInfo.region);
            if (zone) params.append('zone', zone);
            
            let actualCsp = connInfo.csp.toLowerCase(); // Track which CSP name actually worked
            
            const apiUrl = `${MC_INSIGHT_API_BASE}/vm-spec?${params}`;
            console.log(`[Recent-Spec] Fetching: ${apiUrl}`);
            let response = await fetch(apiUrl);
            if (!response.ok) {
                // Retry with alternative CSP names for NCP, NHN, KT
                const cspLower = connInfo.csp.toLowerCase();
                let altCsp = null;
                if (cspLower === 'ncp') {
                    altCsp = 'ncpvpc';
                } else if (cspLower === 'nhn') {
                    altCsp = 'nhncloud';
                } else if (cspLower === 'kt') {
                    altCsp = 'ktvpc';
                }
                
                if (altCsp) {
                    console.log(`${connInfo.csp} spec failed, trying ${altCsp}...`);
                    params.set('csp', altCsp);
                    actualCsp = altCsp; // Update actual CSP name
                    const altUrl = `${MC_INSIGHT_API_BASE}/vm-spec?${params}`;
                    response = await fetch(altUrl);
                    if (!response.ok) return null;
                } else {
                    return null;
                }
            }
            
            let data = await response.json();
            
            // Check if we need to retry with alternative CSP name
            if ((!data.items || data.items.length === 0) && data.total === 0) {
                const cspLower = connInfo.csp.toLowerCase();
                let altCsp = null;
                if (cspLower === 'ncp') {
                    altCsp = 'ncpvpc';
                } else if (cspLower === 'nhn') {
                    altCsp = 'nhncloud';
                } else if (cspLower === 'kt') {
                    altCsp = 'ktvpc';
                }
                
                if (altCsp) {
                    console.log(`${connInfo.csp} spec returned no results, trying ${altCsp}...`);
                    params.set('csp', altCsp);
                    actualCsp = altCsp; // Update actual CSP name
                    const altUrl = `${MC_INSIGHT_API_BASE}/vm-spec?${params}`;
                    const altResponse = await fetch(altUrl);
                    if (altResponse.ok) {
                        data = await altResponse.json();
                    }
                }
            }
            
            // Find the matching spec by name
            let specData = null;
            if (data.items && data.items.length > 0) {
                specData = data.items.find(item => item.name === specName);
                if (!specData) {
                    console.warn(`[Recent-Spec] No matching spec found for ${specName}, using first item`);
                    specData = data.items[0];
                }
            }
            
            // Fetch price info separately - always start with original CSP name
            if (specData) {
                try {
                    const priceParams = new URLSearchParams({
                        csp: connInfo.csp.toLowerCase(), // Always start with original CSP name (e.g., ncp)
                        name: specName,  // Use name parameter for spec name filtering (partial match in API)
                        limit: '50'  // Get up to 50 results to find exact match
                    });
                    if (connInfo.region) priceParams.append('region', connInfo.region);
                    if (zone) priceParams.append('zone', zone);
                    
                    const priceUrl = `${MC_INSIGHT_API_BASE}/price-info?${priceParams}`;
                    let priceResponse = await fetch(priceUrl);
                    let priceData = null;
                    
                    if (priceResponse.ok) {
                        priceData = await priceResponse.json();
                    }
                    
                    // Retry with alternative CSP names if failed or no results
                    if (!priceResponse.ok || !priceData || !priceData.items || priceData.items.length === 0) {
                        const cspLower = connInfo.csp.toLowerCase();
                        let altCsp = null;
                        if (cspLower === 'ncp') {
                            altCsp = 'ncpvpc';
                        } else if (cspLower === 'nhn') {
                            altCsp = 'nhncloud';
                        } else if (cspLower === 'kt') {
                            altCsp = 'ktvpc';
                        }
                        
                        if (altCsp) {
                            priceParams.set('csp', altCsp);
                            const altPriceUrl = `${MC_INSIGHT_API_BASE}/price-info?${priceParams}`;
                            priceResponse = await fetch(altPriceUrl);
                            if (priceResponse.ok) {
                                priceData = await priceResponse.json();
                            }
                        }
                    }
                    
                    // Find exact match by name (strict match required)
                    if (priceData && priceData.items && priceData.items.length > 0) {
                        const exactMatch = priceData.items.find(item => item.name === specName);
                        
                        if (exactMatch) {
                            // Only set price if exact match found
                            specData.price_per_hour = exactMatch.price;
                            specData.price_currency = exactMatch.currency;
                        } else {
                            // No exact match found, leave as NA (null)
                            specData.price_per_hour = null;
                            specData.price_currency = null;
                        }
                    } else {
                        // No results returned, leave as NA (null)
                        specData.price_per_hour = null;
                        specData.price_currency = null;
                    }
                } catch (priceError) {
                    console.error('[Recent-Price] Failed to fetch price:', priceError);
                    // On error, leave as NA (null)
                    specData.price_per_hour = null;
                    specData.price_currency = null;
                }
            }
            
            return specData;
        } catch (error) {
            console.error('Error fetching spec info:', error);
            return null;
        }
    }
    
    // Fetch price info only from MC-Insight
    async function fetchPriceInfoForRecent(connInfo, zone, specName) {
        try {
            // Use Spider API for OpenStack and Mock (no price info available)
            if (connInfo.csp.toUpperCase() === 'OPENSTACK' || connInfo.csp.toUpperCase() === 'MOCK' || connInfo.csp.toUpperCase() === 'CLOUDTWIN') {
                return { price_per_hour: null };
            }
            
            // Use MC-Insight API for other CSPs
            const priceParams = new URLSearchParams({
                csp: connInfo.csp.toLowerCase(),
                name: specName,
                limit: '50'
            });
            if (connInfo.region) priceParams.append('region', connInfo.region);
            if (zone) priceParams.append('zone', zone);
            
            const priceUrl = `${MC_INSIGHT_API_BASE}/price-info?${priceParams}`;
            let priceResponse = await fetch(priceUrl);
            let priceData = null;
            
            if (priceResponse.ok) {
                priceData = await priceResponse.json();
            }
            
            // Retry with alternative CSP names if failed or no results
            if (!priceResponse.ok || !priceData || !priceData.items || priceData.items.length === 0) {
                const cspLower = connInfo.csp.toLowerCase();
                let altCsp = null;
                if (cspLower === 'ncp') {
                    altCsp = 'ncpvpc';
                } else if (cspLower === 'nhn') {
                    altCsp = 'nhncloud';
                } else if (cspLower === 'kt') {
                    altCsp = 'ktvpc';
                }
                
                if (altCsp) {
                    priceParams.set('csp', altCsp);
                    const altPriceUrl = `${MC_INSIGHT_API_BASE}/price-info?${priceParams}`;
                    priceResponse = await fetch(altPriceUrl);
                    if (priceResponse.ok) {
                        priceData = await priceResponse.json();
                    }
                }
            }
            
            // Find exact match by name (strict match required)
            if (priceData && priceData.items && priceData.items.length > 0) {
                const exactMatch = priceData.items.find(item => item.name === specName);
                
                if (exactMatch) {
                    return {
                        price_per_hour: exactMatch.price,
                        price_currency: exactMatch.currency
                    };
                }
            }
            
            return { price_per_hour: null };
        } catch (error) {
            console.error('[Recent-Price] Failed to fetch price:', error);
            return { price_per_hour: null };
        }
    }
    
    // Sort recent table (client-side)
    function sortRecentTable(field) {
        if (recentSortField === field) {
            recentSortOrder = recentSortOrder === 'asc' ? 'desc' : 'asc';
        } else {
            recentSortField = field;
            recentSortOrder = 'desc';
        }
        
        // Client-side sort
        recentData.sort((a, b) => {
            let aVal, bVal;
            
            if (field === 'count') {
                aVal = a.CreationCount;
                bVal = b.CreationCount;
            } else if (field === 'last_created') {
                aVal = new Date(a.LastCreatedAt).getTime();
                bVal = new Date(b.LastCreatedAt).getTime();
            } else if (field === 'csp') {
                aVal = (a.CSP || '').toLowerCase();
                bVal = (b.CSP || '').toLowerCase();
            } else if (field === 'region') {
                aVal = (a.Region || '').toLowerCase();
                bVal = (b.Region || '').toLowerCase();
            } else if (field === 'zone') {
                aVal = (a.Zone || '').toLowerCase();
                bVal = (b.Zone || '').toLowerCase();
            } else if (field === 'image_name') {
                aVal = (a.ImageName || '').toLowerCase();
                bVal = (b.ImageName || '').toLowerCase();
            } else if (field === 'spec_name') {
                aVal = (a.SpecName || '').toLowerCase();
                bVal = (b.SpecName || '').toLowerCase();
            } else if (field === 'os_arch') {
                aVal = (a.osArch || '').toLowerCase();
                bVal = (b.osArch || '').toLowerCase();
            } else if (field === 'cpu') {
                aVal = (a.cpuInfo || '').toLowerCase();
                bVal = (b.cpuInfo || '').toLowerCase();
            } else if (field === 'gpu') {
                aVal = (a.gpuInfo || '').toLowerCase();
                bVal = (b.gpuInfo || '').toLowerCase();
            } else if (field === 'price') {
                // Extract numeric value from price string (e.g., "$0.6470" -> 0.6470)
                aVal = parseFloat((a.PriceInfo || '0').replace(/[^0-9.]/g, '')) || 0;
                bVal = parseFloat((b.PriceInfo || '0').replace(/[^0-9.]/g, '')) || 0;
            } else if (field === 'avg_time') {
                aVal = a.AvgCreationTime || 0;
                bVal = b.AvgCreationTime || 0;
            }
            
            // Handle numeric sorting
            if (field === 'count' || field === 'last_created' || field === 'price' || field === 'avg_time') {
                if (recentSortOrder === 'asc') {
                    return aVal - bVal;
                } else {
                    return bVal - aVal;
                }
            } else {
                // String sorting
                if (recentSortOrder === 'asc') {
                    return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                } else {
                    return bVal > aVal ? 1 : bVal < aVal ? -1 : 0;
                }
            }
        });
        
        updateRecentTableHeaders();
        renderRecentTable();
    }
    
    // Update Recent table headers with sort arrows
    function updateRecentTableHeaders() {
        const headers = document.querySelectorAll('#recent-table-header th');
        headers.forEach(header => {
            const onclick = header.getAttribute('onclick');
            if (onclick) {
                const match = onclick.match(/sortRecentTable\('([^']+)'\)/);
                if (match) {
                    const field = match[1];
                    const isActive = recentSortField === field;
                    const arrow = isActive ? (recentSortOrder === 'asc' ? ' ‚ñ≤' : ' ‚ñº') : '';
                    
                    let text = header.textContent.replace(/\s*[‚ñ≤‚ñº]\s*$/, '').trim();
                    header.textContent = text + arrow;
                }
            }
        });
    }
    
    // Check if config is in favorites
    async function checkIfFavorite(csp, region, zone, imageName, specName) {
        try {
            const params = new URLSearchParams({
                CSP: csp,
                Region: region,
                Zone: zone || ''
            });
            
            const response = await fetch(`/spider/vm/imagespecfavorite?${params}`);
            if (!response.ok) return false;
            
            const favoriteList = await response.json();
            return favoriteList.some(fav => 
                fav.ImageName === imageName && fav.SpecName === specName
            );
        } catch (error) {
            console.error('Error checking favorite status:', error);
            return false;
        }
    }
    
    // Toggle favorite from recent
    async function toggleFavoriteFromRecent(buttonElement, index) {
        const record = recentData[index];
        
        try {
            const params = new URLSearchParams({
                CSP: record.CSP,
                Region: record.Region,
                Zone: record.Zone || '',
                ImageName: record.ImageName,
                SpecName: record.SpecName
            });
            
            if (record.isFavorite) {
                // Remove from favorites
                const response = await fetch(`/spider/vm/imagespecfavorite?${params}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to remove from favorites');
                }
                
                // Update local state
                recentData[index].isFavorite = false;
                
                // Update button
                buttonElement.textContent = '‚òÜ';
                buttonElement.style.color = '#666';
            } else {
                // Add to favorites with all metadata
                const body = {
                    CSP: record.CSP,
                    Region: record.Region,
                    Zone: record.Zone || '',
                    ImageName: record.ImageName,
                    SpecName: record.SpecName,
                    OSArch: record.osArch,
                    OsPlatform: record.osPlatform,
                    OsDistribution: record.osDistribution,
                    CPUInfo: record.cpuInfo,
                    GPUInfo: record.gpuInfo,
                    PriceInfo: record.priceDisplay
                };
                
                const response = await fetch(`/spider/vm/imagespecfavorite`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message || 'Failed to add favorite');
                }
                
                // Update local state
                recentData[index].isFavorite = true;
                
                // Update button
                buttonElement.textContent = '‚òÖ';
                buttonElement.style.color = '#ffc107';
            }
        } catch (error) {
            alert('Error toggling favorite: ' + error.message);
        }
    }
    
    // Delete recent record
    // Bulk toggle favorite for all recent records
    async function bulkToggleRecentFavorite(event) {
        event.stopPropagation(); // Prevent header click event
        
        const isAllMode = document.getElementById('export-all-checkbox')?.checked || false;
        if (isAllMode) {
            alert('Cannot add favorites in All mode');
            return;
        }
        
        if (!recentData || recentData.length === 0) {
            alert('No recent records to add to favorites');
            return;
        }
        
        if (!confirm(`Add all ${recentData.length} recent record(s) to favorites?`)) {
            return;
        }
        
        const loadingOverlay = document.getElementById('global-loading-overlay');
        loadingOverlay.style.display = 'flex';
        
        try {
            let successCount = 0;
            let errorCount = 0;
            
            for (const record of recentData) {
                try {
                    const response = await fetch('/spider/vm/imagespecfavorite', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            CSP: record.CSP,
                            Region: record.Region,
                            Zone: record.Zone || '',
                            ImageName: record.ImageName,
                            SpecName: record.SpecName,
                            OSArch: record.osArch || '',
                            OsPlatform: record.osPlatform || '',
                            OsDistribution: record.osDistribution || '',
                            CPUInfo: record.cpuInfo || '',
                            GPUInfo: record.gpuInfo || '',
                            PriceInfo: record.priceDisplay || ''
                        })
                    });
                    
                    if (response.ok) {
                        successCount++;
                        record.isFavorite = true;
                    } else {
                        errorCount++;
                    }
                } catch (err) {
                    errorCount++;
                }
            }
            
            renderRecentTable();
            alert(`Added to favorites: ${successCount} succeeded, ${errorCount} failed (may be duplicates)`);
        } catch (error) {
            alert('Error adding to favorites: ' + error.message);
        } finally {
            loadingOverlay.style.display = 'none';
        }
    }
    
    // Bulk delete all recent records
    async function bulkDeleteRecent(event) {
        event.stopPropagation(); // Prevent header click event
        
        if (!recentData || recentData.length === 0) {
            alert('No recent records to delete');
            return;
        }
        
        if (!confirm(`Are you sure you want to delete all ${recentData.length} recent record(s)?`)) {
            return;
        }
        
        const loadingOverlay = document.getElementById('global-loading-overlay');
        loadingOverlay.style.display = 'flex';
        
        try {
            let successCount = 0;
            let errorCount = 0;
            
            // Delete in reverse order to avoid index issues
            for (let i = recentData.length - 1; i >= 0; i--) {
                const record = recentData[i];
                try {
                    const params = new URLSearchParams({
                        CSP: record.CSP,
                        Region: record.Region,
                        Zone: record.Zone || '',
                        ImageName: record.ImageName,
                        SpecName: record.SpecName
                    });
                    
                    const response = await fetch(`/spider/vm/imagespecrecent?${params}`, {
                        method: 'DELETE'
                    });
                    
                    if (response.ok) {
                        successCount++;
                        recentData.splice(i, 1);
                    } else {
                        errorCount++;
                    }
                } catch (err) {
                    errorCount++;
                }
            }
            
            renderRecentTable();
            alert(`Deleted: ${successCount} succeeded, ${errorCount} failed`);
        } catch (error) {
            alert('Error deleting records: ' + error.message);
        } finally {
            loadingOverlay.style.display = 'none';
        }
    }
    
    async function deleteRecentRecord(index) {
        if (!confirm('Are you sure you want to remove this recent VM record?')) {
            return;
        }
        
        const record = recentData[index];
        
        try {
            const params = new URLSearchParams({
                CSP: record.CSP,
                Region: record.Region,
                Zone: record.Zone || '',
                ImageName: record.ImageName,
                SpecName: record.SpecName
            });
            
            const response = await fetch(`/spider/vm/imagespecrecent?${params}`, {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                throw new Error('Failed to delete recent record');
            }
            
            // Remove from local data and re-render
            recentData.splice(index, 1);
            renderRecentTable();
            
            // Show success message (optional)
            // alert('Successfully removed from recent records');
        } catch (error) {
            alert('Error deleting recent record: ' + error.message);
        }
    }
    
    // Export recent data to JSON file
    async function exportRecentData() {
        const exportAll = document.getElementById('export-all-checkbox')?.checked || false;
        
        try {
            let exportData;
            let filenamePrefix = 'cb-spider-recent-vms';
            
            if (exportAll) {
                // Fetch all recent data from backend
                const response = await fetch('/spider/vm/imagespecrecent?Limit=1000');
                if (!response.ok) {
                    throw new Error('Failed to fetch all recent VM data');
                }
                const allRecords = await response.json();
                
                if (!allRecords || allRecords.length === 0) {
                    alert('No recent VM data to export');
                    return;
                }
                
                exportData = allRecords.map(record => ({
                    CSP: record.CSP,
                    Region: record.Region,
                    Zone: record.Zone,
                    ImageName: record.ImageName,
                    SpecName: record.SpecName,
                    OSArch: record.OSArch,
                    OsPlatform: record.OsPlatform,
                    OsDistribution: record.OsDistribution,
                    CPUInfo: record.CPUInfo,
                    GPUInfo: record.GPUInfo,
                    PriceInfo: record.PriceInfo,
                    AvgCreationTime: record.AvgCreationTime,
                    CreationCount: record.CreationCount,
                    LastCreatedAt: record.LastCreatedAt
                }));
                
                filenamePrefix = 'cb-spider-recent-vms-all';
            } else {
                // Export current view data only
                if (!recentData || recentData.length === 0) {
                    alert('No recent VM data to export');
                    return;
                }
                
                exportData = recentData.map(record => ({
                    CSP: record.CSP,
                    Region: record.Region,
                    Zone: record.Zone,
                    ImageName: record.ImageName,
                    SpecName: record.SpecName,
                    OSArch: record.OSArch,
                    OsPlatform: record.OsPlatform,
                    OsDistribution: record.OsDistribution,
                    CPUInfo: record.CPUInfo,
                    GPUInfo: record.GPUInfo,
                    PriceInfo: record.PriceInfo,
                    AvgCreationTime: record.AvgCreationTime,
                    CreationCount: record.CreationCount,
                    LastCreatedAt: record.LastCreatedAt
                }));
            }
            
            // Create JSON file and download
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filenamePrefix}-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (error) {
            alert('Error exporting data: ' + error.message);
        }
    }
    
    // Import recent data from JSON file
    function importRecentData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json,.json';
        
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const importData = JSON.parse(text);
                
                if (!Array.isArray(importData)) {
                    alert('Invalid JSON format: Expected an array of records');
                    return;
                }
                
                // Auto-detect if this is All data by checking CSP diversity
                const uniqueCSPs = [...new Set(importData.map(r => r.CSP?.toUpperCase()))];
                const isAllData = uniqueCSPs.length > 1;
                
                // Show confirmation message
                const dataType = isAllData ? 'ALL CSPs/Regions' : 'specific CSP/Region';
                const confirmMsg = `Import ${importData.length} record(s) from ${dataType}?\n\nThis will skip duplicates.`;
                
                if (!confirm(confirmMsg)) {
                    return;
                }
                
                // Show loading
                const loadingMsg = document.querySelector('#recent-list-container .loading-message');
                if (loadingMsg) {
                    loadingMsg.textContent = 'Importing data...';
                    loadingMsg.style.display = 'block';
                }
                
                // Send to backend API
                const response = await fetch('/spider/vm/imagespecrecent/bulk', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ records: importData })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to import data');
                }
                
                const result = await response.json();
                
                // Hide loading
                if (loadingMsg) {
                    loadingMsg.style.display = 'none';
                }
                
                // Reload the recent list
                await loadVMRecentList();
                
                // Show result message
                alert(`Import completed: ${result.inserted || 0} inserted, ${result.skipped || 0} skipped (duplicates)`);
                
            } catch (error) {
                // Hide loading
                const loadingMsg = document.querySelector('#recent-list-container .loading-message');
                if (loadingMsg) {
                    loadingMsg.style.display = 'none';
                }
                alert('Error importing data: ' + error.message);
            }
        };
        
        input.click();
    }
    
    // Select recent config
    function selectRecentConfig(imageName, specName) {
        document.getElementById('imageName').value = imageName;
        document.getElementById('vmSpecName').value = specName;
        
        // Find the selected record from recentData
        const selectedRecord = recentData.find(record => 
            record.ImageName === imageName && record.SpecName === specName
        );
        
        if (selectedRecord) {
            // Update OS Information Display
            const osInfoDisplay = document.getElementById('osInfoDisplay');
            if (osInfoDisplay) {
                osInfoDisplay.innerHTML = '';
                
                // Use individual fields
                const osArch = selectedRecord.osArch || '-';
                const osPlatform = selectedRecord.osPlatform || '-';
                const osDistribution = selectedRecord.osDistribution || '-';
                
                // Store selected OS Arch globally (only if it has value)
                selectedOSArch = (osArch !== '-') ? osArch : '';
                
                // Create OS info boxes
                const archBox = document.createElement('span');
                archBox.className = 'os-info-box';
                archBox.textContent = osArch;
                archBox.title = osArch;
                osInfoDisplay.appendChild(archBox);
                
                const platformBox = document.createElement('span');
                platformBox.className = 'os-info-box';
                platformBox.textContent = osPlatform;
                platformBox.title = osPlatform;
                osInfoDisplay.appendChild(platformBox);
                
                const distBox = document.createElement('span');
                distBox.className = 'os-info-box';
                distBox.textContent = osDistribution;
                distBox.title = osDistribution;
                osInfoDisplay.appendChild(distBox);
                
                // Show the form group and display
                document.getElementById('osInfoFormGroup').style.display = '';
                osInfoDisplay.classList.add('active');
            }
            
            // Update Spec Information Display
            const specInfoDisplay = document.getElementById('specInfoDisplay');
            if (specInfoDisplay) {
                specInfoDisplay.innerHTML = '';
                
                // Box 1: CPU / Memory
                const cpuMemBox = document.createElement('span');
                cpuMemBox.className = 'spec-info-box';
                cpuMemBox.textContent = selectedRecord.cpuInfo;
                cpuMemBox.title = selectedRecord.cpuInfo;
                specInfoDisplay.appendChild(cpuMemBox);
                
                // Box 2: GPU / GPU Memory
                const gpuBox = document.createElement('span');
                gpuBox.className = 'spec-info-box';
                const gpuText = selectedRecord.gpuInfo.includes('/') ? `GPU: ${selectedRecord.gpuInfo}` : `GPU: ${selectedRecord.gpuInfo}`;
                gpuBox.textContent = gpuText;
                gpuBox.title = gpuText;
                specInfoDisplay.appendChild(gpuBox);
                
                // Box 3: Price - Fetch latest price from MC-Insight
                const priceBox = document.createElement('span');
                priceBox.className = 'spec-info-box';
                priceBox.textContent = 'Loading...';
                priceBox.title = 'Fetching latest price';
                specInfoDisplay.appendChild(priceBox);
                
                // Show the form group and display
                document.getElementById('specInfoFormGroup').style.display = '';
                specInfoDisplay.classList.add('active');
                
                // Fetch latest price asynchronously
                (async () => {
                    try {
                        const connInfo = await getConnectionInfo();
                        const priceInfo = await fetchPriceInfoForRecent(connInfo, selectedRecord.Zone, specName);
                        
                        let priceText = '$-';
                        if (priceInfo?.price_per_hour && priceInfo.price_per_hour > 0) {
                            const priceValue = parseFloat(priceInfo.price_per_hour);
                            if (!isNaN(priceValue)) {
                                priceText = `$${priceValue.toFixed(4)}/H`;
                            }
                        }
                        
                        priceBox.textContent = priceText;
                        priceBox.title = priceText;
                    } catch (error) {
                        console.error('Failed to fetch latest price:', error);
                        priceBox.textContent = selectedRecord.priceDisplay || '$-';
                        priceBox.title = 'Failed to fetch latest price';
                    }
                })();
            }
        }
        
        closeVMRecentOverlay();
    }
    
    // Handle Favorite All checkbox change
    async function onFavoriteAllCheckboxChange() {
        const checkbox = document.getElementById('favorite-all-checkbox');
        const isAllMode = checkbox.checked;
        
        // Show loading overlay
        const loadingOverlay = document.getElementById('global-loading-overlay');
        loadingOverlay.style.display = 'flex';
        
        try {
            // Show/hide CSP, Region, Zone columns
            const cspHeader = document.getElementById('favorite-csp-header');
            const regionHeader = document.getElementById('favorite-region-header');
            const zoneHeader = document.getElementById('favorite-zone-header');
            
            if (cspHeader) cspHeader.style.display = isAllMode ? '' : 'none';
            if (regionHeader) regionHeader.style.display = isAllMode ? '' : 'none';
            if (zoneHeader) zoneHeader.style.display = isAllMode ? '' : 'none';
            
            // Resize overlay content
            const overlayContent = document.getElementById('favorite-overlay-content');
            if (overlayContent) {
                overlayContent.style.maxWidth = isAllMode ? '90vw' : '1000px';
            }
            
            if (isAllMode) {
                // Backup current connection data before loading all
                favoriteDataBackup = [...favoriteData];
                // Check mode: Load all data
                await loadVMFavoriteList();
            } else {
                // Uncheck mode: Restore backed up data
                favoriteData = [...favoriteDataBackup];
                favoriteDataBackup = [];
                renderFavoriteTable();
            }
        } finally {
            // Hide loading overlay
            loadingOverlay.style.display = 'none';
        }
    }
    
    // Show VM Favorite Overlay
    async function showVMFavoriteOverlay() {
        // 1. Show loading spinner
        const loadingOverlay = document.getElementById('global-loading-overlay');
        loadingOverlay.style.display = 'flex';
        
        try {
            // 2. Initialize All checkbox state and column visibility
            const checkbox = document.getElementById('favorite-all-checkbox');
            const isAllMode = checkbox?.checked || false;
            
            const cspHeader = document.getElementById('favorite-csp-header');
            const regionHeader = document.getElementById('favorite-region-header');
            const zoneHeader = document.getElementById('favorite-zone-header');
            
            if (cspHeader) cspHeader.style.display = isAllMode ? '' : 'none';
            if (regionHeader) regionHeader.style.display = isAllMode ? '' : 'none';
            if (zoneHeader) zoneHeader.style.display = isAllMode ? '' : 'none';
            
            const overlayContent = document.getElementById('favorite-overlay-content');
            if (overlayContent) {
                overlayContent.style.maxWidth = isAllMode ? '90vw' : '1000px';
            }
            
            // 3. Fetch data
            await loadVMFavoriteList();
            
            // 4. Show overlay
            document.getElementById('vm-favorite-overlay').style.display = 'flex';
            document.addEventListener('keydown', handleVMFavoriteOverlayEsc);
        } catch (error) {
            console.error('Error loading favorite VM data:', error);
            alert('Failed to load favorite VM data: ' + error.message);
        } finally {
            // Hide loading spinner
            loadingOverlay.style.display = 'none';
        }
    }
    
    // Close VM Favorite Overlay
    function closeVMFavoriteOverlay() {
        document.getElementById('vm-favorite-overlay').style.display = 'none';
        document.removeEventListener('keydown', handleVMFavoriteOverlayEsc);
    }

    function handleVMFavoriteOverlayEsc(event) {
        if (event.key === 'Escape') {
            event.stopImmediatePropagation();
            closeVMFavoriteOverlay();
        }
    }
    
    // Load VM Favorite List
    async function loadVMFavoriteList() {
        const loadingMsg = document.querySelector('#favorite-list-container .loading-message');
        const table = document.getElementById('favorite-table');
        const tbody = document.getElementById('favorite-table-body');
        const noDataMsg = document.getElementById('favorite-no-data');
        
        loadingMsg.style.display = 'block';
        table.style.display = 'none';
        noDataMsg.style.display = 'none';
        tbody.innerHTML = '';
        
        try {
            const connInfo = await getConnectionInfo();
            
            // Check if All mode is enabled
            const isAllMode = document.getElementById('favorite-all-checkbox')?.checked || false;
            
            const params = new URLSearchParams({
                CSP: isAllMode ? '' : (connInfo.csp || ''),
                Region: isAllMode ? '' : (connInfo.region || ''),
                Zone: isAllMode ? '' : (connInfo.zone || ''),
                Limit: isAllMode ? '1000' : '100'
            });
            
            const response = await fetch(`/spider/vm/imagespecfavorite?${params}`);
            if (!response.ok) {
                throw new Error('Failed to fetch favorite VM data');
            }
            
            const favoriteList = await response.json();
            loadingMsg.style.display = 'none';
            
            if (!favoriteList || favoriteList.length === 0) {
                noDataMsg.style.display = 'block';
                favoriteData = [];
                return;
            }
            
            // Store data (no MC-Insight API calls needed)
            favoriteData = favoriteList.map(record => ({
                ...record,
                // Use stored metadata or fallback to defaults
                osArch: record.OSArch || '-',
                osPlatform: record.OsPlatform || '-',
                osDistribution: record.OsDistribution || '-',
                cpuInfo: record.CPUInfo || '-',
                gpuInfo: record.GPUInfo || '-',
                priceDisplay: record.PriceInfo || '$-'
            }));
            
            renderFavoriteTable();
        } catch (error) {
            console.error('Error loading favorite VM list:', error);
            loadingMsg.style.display = 'none';
            noDataMsg.textContent = 'Error loading favorite VM data: ' + error.message;
            noDataMsg.style.display = 'block';
        }
    }
    
    // Render Favorite Table
    function renderFavoriteTable() {
        const tbody = document.getElementById('favorite-table-body');
        const table = document.getElementById('favorite-table');
        tbody.innerHTML = '';
        
        const isAllMode = document.getElementById('favorite-all-checkbox')?.checked || false;
        
        // Sort data: existing items first, new items last (in All mode)
        let sortedData = [...favoriteData];
        if (isAllMode && favoriteDataBackup.length > 0) {
            sortedData.sort((a, b) => {
                const keyA = `${a.CSP}|${a.Region}|${a.Zone}|${a.ImageName}|${a.SpecName}`;
                const keyB = `${b.CSP}|${b.Region}|${b.Zone}|${b.ImageName}|${b.SpecName}`;
                const isNewA = !favoriteDataBackup.some(item => 
                    `${item.CSP}|${item.Region}|${item.Zone}|${item.ImageName}|${item.SpecName}` === keyA
                );
                const isNewB = !favoriteDataBackup.some(item => 
                    `${item.CSP}|${item.Region}|${item.Zone}|${item.ImageName}|${item.SpecName}` === keyB
                );
                // Existing items (false) come before new items (true)
                return isNewA - isNewB;
            });
        }
        
        sortedData.forEach((record, i) => {
            const row = document.createElement('tr');
            
            // Check if this is a newly added item (not in backup)
            let isNewItem = false;
            if (isAllMode && favoriteDataBackup.length > 0) {
                const key = `${record.CSP}|${record.Region}|${record.Zone}|${record.ImageName}|${record.SpecName}`;
                isNewItem = !favoriteDataBackup.some(item => 
                    `${item.CSP}|${item.Region}|${item.Zone}|${item.ImageName}|${item.SpecName}` === key
                );
            }
            
            // Apply darker background to new items
            if (isNewItem) {
                row.style.backgroundColor = '#d0d0d0'; // Darker gray background
            }
            
            // Disable row selection in All mode
            if (!isAllMode) {
                row.style.cursor = 'pointer';
                row.onclick = function(e) {
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                        return;
                    }
                    selectFavoriteConfig(record.ImageName, record.SpecName);
                };
            } else {
                row.style.cursor = 'not-allowed';
                row.style.opacity = '0.8';
            }
            
            // Build row HTML based on All mode
            let rowHTML = `<td style="text-align: center;">${i + 1}</td>`;
            
            if (isAllMode) {
                rowHTML += `
                    <td style="text-align: center;">${record.CSP || '-'}</td>
                    <td style="text-align: center;">${record.Region || '-'}</td>
                    <td style="text-align: center;">${record.Zone || '-'}</td>
                `;
            }
            
            rowHTML += `
                <td style="text-align: center; color: #0066cc;">${record.ImageName}</td>
                <td style="text-align: center; color: #0066cc;">${record.SpecName}</td>
                <td>${record.osArch}</td>
                <td>${record.cpuInfo}</td>
                <td>${record.gpuInfo}</td>
                <td>${record.priceDisplay}</td>
                <td>${formatDateTime(record.CreatedAt)}</td>
                <td style="text-align: center;">
                    <button class="select-btn" style="font-size: 14px; padding: 1px 4px; color: #dc3545;" onclick="deleteFavorite(${i})" title="Delete">‚úï</button>
                </td>
            `;
            
            row.innerHTML = rowHTML;
            tbody.appendChild(row);
        });
        
        updateFavoriteTableHeaders();
        table.style.display = 'table';
    }
    
    // Sort favorite table (client-side)
    function sortFavoriteTable(field) {
        if (favoriteSortField === field) {
            favoriteSortOrder = favoriteSortOrder === 'asc' ? 'desc' : 'asc';
        } else {
            favoriteSortField = field;
            favoriteSortOrder = 'desc';
        }
        
        // Client-side sort
        favoriteData.sort((a, b) => {
            let aVal, bVal;
            
            switch(field) {
                case 'csp':
                    aVal = (a.CSP || '').toLowerCase();
                    bVal = (b.CSP || '').toLowerCase();
                    break;
                case 'region':
                    aVal = (a.Region || '').toLowerCase();
                    bVal = (b.Region || '').toLowerCase();
                    break;
                case 'zone':
                    aVal = (a.Zone || '').toLowerCase();
                    bVal = (b.Zone || '').toLowerCase();
                    break;
                case 'image_name':
                    aVal = a.ImageName.toLowerCase();
                    bVal = b.ImageName.toLowerCase();
                    break;
                case 'spec_name':
                    aVal = a.SpecName.toLowerCase();
                    bVal = b.SpecName.toLowerCase();
                    break;
                case 'os_arch':
                    aVal = a.osArch.toLowerCase();
                    bVal = b.osArch.toLowerCase();
                    break;
                case 'cpu':
                    aVal = a.cpuInfo.toLowerCase();
                    bVal = b.cpuInfo.toLowerCase();
                    break;
                case 'gpu':
                    aVal = a.gpuInfo.toLowerCase();
                    bVal = b.gpuInfo.toLowerCase();
                    break;
                case 'price':
                    aVal = a.priceDisplay.toLowerCase();
                    bVal = b.priceDisplay.toLowerCase();
                    break;
                case 'created_at':
                    aVal = new Date(a.CreatedAt).getTime();
                    bVal = new Date(b.CreatedAt).getTime();
                    break;
            }
            
            if (typeof aVal === 'number') {
                return favoriteSortOrder === 'asc' ? aVal - bVal : bVal - aVal;
            } else {
                if (favoriteSortOrder === 'asc') {
                    return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                } else {
                    return aVal < bVal ? 1 : aVal > bVal ? -1 : 0;
                }
            }
        });
        
        updateFavoriteTableHeaders();
        renderFavoriteTable();
    }
    
    // Update Favorite table headers with sort arrows
    function updateFavoriteTableHeaders() {
        const headers = document.querySelectorAll('#favorite-table-header th');
        headers.forEach(header => {
            const onclick = header.getAttribute('onclick');
            if (onclick) {
                const match = onclick.match(/sortFavoriteTable\('([^']+)'\)/);
                if (match) {
                    const field = match[1];
                    const isActive = favoriteSortField === field;
                    const arrow = isActive ? (favoriteSortOrder === 'asc' ? ' ‚ñ≤' : ' ‚ñº') : '';
                    
                    let text = header.textContent.replace(/\s*[‚ñ≤‚ñº]\s*$/, '').trim();
                    header.textContent = text + arrow;
                }
            }
        });
    }
    
    // Select favorite config
    function selectFavoriteConfig(imageName, specName) {
        document.getElementById('imageName').value = imageName;
        document.getElementById('vmSpecName').value = specName;
        
        // Find the selected record from favoriteData
        const selectedRecord = favoriteData.find(record => 
            record.ImageName === imageName && record.SpecName === specName
        );
        
        if (selectedRecord) {
            // Update OS Information Display
            const osInfoDisplay = document.getElementById('osInfoDisplay');
            if (osInfoDisplay) {
                osInfoDisplay.innerHTML = '';
                
                // Use individual fields
                const osArch = selectedRecord.osArch || '-';
                const osPlatform = selectedRecord.osPlatform || '-';
                const osDistribution = selectedRecord.osDistribution || '-';
                
                // Store selected OS Arch globally (only if it has value)
                selectedOSArch = (osArch !== '-') ? osArch : '';
                
                // Create OS info boxes
                const archBox = document.createElement('span');
                archBox.className = 'os-info-box';
                archBox.textContent = osArch;
                archBox.title = osArch;
                osInfoDisplay.appendChild(archBox);
                
                const platformBox = document.createElement('span');
                platformBox.className = 'os-info-box';
                platformBox.textContent = osPlatform;
                platformBox.title = osPlatform;
                osInfoDisplay.appendChild(platformBox);
                
                const distBox = document.createElement('span');
                distBox.className = 'os-info-box';
                distBox.textContent = osDistribution;
                distBox.title = osDistribution;
                osInfoDisplay.appendChild(distBox);
                
                // Show the form group and display
                document.getElementById('osInfoFormGroup').style.display = '';
                osInfoDisplay.classList.add('active');
            }
            
            // Update Spec Information Display
            const specInfoDisplay = document.getElementById('specInfoDisplay');
            if (specInfoDisplay) {
                specInfoDisplay.innerHTML = '';
                
                // Box 1: CPU / Memory
                const cpuMemBox = document.createElement('span');
                cpuMemBox.className = 'spec-info-box';
                cpuMemBox.textContent = selectedRecord.cpuInfo;
                cpuMemBox.title = selectedRecord.cpuInfo;
                specInfoDisplay.appendChild(cpuMemBox);
                
                // Box 2: GPU / GPU Memory
                const gpuBox = document.createElement('span');
                gpuBox.className = 'spec-info-box';
                const gpuText = selectedRecord.gpuInfo.includes('/') ? `GPU: ${selectedRecord.gpuInfo}` : `GPU: ${selectedRecord.gpuInfo}`;
                gpuBox.textContent = gpuText;
                gpuBox.title = gpuText;
                specInfoDisplay.appendChild(gpuBox);
                
                // Box 3: Price - Fetch latest price from MC-Insight
                const priceBox = document.createElement('span');
                priceBox.className = 'spec-info-box';
                priceBox.textContent = 'Loading...';
                priceBox.title = 'Fetching latest price';
                specInfoDisplay.appendChild(priceBox);
                
                // Show the form group and display
                document.getElementById('specInfoFormGroup').style.display = '';
                specInfoDisplay.classList.add('active');
                
                // Fetch latest price asynchronously
                (async () => {
                    try {
                        const connInfo = await getConnectionInfo();
                        const priceInfo = await fetchPriceInfoForRecent(connInfo, selectedRecord.Zone, specName);
                        
                        let priceText = '$-';
                        if (priceInfo?.price_per_hour && priceInfo.price_per_hour > 0) {
                            const priceValue = parseFloat(priceInfo.price_per_hour);
                            if (!isNaN(priceValue)) {
                                priceText = `$${priceValue.toFixed(4)}/H`;
                            }
                        }
                        
                        priceBox.textContent = priceText;
                        priceBox.title = priceText;
                    } catch (error) {
                        console.error('Failed to fetch latest price:', error);
                        priceBox.textContent = selectedRecord.priceDisplay || '$-';
                        priceBox.title = 'Failed to fetch latest price';
                    }
                })();
            }
        }
        
        closeVMFavoriteOverlay();
    }
    
    // Export Favorite Data
    async function exportFavoriteData() {
        const exportAll = document.getElementById('favorite-all-checkbox')?.checked || false;
        
        try {
            let exportData;
            let filenamePrefix = 'cb-spider-favorite-vms';
            
            if (exportAll) {
                // Fetch all favorite data from backend
                const response = await fetch('/spider/vm/imagespecfavorite?Limit=1000');
                if (!response.ok) {
                    throw new Error('Failed to fetch all favorite VM data');
                }
                const allRecords = await response.json();
                
                if (!allRecords || allRecords.length === 0) {
                    alert('No favorite VM data to export');
                    return;
                }
                
                exportData = allRecords.map(record => ({
                    CSP: record.CSP,
                    Region: record.Region,
                    Zone: record.Zone,
                    ImageName: record.ImageName,
                    SpecName: record.SpecName,
                    OSArch: record.OSArch,
                    OsPlatform: record.OsPlatform,
                    OsDistribution: record.OsDistribution,
                    CPUInfo: record.CPUInfo,
                    GPUInfo: record.GPUInfo,
                    PriceInfo: record.PriceInfo,
                    CreatedAt: record.CreatedAt
                }));
                
                filenamePrefix = 'cb-spider-favorite-vms-all';
            } else {
                // Export current view data only
                if (!favoriteData || favoriteData.length === 0) {
                    alert('No favorite VM data to export');
                    return;
                }
                
                exportData = favoriteData.map(record => ({
                    CSP: record.CSP,
                    Region: record.Region,
                    Zone: record.Zone,
                    ImageName: record.ImageName,
                    SpecName: record.SpecName,
                    OSArch: record.OSArch,
                    OsPlatform: record.OsPlatform,
                    OsDistribution: record.OsDistribution,
                    CPUInfo: record.CPUInfo,
                    GPUInfo: record.GPUInfo,
                    PriceInfo: record.PriceInfo,
                    CreatedAt: record.CreatedAt
                }));
            }
            
            // Create JSON file and download
            const jsonStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filenamePrefix}-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (error) {
            alert('Error exporting data: ' + error.message);
        }
    }
    
    // Import Favorite Data
    function importFavoriteData() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'application/json,.json';
        
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const importData = JSON.parse(text);
                
                if (!Array.isArray(importData)) {
                    alert('Invalid JSON format: Expected an array of records');
                    return;
                }
                
                // Auto-detect if this is All data by checking CSP diversity
                const uniqueCSPs = [...new Set(importData.map(r => r.CSP?.toUpperCase()))];
                const isAllData = uniqueCSPs.length > 1;
                
                // Show confirmation message
                const dataType = isAllData ? 'ALL CSPs/Regions' : 'specific CSP/Region';
                const confirmMsg = `Import ${importData.length} record(s) from ${dataType}?\n\nThis will skip duplicates.`;
                
                if (!confirm(confirmMsg)) {
                    return;
                }
                
                // Show loading
                const loadingMsg = document.querySelector('#favorite-list-container .loading-message');
                if (loadingMsg) {
                    loadingMsg.textContent = 'Importing data...';
                    loadingMsg.style.display = 'block';
                }
                
                // Send to backend API
                const response = await fetch('/spider/vm/imagespecfavorite/bulk', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ records: importData })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to import data');
                }
                
                const result = await response.json();
                
                // Hide loading
                if (loadingMsg) {
                    loadingMsg.style.display = 'none';
                }
                
                // Reload the favorite list
                await loadVMFavoriteList();
                
                // Show result message
                alert(`Import completed: ${result.inserted || 0} inserted, ${result.skipped || 0} skipped (duplicates)`);
                
            } catch (error) {
                // Hide loading
                const loadingMsg = document.querySelector('#favorite-list-container .loading-message');
                if (loadingMsg) {
                    loadingMsg.style.display = 'none';
                }
                alert('Error importing data: ' + error.message);
            }
        };
        
        input.click();
    }
    
    // Bulk delete all favorite records
    async function bulkDeleteFavorite(event) {
        event.stopPropagation(); // Prevent header click event
        
        if (!favoriteData || favoriteData.length === 0) {
            alert('No favorite records to delete');
            return;
        }
        
        if (!confirm(`Are you sure you want to delete all ${favoriteData.length} favorite record(s)?`)) {
            return;
        }
        
        const loadingOverlay = document.getElementById('global-loading-overlay');
        loadingOverlay.style.display = 'flex';
        
        try {
            let successCount = 0;
            let errorCount = 0;
            
            // Delete in reverse order to avoid index issues
            for (let i = favoriteData.length - 1; i >= 0; i--) {
                const record = favoriteData[i];
                try {
                    const params = new URLSearchParams({
                        CSP: record.CSP,
                        Region: record.Region,
                        Zone: record.Zone || '',
                        ImageName: record.ImageName,
                        SpecName: record.SpecName
                    });
                    
                    const response = await fetch(`/spider/vm/imagespecfavorite?${params}`, {
                        method: 'DELETE'
                    });
                    
                    if (response.ok) {
                        successCount++;
                        favoriteData.splice(i, 1);
                    } else {
                        errorCount++;
                    }
                } catch (err) {
                    errorCount++;
                }
            }
            
            renderFavoriteTable();
            alert(`Deleted: ${successCount} succeeded, ${errorCount} failed`);
        } catch (error) {
            alert('Error deleting records: ' + error.message);
        } finally {
            loadingOverlay.style.display = 'none';
        }
    }
    
    // Delete favorite
    async function deleteFavorite(index) {
        if (!confirm('Are you sure you want to remove this favorite configuration?')) {
            return;
        }
        
        const record = favoriteData[index];
        
        try {
            const params = new URLSearchParams({
                CSP: record.CSP,
                Region: record.Region,
                Zone: record.Zone,
                ImageName: record.ImageName,
                SpecName: record.SpecName
            });
            
            const response = await fetch(`/spider/vm/imagespecfavorite?${params}`, {
                method: 'DELETE'
            });
            
            if (!response.ok) {
                throw new Error('Failed to delete favorite');
            }
            
            // Remove from local data
            favoriteData.splice(index, 1);
            
            // Re-render table
            renderFavoriteTable();
            
            // If empty, show no data message
            if (favoriteData.length === 0) {
                document.getElementById('favorite-table').style.display = 'none';
                document.getElementById('favorite-no-data').style.display = 'block';
            }
        } catch (error) {
            alert('Error deleting favorite: ' + error.message);
        }
    }
    
    // Format date time
    function formatDateTime(dateStr) {
        if (!dateStr) return '-';
        try {
            const date = new Date(dateStr);
            return date.toLocaleString('en-US', {
                year: 'numeric',
                month: 'short',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        } catch (e) {
            return dateStr;
        }
    }

</script>

</html>
