<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>S3 Manager</title>
<style>
    body { font-family: Arial, sans-serif; font-size: 12px; }
    .fixed-header { position: fixed; top: 0; width: 97%; background: #fff; z-index: 1000; display: flex; justify-content: space-between; padding: 10px 20px; align-items: center; box-shadow: 0 4px 6px -6px #222; }
    .header-container { display: flex; align-items: flex-end; }
    .header-container img { margin-right: 10px; height: 28px; }
    .header-container h1 { font-size: 16px; margin: 0; }
    .searchContainer { position: relative; display: flex; align-items: center; padding-left: 0.5cm; }
    #searchInput { width: 190px; font-family: Arial, sans-serif; padding-right: 2.5cm; }
    #clearSearch { position: absolute; right: 0.1cm; top: 50%; transform: translateY(-50%); border: none; background: transparent; cursor: pointer; }
    .fixed-action-buttons { display: flex; align-items: center; }
    .fixed-action-buttons button { margin-left: 10px; }
    .header-with-progress { display: flex; align-items: center; margin-bottom: 0px; }
    .progress-bar-container { width: 600px; margin-left: 10px; margin-bottom: 0px; margin-top: 10px; height: 22px; background: #f0f5ff; border-radius: 4px; overflow: hidden; display: none; position: relative; z-index: 2000; }
    .progress-bar { width: 0; height: 100%; background: #cce6ff; border-radius: 4px; transition: width 2s ease; }
    #timeDisplay { position: absolute; top: 50%; right: 10px; transform: translateY(-50%); font-size: 14px; color: #333; z-index: 30; }
    .add-button { font-size: 14px; font-weight: bold; margin-left: 1px; margin-right: 5px; margin-bottom: 10px; margin-top: 20px; }
    .content { margin-top: 50px; }
    table { width: 100%; border-collapse: collapse; table-layout: fixed; margin-bottom: 0; }
    th, td { border: 1px solid #aaa; padding: 6px; position: relative; }
    th { background: #f2f2f2; font-size: 14px; text-align: center; }
    td { text-align: left; }
    .column-num { width: 5%; text-align: center; }
    .check-column { width: 5%; text-align: center; }
    .bucket-name-cell, .object-key-cell { font-weight: bold; }
    .bucket-name-cell.selected { color: blue; }
    .center-align { text-align: center; }
    .highlight { background: #fffab6; }
    .overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 1000; }
    .overlay-content { background: #fff; padding: 20px; border-radius: 5px; text-align: left; font-size: 12px; min-width: 300px; }
    .overlay-close-btn {
        background-color: #f0f0f0;
        color: #d9534f;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        position: absolute;
        top: 10px;
        right: 10px;
    }
    .overlay-close-btn:hover {
        background-color: #e0e0e0;
    }
    .object-detail-table th, .object-detail-table td { border: 1px solid #ddd; }
    .object-detail-table th { width: 110px; }
    .progress-bar { transition: width 1.5s ease; }
    #object-panel { margin-top: 20px; margin-left: 40px; }
    .object-panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0px; }
    .object-panel-header h2 { margin: 0; }
    .object-panel-actions { display: flex; align-items: center; }
    
    /* Object Versions Table Styling */
    .object-versions-table { width: 100%; border-collapse: collapse; margin-top: 10px; table-layout: fixed; }
    .object-versions-table th { border: 1px solid #ddd; padding: 8px; text-align: center; background: #f2f2f2; }
    .object-versions-table td { border: 1px solid #ddd; padding: 8px; word-wrap: break-word; overflow-wrap: break-word; }
    .object-versions-table td:first-child { text-align: left; }
    .object-versions-table td:not(:first-child) { text-align: center; }
    
    /* Versioning column styling */
    .versioning-enabled { color: #28a745; font-weight: bold; }
    .versioning-suspended { color: #000000; font-weight: bold; }
    .versioning-error { color: #ffc107; font-weight: bold; }
    .versioning-toggle { cursor: pointer; }
    
    /* Toggle button styling */
    .versioning-toggle-btn {
        width: 32px;
        height: 16px;
        border-radius: 16px;
        border: none;
        cursor: pointer;
        position: relative;
        transition: all 0.3s ease;
        display: inline-block;
        margin-right: 8px;
        vertical-align: middle;
    }
    
    .versioning-toggle-btn.enabled {
        background: #28a745;
    }
    
    .versioning-toggle-btn.suspended {
        background: #6c757d;
    }
    
    .versioning-toggle-btn.error {
        background: #ffc107;
    }
    
    .versioning-toggle-btn::after {
        content: '';
        position: absolute;
        top: 2px;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: white;
        transition: all 0.3s ease;
    }
    
    .versioning-toggle-btn.enabled::after {
        right: 2px;
    }
    
    .versioning-toggle-btn.suspended::after {
        left: 2px;
    }
    
    .versioning-toggle-btn.error::after {
        left: 2px;
    }
    
    /* CORS toggle button styling */
    .cors-toggle-btn {
        width: 32px;
        height: 16px;
        border-radius: 16px;
        border: none;
        cursor: pointer;
        position: relative;
        transition: all 0.3s ease;
        display: inline-block;
        margin-right: 8px;
        vertical-align: middle;
    }
    
    .cors-toggle-btn.configured {
        background: #17a2b8;
    }
    
    .cors-toggle-btn.not-configured {
        background: #6c757d;
    }
    
    .cors-toggle-btn::after {
        content: '';
        position: absolute;
        top: 2px;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: white;
        transition: all 0.3s ease;
    }
    
    .cors-toggle-btn.configured::after {
        right: 2px;
    }
    
    .cors-toggle-btn.not-configured::after {
        left: 2px;
    }
    
    /* CORS status styling */
    .cors-configured { color: #17a2b8; font-weight: bold; cursor: pointer; text-decoration: underline; }
    .cors-not-configured { color: #6c757d; font-weight: bold; }
    .cors-toggle { cursor: pointer; }
</style>
</head>
<body>
    <div class="fixed-header">
        <div class="header-container">
            <img src="/spider/adminweb/images/left-menu/s3.png" alt="S3 Icon">
            <h1>S3 Manager</h1>
            <div class="searchContainer">
                <input type="text" id="searchInput" onkeyup="searchKeyword()" placeholder="Search Bucket or Object...">
                <button id="clearSearch" onclick="clearSearchInput()">X</button>
            </div>
        </div>
    </div>

    <div class="content">
        <div class="header-with-progress">
            <button onclick="showBucketCreateOverlay()" class="add-button">+ Bucket</button>
            <div class="progress-bar-container" id="progressBarContainer">
                <div class="progress-bar" id="progressBar"></div>
                <span id="timeDisplay"></span>
            </div>
            <div style="flex: 1;"></div>
            <div class="fixed-action-buttons">
                <input type="checkbox" onclick="toggleSelectAll(this, 'bucket')">
                <button onclick="deleteSelectedBuckets()" style="margin-left: 10px;">Delete</button>
            </div>
        </div>

        {{if .ErrorMessage}}
        <script>
            // Show error popup when page loads
            window.addEventListener('DOMContentLoaded', function() {
                alert('‚ö†Ô∏è S3 Connection Error:\n\n{{.ErrorMessage}}');
            });
        </script>
        {{end}}

        <table id="bucket-table">
            <thead>
                <tr>
                    <th class="column-num">#</th>
                    <th class="center-align bucket-name-cell">Bucket Name</th>
                    <th class="center-align">Created</th>
                    <th class="center-align">Versioning</th>
                    <th class="center-align">CORS</th>
                    <th class="center-align">Actions</th>
                    <th class="check-column"><input type="checkbox" onclick="toggleSelectAll(this, 'bucket')"></th>
                </tr>
            </thead>
            <tbody id="bucket-list-body">
                {{range $i, $b := .Buckets}}
                <tr>
                    <td class="column-num">{{$i | inc}}</td>
                    <td class="bucket-name-cell" id="bucket-{{$b.Name}}"><span style="cursor:pointer;" onclick="showObjectPanel('{{$b.Name}}')">{{$b.Name}}</span></td>
                    <td class="center-align" data-utc-time="{{$b.CreationDate}}">{{$b.CreationDate}}</td>
                    <td class="center-align">
                        <div class="versioning-toggle" onclick="toggleVersioningQuick('{{$b.Name}}', '{{$b.VersioningStatus}}')">
                            <button class="versioning-toggle-btn {{if eq $b.VersioningStatus "Enabled"}}enabled{{else if eq $b.VersioningStatus "Suspended"}}suspended{{else}}error{{end}}" 
                                    type="button"></button>
                            <span class="versioning-{{if eq $b.VersioningStatus "Enabled"}}enabled{{else if eq $b.VersioningStatus "Suspended"}}suspended{{else}}error{{end}}">
                                {{$b.VersioningStatus}}
                            </span>
                        </div>
                    </td>
                    <td class="center-align">
                        <div class="cors-toggle" onclick="toggleCORSQuick('{{$b.Name}}', '{{$b.CORSStatus}}')">
                            <button class="cors-toggle-btn {{if eq $b.CORSStatus "Configured"}}configured{{else}}not-configured{{end}}" 
                                    type="button"></button>
                            <span class="cors-{{if eq $b.CORSStatus "Configured"}}configured{{else}}not-configured{{end}}" 
                                  {{if eq $b.CORSStatus "Configured"}}onclick="showCORSInfo('{{$b.Name}}')"{{end}}>
                                {{$b.CORSStatus}}
                            </span>
                        </div>
                    </td>
                    <td class="center-align">
                        <button onclick="deleteBucket('{{$b.Name}}')">Delete</button>
                    </td>
                    <td class="check-column"><input type="checkbox" name="bucket-checkbox" value="{{$b.Name}}"></td>
                </tr>
                {{end}}
            </tbody>
        </table>

        <div id="object-panel" style="display:none;">
            <div class="header-with-progress">
                <button onclick="showObjectUploadOverlay()" class="add-button">+ Object</button>
                <button onclick="showObjectVersions()" class="add-button" style="margin-left: 10px;">Versions</button>
                <div style="flex: 1;"></div>
                <div class="object-panel-actions">
                    <input type="checkbox" onclick="toggleSelectAll(this, 'object')">
                    <button onclick="deleteSelectedObjects()" style="margin-left: 10px;">Delete</button>
                </div>
            </div>
            <table id="object-table">
                <thead>
                    <tr>
                        <th class="column-num">#</th>
                        <th class="center-align">Object Key</th>
                        <th class="center-align">Size</th>
                        <th class="center-align">Last Modified</th>
                        <th class="center-align">Actions</th>
                        <th class="check-column"><input type="checkbox" onclick="toggleSelectAll(this, 'object')"></th>
                    </tr>
                </thead>
                <tbody id="object-list-body">
                </tbody>
            </table>
        </div>
    </div>

    <div id="bucket-create-overlay" class="overlay">
        <div class="overlay-content" style="position:relative;">
            <button class="overlay-close-btn" onclick="hideBucketCreateOverlay()">X</button>
            <h2>Create New Bucket</h2>
            <form id="bucket-create-form" onsubmit="event.preventDefault(); createBucket();">
                <div>
                    <label>Bucket Name:</label>
                    <input type="text" id="new-bucket-name" required>
                </div>
                <div style="margin-top:20px; text-align:center;">
                    <button type="submit">Create</button>
                    <button type="button" onclick="hideBucketCreateOverlay()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <div id="object-upload-overlay" class="overlay">
        <div class="overlay-content" style="position:relative; width: 400px;">
            <button class="overlay-close-btn" onclick="hideObjectUploadOverlay()">X</button>
            <h2>Upload Objects to <span id="upload-bucket-name"></span></h2>
            <form id="object-upload-form" onsubmit="event.preventDefault(); uploadFiles();">
                <div style="margin-bottom: 15px;">
                    <label>Select Files:</label>
                    <input type="file" id="file-input" multiple required style="margin-top: 5px;">
                </div>
                <div id="selected-files-list" style="margin-bottom: 15px; max-height: 200px; overflow-y: auto;">No files selected</div>
                <div id="upload-progress" style="display: none; margin-bottom: 15px;">
                    <div style="margin-bottom: 5px;">Uploading: <span id="current-file"></span></div>
                    <div style="background: #f0f0f0; height: 20px; border-radius: 4px; overflow: hidden;">
                        <div id="progress-bar-inner" style="background: #4CAF50; height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div style="margin-top: 5px; font-size: 11px;">Progress: <span id="progress-text">0%</span></div>
                </div>
                <div style="text-align:center;">
                    <button type="submit" id="upload-btn">Upload</button>
                    <button type="button" onclick="showUploadURLOverlay()">Get Upload URL</button>
                    <button type="button" onclick="hideObjectUploadOverlay()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <div id="object-detail-overlay" class="overlay">
        <div class="overlay-content" style="position:relative; width: 500px;">
            <button class="overlay-close-btn" onclick="hideObjectDetailOverlay()">X</button>
            <h2>Object Detail: <span id="object-detail-key"></span></h2>
            <table class="object-detail-table" style="width:100%;">
                <tbody id="object-detail-body">
                </tbody>
            </table>
        </div>
    </div>
    
    <div id="cors-info-overlay" class="overlay">
        <div class="overlay-content" style="position:relative; width: 700px; max-height: 80vh;">
            <button class="overlay-close-btn" onclick="hideCORSInfoOverlay()">X</button>
            <h2>CORS Configuration: <span id="cors-bucket-name"></span></h2>
            
            <div style="max-height: 60vh; overflow-y: auto; padding: 10px; background: #f8f9fa; border-radius: 4px; border: 1px solid #dee2e6;">
                <pre id="cors-json-content" style="margin: 0; font-family: 'Courier New', monospace; font-size: 12px; white-space: pre-wrap; word-wrap: break-word;"></pre>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button onclick="hideCORSInfoOverlay()">Close</button>
            </div>
        </div>
    </div>

    <div id="upload-url-overlay" class="overlay">
        <div class="overlay-content" style="position:relative; width: 600px;">
            <button class="overlay-close-btn" onclick="hideUploadURLOverlay()">X</button>
            <h2>Generate Upload URL for: <span id="upload-url-bucket-name"></span></h2>
            
            <div style="margin-bottom: 15px;">
                <label>Object Key (filename):</label>
                <input type="text" id="upload-object-key" placeholder="Enter object key/filename" style="width: 100%; margin-top: 5px; padding: 8px;">
            </div>
            
            <div style="margin-bottom: 15px;">
                <label>Expiration (hours):</label>
                <input type="number" id="upload-expiration-hours" value="1" min="1" max="168" style="margin-left: 10px; width: 80px;">
            </div>
            
            <div style="text-align: center; margin-bottom: 15px;">
                <button onclick="generateUploadURLAction()">Generate Upload URL</button>
            </div>
            
            <div id="upload-url-result" style="display: none;">
                <label>Presigned Upload URL:</label>
                <textarea id="upload-url-text" readonly style="width: 100%; height: 100px; margin-top: 5px;"></textarea>
                <div style="margin-top: 10px; text-align: center;">
                    <button onclick="copyUploadURL()" style="margin-right: 10px;">Copy URL</button>
                    <button onclick="testUploadURL()">Test Upload</button>
                </div>
                <div id="upload-instructions" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px; font-size: 12px;">
                    <strong>How to use this Upload URL:</strong><br>
                    Use HTTP PUT request to upload file directly to S3:<br>
                    <code>curl -X PUT -T "your-file" "the-presigned-url"</code>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 15px;">
                <button onclick="hideUploadURLOverlay()">Close</button>
            </div>
        </div>
    </div>

    <div id="presigned-url-overlay" class="overlay">
        <div class="overlay-content" style="position:relative; width: 500px;">
            <button class="overlay-close-btn" onclick="hidePresignedURLOverlay()">X</button>
            <h2>Share Object: <span id="presigned-object-key"></span></h2>
            
            <div style="margin-bottom: 15px;">
                <label>Expiration (hours):</label>
                <input type="number" id="expiration-hours" value="1" min="1" max="168" style="margin-left: 10px; width: 80px;">
            </div>

            <div style="margin-bottom: 15px;">
                <button onclick="generatePresignedURLAction()">Generate Download URL</button>
            </div>

            <div id="presigned-url-result" style="display: none;">
                <label>Download URL:</label>
                <textarea id="presigned-url-text" readonly style="width: 100%; height: 100px; margin-top: 5px;"></textarea>
                <button onclick="copyPresignedURL()" style="margin-top: 10px;">Copy URL</button>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <button onclick="hidePresignedURLOverlay()">Close</button>
            </div>
        </div>
    </div>

    <div id="object-versions-overlay" class="overlay">
        <div class="overlay-content" style="position:relative; width: 1100px; max-width: 95vw; max-height: 80vh; overflow-y: auto;">
            <button class="overlay-close-btn" onclick="hideObjectVersionsOverlay()">X</button>
            <h2>Object Versions in: <span id="versions-bucket-name"></span></h2>
            
            <div style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; font-size: 13px;">
                <strong>Note:</strong> Versioning-enabled buckets cannot be deleted until all object versions and delete markers are removed.
                <br>Use the "Delete" buttons below or "Empty Bucket" to clean up before deleting the bucket.
            </div>
            
            <div style="display: flex; justify-content: flex-end; margin-bottom: 10px;">
                <button onclick="deleteAllVersions(document.getElementById('versions-bucket-name').textContent)" 
                        style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; font-weight: bold; cursor: pointer;">
                    üóÇÔ∏è Empty Bucket
                </button>
            </div>
            
            <table class="object-versions-table">
                <thead>
                    <tr>
                        <th style="width: 30%;">Object Key</th>
                        <th style="width: 25%;">Version ID</th>
                        <th style="width: 10%;">Size</th>
                        <th style="width: 15%;">Last Modified</th>
                        <th style="width: 6%;">Latest</th>
                        <th style="width: 14%;">Actions</th>
                    </tr>
                </thead>
                <tbody id="object-versions-body">
                </tbody>
            </table>

            <div style="text-align: center; margin-top: 20px;">
                <button onclick="hideObjectVersionsOverlay()">Close</button>
            </div>
        </div>
    </div>

<script>
const connConfig = "{{.ConnectionConfig}}";

function showProgressBar() {
    const bar = document.getElementById('progressBar');
    const cont = document.getElementById('progressBarContainer');
    bar.style.width = '0%'; cont.style.display = 'block';
    setTimeout(() => { bar.style.width = '100%'; }, 50);
}
function hideProgressBar() {
    setTimeout(() => {
        document.getElementById('progressBarContainer').style.display = 'none';
        document.getElementById('timeDisplay').textContent = '';
    }, 500);
}

function createBucket() {
    const name = document.getElementById('new-bucket-name').value.trim();
    if (!name) return alert('Bucket name required!');
    showProgressBar();
    
    fetch(`/spider/s3/${name}?ConnectionName=${connConfig}`, {
        method: 'PUT'
    })
    .then(response => {
        if (response.ok) {
            hideBucketCreateOverlay(); 
            location.reload();
        } else {
            // Parse error response body (XML or JSON)
            return response.text().then(errorText => {
                if (errorText.includes('<?xml') || errorText.includes('<Error>')) {
                    // Parse S3 XML error response
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(errorText, 'text/xml');
                    const errorCode = xmlDoc.getElementsByTagName('Code')[0]?.textContent || 'Unknown';
                    const errorMessage = xmlDoc.getElementsByTagName('Message')[0]?.textContent || errorText;
                    throw new Error(`${errorCode}: ${errorMessage}`);
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            });
        }
    })
    .catch(e => { 
        alert('Error: ' + e.message); 
        hideProgressBar(); 
    });
}

function toggleVersioningQuick(bucketName, currentStatus) {
    const newStatus = currentStatus === 'Enabled' ? 'Suspended' : 'Enabled';
    
    if (!confirm(`Change versioning for bucket "${bucketName}" from "${currentStatus}" to "${newStatus}"?`)) {
        return;
    }
    
    showProgressBar();
    
    const versioningXml = `<?xml version="1.0" encoding="UTF-8"?>
<VersioningConfiguration>
    <Status>${newStatus}</Status>
</VersioningConfiguration>`;

    const url = `/spider/s3/${bucketName}?versioning&ConnectionName=${connConfig}`;
    
    fetch(url, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/xml',
            'X-Connection-Name': connConfig
        },
        body: versioningXml
    })
    .then(response => {
        hideProgressBar();
        if (response.ok) {
            // Save current bucket to sessionStorage before reload
            if (currentBucket) {
                sessionStorage.setItem('cb-spider-selected-bucket', currentBucket);
                sessionStorage.setItem('cb-spider-selected-prefix', currentPrefix || '');
            }
            location.reload();
        } else {
            return response.text().then(responseText => {
                if (responseText.includes('<e>')) {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(responseText, 'text/xml');
                    const errorCode = xmlDoc.getElementsByTagName('Code')[0]?.textContent || 'Unknown';
                    const errorMessage = xmlDoc.getElementsByTagName('Message')[0]?.textContent || responseText;
                    throw new Error(`${errorCode}: ${errorMessage}`);
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            });
        }
    })
    .catch(error => {
        hideProgressBar();
        alert('Error toggling versioning: ' + error.message);
    });
}

function toggleCORSQuick(bucketName, currentStatus) {
    if (currentStatus === 'Configured') {
        // Ask user what they want to do: view config or delete CORS
        const action = confirm(`CORS is currently configured for bucket "${bucketName}".\n\nClick OK to DISABLE CORS, or Cancel to VIEW current configuration.`);
        
        if (action) {
            // User wants to disable CORS
            if (!confirm(`Are you sure you want to disable CORS for bucket "${bucketName}"?`)) {
                return;
            }
            
            showProgressBar();
            
            // Delete CORS configuration
            fetch(`/spider/s3/${bucketName}?cors&ConnectionName=${connConfig}`, {
                method: 'DELETE'
            })
            .then(response => {
                hideProgressBar();
                if (response.ok) {
                    // Save current bucket to sessionStorage before reload
                    if (currentBucket) {
                        sessionStorage.setItem('cb-spider-selected-bucket', currentBucket);
                        sessionStorage.setItem('cb-spider-selected-prefix', currentPrefix || '');
                    }
                    location.reload();
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            })
            .catch(error => {
                hideProgressBar();
                alert('Error disabling CORS: ' + error.message);
            });
        } else {
            // User wants to view current configuration
            if (typeof event !== 'undefined') {
                event.stopPropagation();
            }
            showCORSInfo(bucketName);
        }
        return;
    }
    
    if (!confirm(`Enable CORS for bucket "${bucketName}"?`)) {
        return;
    }
    
    showProgressBar();
    
    const corsXml = `<?xml version="1.0" encoding="UTF-8"?>
<CORSConfiguration>
    <CORSRule>
        <AllowedOrigin>*</AllowedOrigin>
        <AllowedMethod>GET</AllowedMethod>
        <AllowedMethod>PUT</AllowedMethod>
        <AllowedMethod>POST</AllowedMethod>
        <AllowedMethod>DELETE</AllowedMethod>
        <AllowedMethod>HEAD</AllowedMethod>
        <AllowedHeader>*</AllowedHeader>
        <ExposeHeader>ETag</ExposeHeader>
        <ExposeHeader>x-amz-server-side-encryption</ExposeHeader>
        <ExposeHeader>x-amz-request-id</ExposeHeader>
        <ExposeHeader>x-amz-id-2</ExposeHeader>
        <MaxAgeSeconds>3600</MaxAgeSeconds>
    </CORSRule>
</CORSConfiguration>`;

    fetch(`/spider/s3/${bucketName}?cors&ConnectionName=${connConfig}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/xml'
        },
        body: corsXml
    })
    .then(response => {
        hideProgressBar();
        if (response.ok) {
            // Save current bucket to sessionStorage before reload
            if (currentBucket) {
                sessionStorage.setItem('cb-spider-selected-bucket', currentBucket);
                sessionStorage.setItem('cb-spider-selected-prefix', currentPrefix || '');
            }
            location.reload();
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
    })
    .catch(error => {
        hideProgressBar();
        alert('Error enabling CORS: ' + error.message);
    });
}

function deleteBucket(name, forceDelete = false) {
    if (!forceDelete && !confirm(`Delete bucket "${name}"?\n\nWarning: The bucket must be empty before it can be deleted. If the bucket contains objects, the deletion will fail.`)) return;
    showProgressBar();
    
    const url = forceDelete 
        ? `/spider/s3/${name}?force=true&ConnectionName=${connConfig}`
        : `/spider/s3/${name}?ConnectionName=${connConfig}`;
    
    fetch(url, { 
        method: 'DELETE',
        headers: {
            'X-Connection-Name': connConfig
        }
    })
    .then(response => {
        if (response.ok) {
            location.reload();
        } else {
            return response.text().then(errorText => {
                if (errorText.includes('<?xml') || errorText.includes('<Error>')) {
                    try {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(errorText, 'text/xml');
                        const errorCode = xmlDoc.getElementsByTagName('Code')[0]?.textContent || 'Unknown';
                        const errorMessage = xmlDoc.getElementsByTagName('Message')[0]?.textContent || 'Unknown error';
                        
                        if (errorCode === 'BucketNotEmpty') {
                            throw new Error(`Cannot delete bucket "${name}": The bucket is not empty.\n\nPlease delete all objects in the bucket first, then try again.`);
                        } else if (errorCode === 'NoSuchBucket') {
                            // Check if this is a metadata-only bucket
                            if (errorMessage.includes('metadata exists') || errorMessage.includes('Use force=true')) {
                                hideProgressBar();
                                if (confirm(`Bucket "${name}" not found in CSP, but metadata exists.\n\nDo you want to force delete the metadata only?`)) {
                                    deleteBucket(name, true);
                                }
                                return;
                            }
                            throw new Error(`Bucket "${name}" does not exist.`);
                        } else if (errorCode === 'AccessDenied') {
                            throw new Error(`Access denied: You don't have permission to delete bucket "${name}".`);
                        } else {
                            throw new Error(`${errorCode}: ${errorMessage}`);
                        }
                    } catch (parseError) {
                        if (parseError.message.includes('Cannot delete bucket')) {
                            throw parseError;
                        }
                        throw new Error(`HTTP ${response.status}: ${errorText}`);
                    }
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorText}`);
                }
            });
        }
    })
    .catch(e => { 
        alert('Error: ' + e.message); 
        hideProgressBar(); 
    });
}

function disableCORS(bucketName) {
    if (!confirm(`Disable CORS for bucket "${bucketName}"?`)) {
        return;
    }
    
    showProgressBar();
    
    fetch(`/spider/s3/${bucketName}?cors&ConnectionName=${connConfig}`, {
        method: 'DELETE'
    })
    .then(response => {
        hideProgressBar();
        if (response.ok) {
            location.reload();
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
    })
    .catch(error => {
        hideProgressBar();
        alert('Error disabling CORS: ' + error.message);
    });
}

function showCORSInfo(bucketName) {
    document.getElementById('cors-bucket-name').textContent = bucketName;
    document.getElementById('cors-info-overlay').style.display = 'flex';
    document.getElementById('cors-json-content').textContent = 'Loading...';
    
    fetch(`/spider/s3/${bucketName}?cors&ConnectionName=${connConfig}`)
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.text();
    })
    .then(corsXml => {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(corsXml, 'text/xml');
        
        const corsRules = xmlDoc.getElementsByTagName('CORSRule');
        const corsData = {
            CORSRules: []
        };
        
        for (let i = 0; i < corsRules.length; i++) {
            const rule = corsRules[i];
            const corsRule = {
                AllowedOrigin: [],
                AllowedMethod: [],
                AllowedHeader: [],
                ExposeHeader: [],
                MaxAgeSeconds: null
            };
            
            const origins = rule.getElementsByTagName('AllowedOrigin');
            for (let j = 0; j < origins.length; j++) {
                corsRule.AllowedOrigin.push(origins[j].textContent);
            }
            
            const methods = rule.getElementsByTagName('AllowedMethod');
            for (let j = 0; j < methods.length; j++) {
                corsRule.AllowedMethod.push(methods[j].textContent);
            }
            
            const headers = rule.getElementsByTagName('AllowedHeader');
            for (let j = 0; j < headers.length; j++) {
                corsRule.AllowedHeader.push(headers[j].textContent);
            }
            
            const exposeHeaders = rule.getElementsByTagName('ExposeHeader');
            for (let j = 0; j < exposeHeaders.length; j++) {
                corsRule.ExposeHeader.push(exposeHeaders[j].textContent);
            }
            
            const maxAge = rule.getElementsByTagName('MaxAgeSeconds')[0];
            if (maxAge) {
                corsRule.MaxAgeSeconds = parseInt(maxAge.textContent);
            }
            
            corsData.CORSRules.push(corsRule);
        }
        
        document.getElementById('cors-json-content').textContent = JSON.stringify(corsData, null, 2);
        document.addEventListener('keydown', handleCORSInfoEsc);
    })
    .catch(error => {
        document.getElementById('cors-json-content').textContent = `Error loading CORS configuration: ${error.message}`;
    });
}

function hideCORSInfoOverlay() {
    document.getElementById('cors-info-overlay').style.display = 'none';
    document.getElementById('cors-json-content').textContent = '';
    document.removeEventListener('keydown', handleCORSInfoEsc);
}

function handleCORSInfoEsc(event) {
    if (event.key === 'Escape') {
        hideCORSInfoOverlay();
    }
}

function showBucketCreateOverlay() { 
    const region = '{{.RegionName}}'.toLowerCase();
    const bucketNameInput = document.getElementById('new-bucket-name');
    bucketNameInput.value = `${region}-bucket-${Math.random().toString(36).substring(2, 8)}`;
    document.getElementById('bucket-create-overlay').style.display = 'flex';
    document.addEventListener('keydown', handleBucketCreateEsc);
}

function handleBucketCreateEsc(event) {
    if (event.key === 'Escape') {
        hideBucketCreateOverlay();
    }
}

function hideBucketCreateOverlay() { 
    document.getElementById('bucket-create-overlay').style.display = 'none';
    document.removeEventListener('keydown', handleBucketCreateEsc);
    const region = '{{.RegionName}}'.toLowerCase();
    const bucketNameInput = document.getElementById('new-bucket-name');
    bucketNameInput.value = `${region}-bucket-${Math.random().toString(36).substring(2, 8)}`;
}

function deleteSelectedBuckets() {
    const checked = document.querySelectorAll('input[name="bucket-checkbox"]:checked');
    if (!checked.length) {
        alert("Select bucket(s) to delete!");
        return;
    }
    
    const bucketNames = Array.from(checked).map(chk => chk.value).join(', ');
    if (!confirm(`Delete selected bucket(s): ${bucketNames}?\n\nWarning: All buckets must be empty before they can be deleted.`)) {
        return;
    }
    
    showProgressBar();
    
    const deletePromises = Array.from(checked).map(chk => {
        const bucketName = chk.value;
        return fetch(`/spider/s3/${bucketName}?ConnectionName=${connConfig}`, { 
            method: 'DELETE',
            headers: {
                'X-Connection-Name': connConfig
            }
        }).then(response => {
            if (!response.ok) {
                return response.text().then(errorText => {
                    if (errorText.includes('BucketNotEmpty')) {
                        return { bucket: bucketName, error: 'Bucket is not empty' };
                    } else if (errorText.includes('NoSuchBucket')) {
                        // Check if metadata exists
                        if (errorText.includes('metadata exists') || errorText.includes('Use force=true')) {
                            return { bucket: bucketName, error: 'Not found in CSP', needsForce: true };
                        }
                        return { bucket: bucketName, error: 'Bucket does not exist' };
                    } else if (errorText.includes('AccessDenied')) {
                        return { bucket: bucketName, error: 'Access denied' };
                    } else {
                        return { bucket: bucketName, error: `HTTP ${response.status}` };
                    }
                });
            }
            return { bucket: bucketName, success: true };
        }).catch(error => {
            return { bucket: bucketName, error: 'Network error' };
        });
    });
    
    Promise.all(deletePromises).then(results => {
        hideProgressBar();
        
        const successes = results.filter(r => r.success);
        const failures = results.filter(r => r.error);
        const needsForce = results.filter(r => r.needsForce);
        
        if (failures.length > 0) {
            let message = `Deletion completed:\n\n`;
            if (successes.length > 0) {
                message += `Successfully deleted: ${successes.map(s => s.bucket).join(', ')}\n\n`;
            }
            message += `Failed to delete:\n`;
            failures.forEach(f => {
                message += `- ${f.bucket}: ${f.error}\n`;
            });
            alert(message);
            
            // Handle buckets that need force delete
            if (needsForce.length > 0) {
                const forceList = needsForce.map(f => f.bucket).join(', ');
                if (confirm(`The following bucket(s) not found in CSP but metadata exists:\n${forceList}\n\nDo you want to force delete the metadata?`)) {
                    showProgressBar();
                    const forceDeletePromises = needsForce.map(item => {
                        return fetch(`/spider/s3/${item.bucket}?force=true&ConnectionName=${connConfig}`, {
                            method: 'DELETE',
                            headers: { 'X-Connection-Name': connConfig }
                        });
                    });
                    Promise.all(forceDeletePromises).then(() => {
                        hideProgressBar();
                        location.reload();
                    }).catch(e => {
                        hideProgressBar();
                        alert('Error during force deletion: ' + e.message);
                        location.reload();
                    });
                    return;
                }
            }
        }
        
        location.reload();
    }).catch(e => { 
        alert('Error during bulk deletion: ' + e.message); 
        hideProgressBar(); 
    });
}

let currentBucket = null;
let currentPrefix = "";

function showObjectPanel(bucket, prefix = "") {
    currentBucket = bucket;
    currentPrefix = prefix;
    
    console.log(`Showing object panel for bucket: ${bucket}, prefix: ${prefix}`);
    
    // Clear previous selection
    document.querySelectorAll('.bucket-name-cell').forEach(el => el.classList.remove('selected'));
    
    // Highlight selected bucket
    const bucketElement = document.getElementById(`bucket-${bucket}`);
    if (bucketElement) {
        bucketElement.classList.add('selected');
    }
    
    // Show object panel
    document.getElementById('object-panel').style.display = 'block';
    
    // Update panel header
    updateObjectPanelHeader(bucket, prefix);
    
    // Fetch and display objects
    fetchObjects(bucket, prefix);
}

function updateObjectPanelHeader(bucket, prefix) {
    let header = document.querySelector('.object-panel-header h2');
    if (!header) {
        const panelHeader = document.querySelector('.object-panel-header');
        if (panelHeader) {
            const h2 = document.createElement('h2');
            h2.style.margin = '0';
            panelHeader.insertBefore(h2, panelHeader.firstChild);
            header = h2;
        }
    }
    
    if (header) {
        if (prefix && prefix !== "") {
            header.innerHTML = `
                Objects in: <strong>${bucket}</strong>/${prefix}
                <button onclick="showObjectPanel('${bucket}', '')" style="margin-left: 10px; font-size: 12px;">üìÅ Root</button>
            `;
        } else {
            header.innerHTML = `Objects in: <strong>${bucket}</strong>`;
        }
    }
}

function fetchObjects(bucket, prefix = "") {
    console.log(`Fetching objects for bucket: ${bucket}, prefix: ${prefix}`);
    
    let url = `/spider/s3/${bucket}?delimiter=/&ConnectionName=${connConfig}`;
    if (prefix && prefix !== "") {
        url += `&prefix=${encodeURIComponent(prefix)}`;
    }
    
    console.log(`Request URL: ${url}`);
    
    fetch(url)
        .then(response => {
            console.log(`Response status: ${response.status} ${response.statusText}`);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            return response.text();
        })
        .then(xmlData => {
            console.log(`Response XML length: ${xmlData.length}`);
            console.log(`Response XML preview: ${xmlData.substring(0, 500)}`);
            
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlData, 'text/xml');
            
            const parseError = xmlDoc.getElementsByTagName('parsererror')[0];
            if (parseError) {
                console.error('XML parsing error:', parseError.textContent);
                throw new Error('Failed to parse XML response');
            }
            
            const errorElement = xmlDoc.getElementsByTagName('Error')[0];
            if (errorElement) {
                const errorCode = xmlDoc.getElementsByTagName('Code')[0]?.textContent || 'Unknown';
                const errorMessage = xmlDoc.getElementsByTagName('Message')[0]?.textContent || 'Unknown error';
                throw new Error(`${errorCode}: ${errorMessage}`);
            }
            
            const listBucketResult = xmlDoc.getElementsByTagName('ListBucketResult')[0];
            if (!listBucketResult) {
                console.error('No ListBucketResult found in XML');
                console.error('Available root elements:', xmlDoc.documentElement?.tagName);
                throw new Error('Invalid XML response format');
            }
            
            const contents = xmlDoc.getElementsByTagName('Contents');
            const commonPrefixes = xmlDoc.getElementsByTagName('CommonPrefixes');
            
            console.log(`Found ${contents.length} objects and ${commonPrefixes.length} common prefixes`);
            
            const body = document.getElementById('object-list-body');
            body.innerHTML = '';
            
            let itemCount = 0;
            
            // Display folders first
            for (let i = 0; i < commonPrefixes.length; i++) {
                const prefixElement = commonPrefixes[i].getElementsByTagName('Prefix')[0];
                if (prefixElement) {
                    const folderPrefix = prefixElement.textContent;
                    
                    let folderName = folderPrefix;
                    if (prefix && folderPrefix.startsWith(prefix)) {
                        folderName = folderPrefix.substring(prefix.length);
                    }
                    if (folderName.endsWith('/')) {
                        folderName = folderName.slice(0, -1);
                    }
                    
                    console.log(`Folder ${i+1}: ${folderPrefix} -> ${folderName}`);
                    
                    itemCount++;
                    body.innerHTML += `
                        <tr style="background-color: #f8f9fa;">
                            <td class="column-num">${itemCount}</td>
                            <td class="object-key-cell">
                                <span style="cursor:pointer; font-weight: bold; color: #0066cc;" onclick="showObjectPanel('${bucket}', '${folderPrefix}')">
                                    üìÅ ${folderName}/
                                </span>
                            </td>
                            <td class="center-align">-</td>
                            <td class="center-align">-</td>
                            <td class="center-align">
                                <button onclick="showObjectPanel('${bucket}', '${folderPrefix}')">Open</button>
                                <button onclick="deleteFolder('${bucket}', '${folderPrefix}')">Delete</button>
                            </td>
                            <td class="check-column"><input type="checkbox" name="object-checkbox" value="${folderPrefix}"></td>
                        </tr>
                    `;
                }
            }
            
            // Display files
            for (let i = 0; i < contents.length; i++) {
                const content = contents[i];
                const key = content.getElementsByTagName('Key')[0]?.textContent || '';
                const size = parseInt(content.getElementsByTagName('Size')[0]?.textContent || '0');
                const lastModified = content.getElementsByTagName('LastModified')[0]?.textContent || '';
                
                let displayName = key;
                if (prefix && key.startsWith(prefix)) {
                    displayName = key.substring(prefix.length);
                }
                
                // Decode the display name to show original filename with spaces
                try {
                    displayName = decodeURIComponent(displayName);
                } catch (e) {
                    // If decoding fails, use the original displayName
                    console.warn('Failed to decode filename:', displayName, e);
                }
                
                console.log(`Object ${i+1}: ${key} -> ${displayName} (${size} bytes)`);
                
                itemCount++;
                const encodedKey = encodeURIComponent(key);
                body.innerHTML += `
                    <tr>
                        <td class="column-num">${itemCount}</td>
                        <td class="object-key-cell">
                            <span style="cursor:pointer;" onclick="showObjectDetail('${bucket}','${encodedKey}')">${displayName}</span>
                        </td>
                        <td class="center-align">${formatBytes(size)}</td>
                        <td class="center-align">${formatTime(lastModified)}</td>
                        <td class="center-align">
                            <button onclick="downloadObject('${bucket}','${encodedKey}')">Download</button>
                            <button onclick="deleteObject('${bucket}','${encodedKey}')">Delete</button>
                            <button onclick="generatePresignedURL('${bucket}','${key}')">Share</button>
                        </td>
                        <td class="check-column"><input type="checkbox" name="object-checkbox" value="${key}"></td>
                    </tr>
                `;
            }
            
            if (itemCount === 0) {
                body.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px;">No objects found</td></tr>';
                console.log('No objects or folders found in bucket');
            } else {
                console.log(`Total items displayed: ${itemCount}`);
            }
        })
        .catch(e => {
            console.error('Error fetching objects:', e);
            const body = document.getElementById('object-list-body');
            body.innerHTML = `<tr><td colspan="6" style="text-align: center; padding: 20px; color: red;">Error loading objects: ${e.message}</td></tr>`;
            alert('Error fetching objects: ' + e.message);
        });
}

function hideObjectPanel() {
    document.getElementById('object-panel').style.display = 'none';
    document.getElementById('object-list-body').innerHTML = '';
    document.querySelectorAll('.bucket-name-cell').forEach(el => el.classList.remove('selected'));
    currentBucket = null;
    currentPrefix = "";
}

function deleteFolder(bucket, prefix) {
    if (!confirm(`Delete folder "${prefix}" and ALL its contents?\n\nThis action cannot be undone.`)) return;
    
    console.log(`Deleting folder: ${prefix} from bucket: ${bucket}`);
    showProgressBar();
    
    const url = `/spider/s3/${bucket}?prefix=${encodeURIComponent(prefix)}&ConnectionName=${connConfig}`;
    
    fetch(url)
        .then(response => response.text())
        .then(xmlData => {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlData, 'text/xml');
            const contents = xmlDoc.getElementsByTagName('Contents');
            
            if (contents.length === 0) {
                alert('Folder appears to be empty or already deleted');
                hideProgressBar();
                fetchObjects(bucket, currentPrefix);
                return;
            }
            
            const objectsToDelete = [];
            for (let i = 0; i < contents.length; i++) {
                const key = contents[i].getElementsByTagName('Key')[0]?.textContent;
                if (key) {
                    objectsToDelete.push(key);
                }
            }
            
            console.log(`Found ${objectsToDelete.length} objects to delete in folder ${prefix}`);
            
            const deleteXml = `<?xml version="1.0" encoding="UTF-8"?>
<Delete>
    ${objectsToDelete.map(key => `<Object><Key>${key}</Key></Object>`).join('')}
</Delete>`;
            
            return fetch(`/spider/s3/${bucket}?delete&ConnectionName=${connConfig}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/xml'
                },
                body: deleteXml
            });
        })
        .then(response => {
            hideProgressBar();
            if (response.ok) {
                alert(`Folder "${prefix}" deleted successfully`);
                fetchObjects(bucket, currentPrefix);
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        })
        .catch(e => {
            console.error('Error deleting folder:', e);
            hideProgressBar();
            alert('Error deleting folder: ' + e.message);
        });
}

function deleteObject(bucket, objectKey) {
    // Decode objectKey for display in confirmation dialog
    let displayName = objectKey;
    try {
        displayName = decodeURIComponent(objectKey);
    } catch (e) {
        // If decoding fails, use the original objectKey
        console.warn('Failed to decode objectKey for display:', objectKey, e);
    }
    
    if (!confirm(`Delete object "${displayName}"?`)) {
        return;
    }
    showProgressBar();
    
    // objectKey is already encoded from the server response, use it directly
    fetch(`/spider/s3/${bucket}/${objectKey}?ConnectionName=${connConfig}`, {
        method: 'DELETE'
    })
    .then(response => {
        if (response.ok) {
            fetchObjects(bucket, currentPrefix); 
            hideProgressBar(); 
            uncheckAllCheckboxes('object');
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
    })
    .catch(e => { 
        alert('Error: ' + e.message); 
        hideProgressBar(); 
    });
}

function deleteSelectedObjects() {
    const checked = document.querySelectorAll('input[name="object-checkbox"]:checked');
    if (!checked.length) {
        alert("Select object(s) to delete!");
        return;
    }
    if (!confirm("Delete selected object(s)?")) {
        return;
    }
    showProgressBar();
    
    const objectsXml = Array.from(checked).map(chk => 
        `<Object><Key>${chk.value}</Key></Object>`
    ).join('');
    
    const deleteXml = `<?xml version="1.0" encoding="UTF-8"?>
<Delete>
    ${objectsXml}
</Delete>`;
    
    fetch(`/spider/s3/${currentBucket}?delete&ConnectionName=${connConfig}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/xml'
        },
        body: deleteXml
    })
    .then(response => {
        if (response.ok) {
            fetchObjects(currentBucket, currentPrefix); 
            hideProgressBar(); 
            uncheckAllCheckboxes('object');
        } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
    })
    .catch(e => { 
        alert('Error: ' + e.message); 
        hideProgressBar(); 
    });
}

function uncheckAllCheckboxes(mode) {
    const checkboxes = document.getElementsByName(mode + '-checkbox');
    for (const c of checkboxes) {
        c.checked = false;
    }
    
    const selectAllCheckboxes = document.querySelectorAll(`#${mode}-table thead input[type="checkbox"]`);
    selectAllCheckboxes.forEach(cb => cb.checked = false);
    
    if (mode === 'bucket') {
        const bucketHeaderCheckbox = document.querySelector('.content .header-with-progress .fixed-action-buttons input[type="checkbox"]');
        if (bucketHeaderCheckbox) bucketHeaderCheckbox.checked = false;
    }
    
    if (mode === 'object') {
        const objectPanelCheckbox = document.querySelector('.object-panel-actions input[type="checkbox"]');
        if (objectPanelCheckbox) objectPanelCheckbox.checked = false;
    }
}

function showObjectUploadOverlay() {
    if (!currentBucket) return;
    document.getElementById('upload-bucket-name').innerText = currentBucket;
    document.getElementById('object-upload-overlay').style.display = 'flex';
    document.getElementById('file-input').value = '';
    document.getElementById('selected-files-list').innerHTML = 'No files selected';
    document.getElementById('upload-progress').style.display = 'none';
    document.addEventListener('keydown', handleObjectUploadEsc);
    
    document.getElementById('file-input').addEventListener('change', function(e) {
        const files = e.target.files;
        const fileList = document.getElementById('selected-files-list');
        if (files.length === 0) {
            fileList.innerHTML = 'No files selected';
        } else {
            fileList.innerHTML = '<strong>Selected files:</strong><br>';
            for (let i = 0; i < files.length; i++) {
                fileList.innerHTML += `${i + 1}. ${files[i].name} (${formatBytes(files[i].size)})<br>`;
            }
        }
    });
}

function handleObjectUploadEsc(event) {
    if (event.key === 'Escape') {
        hideObjectUploadOverlay();
    }
}

function hideObjectUploadOverlay() { 
    document.getElementById('object-upload-overlay').style.display = 'none';
    document.getElementById('file-input').value = '';
    document.getElementById('selected-files-list').innerHTML = 'No files selected';
    document.getElementById('upload-progress').style.display = 'none';
    document.getElementById('upload-btn').disabled = false;
    document.removeEventListener('keydown', handleObjectUploadEsc);
}

async function uploadFiles() {
    const files = document.getElementById('file-input').files;
    if (!files.length) return alert('Please select files to upload!');
    
    const uploadBtn = document.getElementById('upload-btn');
    uploadBtn.disabled = true;
    document.getElementById('upload-progress').style.display = 'block';
    
    let successCount = 0;
    let failedFiles = [];
    
    for (let i = 0; i < files.length; i++) {
        const file = files[i];
        document.getElementById('current-file').textContent = file.name;
        document.getElementById('progress-bar-inner').style.width = '0%';
        document.getElementById('progress-text').textContent = `0% (${i + 1}/${files.length})`;
        
        try {
            const response = await uploadWithProgress(`/spider/s3/${currentBucket}?ConnectionName=${connConfig}`, file, file.name, (progress) => {
                document.getElementById('progress-bar-inner').style.width = progress + '%';
                document.getElementById('progress-text').textContent = `${Math.round(progress)}% (${i + 1}/${files.length})`;
            });

            if (!response.ok) {
                let errorMsg = `Upload failed: ${response.statusText} (${response.status})`;
                if (response.responseText) {
                    // Try to extract meaningful error from response
                    if (response.responseText.includes('<Message>')) {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(response.responseText, 'text/xml');
                        const messageElement = xmlDoc.querySelector('Message');
                        if (messageElement) {
                            errorMsg += ` - ${messageElement.textContent}`;
                        }
                    } else if (response.responseText.length < 200) {
                        // Include short response text
                        errorMsg += ` - ${response.responseText}`;
                    }
                }
                throw new Error(errorMsg);
            }

            successCount++;

        } catch (error) {
            failedFiles.push({name: file.name, error: error.message});
        }
    }
    
    uploadBtn.disabled = false;
    
    if (failedFiles.length > 0) {
        let errorMsg = `Upload completed with errors:\n\nSuccessfully uploaded: ${successCount} file(s)\n\nFailed files:\n`;
        failedFiles.forEach(f => {
            errorMsg += `- ${f.name}: ${f.error}\n`;
        });
        alert(errorMsg);
    }
    
    hideObjectUploadOverlay();
    fetchObjects(currentBucket, currentPrefix);
}

function uploadWithProgress(url, file, filename, onProgress) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        const formData = new FormData();
        formData.append('file', file);
        formData.append('key', filename);  // Use 'key' instead of 'filename' as per S3 API spec

        xhr.upload.addEventListener('progress', (e) => {
            if (e.lengthComputable) {
                const percentComplete = (e.loaded / e.total) * 100;
                onProgress(percentComplete);
            }
        });

        xhr.addEventListener('load', () => {
            if (xhr.status >= 200 && xhr.status < 300) {
                resolve({ ok: true, status: xhr.status, statusText: xhr.statusText });
            } else {
                // Include response body for error details
                const responseText = xhr.responseText || xhr.statusText;
                resolve({ 
                    ok: false, 
                    status: xhr.status, 
                    statusText: xhr.statusText,
                    responseText: responseText
                });
            }
        });

        xhr.addEventListener('error', () => {
            reject(new Error('Network error'));
        });

        xhr.addEventListener('timeout', () => reject(new Error('Request timeout')));

        xhr.open('POST', url, true);
        xhr.timeout = 600000;
        xhr.send(formData);
    });
}

function showObjectDetail(bucket, key) {
    showProgressBar();
    
    // key is already encoded from the server response, use it directly
    fetch(`/spider/s3/${bucket}/${key}?ConnectionName=${connConfig}`, {
        method: 'HEAD'
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const size = response.headers.get('Content-Length') || '0';
        const lastModified = response.headers.get('Last-Modified') || '';
        const etag = response.headers.get('ETag') || '';
        const contentType = response.headers.get('Content-Type') || '';
        
        // Decode the key for display purposes
        let displayKey = key;
        try {
            displayKey = decodeURIComponent(key);
        } catch (e) {
            // If decoding fails, use the original key
            console.warn('Failed to decode key for display:', key, e);
        }
        
        document.getElementById('object-detail-key').innerText = displayKey;
        const tbody = document.getElementById('object-detail-body');
        tbody.innerHTML = `
            <tr><th>Key</th><td>${displayKey}</td></tr>
            <tr><th>Size</th><td>${formatBytes(parseInt(size))}</td></tr>
            <tr><th>Last Modified</th><td>${lastModified}</td></tr>
            <tr><th>ETag</th><td>${etag}</td></tr>
            <tr><th>ContentType</th><td>${contentType}</td></tr>
            <tr><th>Actions</th><td>
                <button onclick="downloadObject('${bucket}','${key}')">Download</button>
                <button onclick="generatePresignedURL('${bucket}','${key}')">Share</button>
            </td></tr>
        `;
        document.getElementById('object-detail-overlay').style.display = 'flex';
        document.addEventListener('keydown', handleObjectDetailEsc);
        hideProgressBar();
    })
    .catch(e => { 
        alert('Error: ' + e.message); 
        hideProgressBar(); 
    });
}

function handleObjectDetailEsc(event) {
    if (event.key === 'Escape') {
        hideObjectDetailOverlay();
    }
}

function hideObjectDetailOverlay() { 
    document.getElementById('object-detail-overlay').style.display = 'none';
    document.getElementById('object-detail-body').innerHTML = '';
    document.removeEventListener('keydown', handleObjectDetailEsc);
}

function downloadObject(bucket, key) {
    // key is already encoded from the server response, use it directly
    const url = `/spider/s3/${bucket}/${key}?ConnectionName=${connConfig}`;
    window.open(url, '_blank');
}

function generatePresignedURL(bucket, key) {
    // Decode the key to show the original filename without escape characters
    const decodedKey = decodeURIComponent(key);
    document.getElementById('presigned-object-key').textContent = decodedKey;
    document.getElementById('presigned-url-result').style.display = 'none';
    document.getElementById('presigned-url-overlay').style.display = 'flex';
    document.addEventListener('keydown', handlePresignedURLEsc);
    
    window.currentPresignedContext = { bucket, key };
}

function handlePresignedURLEsc(event) {
    if (event.key === 'Escape') {
        hidePresignedURLOverlay();
    }
}

function hidePresignedURLOverlay() {
    document.getElementById('presigned-url-overlay').style.display = 'none';
    document.getElementById('presigned-url-result').style.display = 'none';
    document.getElementById('expiration-hours').value = '1';
    document.getElementById('presigned-url-text').value = '';
    window.currentPresignedContext = null;
    document.removeEventListener('keydown', handlePresignedURLEsc);
}

async function generatePresignedURLAction() {
    const { bucket, key } = window.currentPresignedContext;
    const hours = parseInt(document.getElementById('expiration-hours').value) || 1;
    const expiresSeconds = hours * 3600;

    try {
        // Decode the key first to get the original key, then encode it properly for URL
        const decodedKey = decodeURIComponent(key);
        const encodedKey = encodeURIComponent(decodedKey);
        
        // Share Object always uses download endpoint (GET method)
        const apiEndpoint = `/spider/s3/presigned/download/${bucket}/${encodedKey}`;
        
        const response = await fetch(`${apiEndpoint}?ConnectionName=${connConfig}&expires=${expiresSeconds}`, {
            headers: {
                'Accept': 'application/xml'
            }
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const xmlText = await response.text();
        
        // Extract PresignedURL using regex to avoid namespace issues
        const urlMatch = xmlText.match(/<PresignedURL>([^<]+)<\/PresignedURL>/);
        const presignedURL = urlMatch ? urlMatch[1] : null;
        
        if (presignedURL) {
            document.getElementById('presigned-url-text').value = presignedURL;
            document.getElementById('presigned-url-result').style.display = 'block';
        } else {
            throw new Error('No presigned URL returned from server');
        }
        
    } catch (error) {
        console.error('Error generating presigned URL:', error);
        alert('Error generating presigned URL: ' + error.message);
    }
}

function copyPresignedURL() {
    const urlText = document.getElementById('presigned-url-text');
    urlText.select();
    urlText.setSelectionRange(0, 99999);
    navigator.clipboard.writeText(urlText.value).then(() => {
        // URL copied successfully - no notification needed
    }).catch(() => {
        alert('Failed to copy URL to clipboard');
    });
}

function showObjectVersions() {
    if (!currentBucket) {
        console.error('No current bucket selected');
        alert('Please select a bucket first');
        return;
    }
    
    console.log(`Opening object versions for bucket: ${currentBucket}`);
    document.getElementById('versions-bucket-name').textContent = currentBucket;
    document.getElementById('object-versions-overlay').style.display = 'flex';
    document.addEventListener('keydown', handleObjectVersionsEsc);
    
    loadObjectVersionsWithActions(currentBucket);
}

function handleObjectVersionsEsc(event) {
    if (event.key === 'Escape') {
        hideObjectVersionsOverlay();
    }
}

function hideObjectVersionsOverlay() {
    document.getElementById('object-versions-overlay').style.display = 'none';
    document.getElementById('object-versions-body').innerHTML = '';
    document.removeEventListener('keydown', handleObjectVersionsEsc);
}

async function loadObjectVersionsWithActions(bucketName) {
    try {
        const url = `/spider/s3/${bucketName}?versions&ConnectionName=${connConfig}`;
        
        const response = await fetch(url);
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const xmlData = await response.text();
        
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlData, 'text/xml');
        
        const parseError = xmlDoc.getElementsByTagName('parsererror')[0];
        if (parseError) {
            throw new Error('Failed to parse XML response');
        }
        
        const listVersionsResult = xmlDoc.getElementsByTagName('ListVersionsResult')[0];
        if (!listVersionsResult) {
            throw new Error('Invalid XML response format - no ListVersionsResult');
        }
        
        const versions = xmlDoc.getElementsByTagName('Version');
        const deleteMarkers = xmlDoc.getElementsByTagName('DeleteMarker');
        
        const tbody = document.getElementById('object-versions-body');
        tbody.innerHTML = '';

        let hasVersions = false;

        for (let i = 0; i < versions.length; i++) {
            const version = versions[i];
            const key = version.getElementsByTagName('Key')[0]?.textContent || '';
            const versionId = version.getElementsByTagName('VersionId')[0]?.textContent || '';
            const size = parseInt(version.getElementsByTagName('Size')[0]?.textContent || '0');
            const lastModified = version.getElementsByTagName('LastModified')[0]?.textContent || '';
            const isLatest = version.getElementsByTagName('IsLatest')[0]?.textContent === 'true';

            hasVersions = true;
            
            // Decode the key for display purposes
            let keyDisplay = key;
            try {
                keyDisplay = decodeURIComponent(key);
            } catch (e) {
                // If decoding fails, use the original key
                console.warn('Failed to decode key for version display:', key, e);
            }
            
            tbody.innerHTML += `
                <tr>
                    <td>${keyDisplay}</td>
                    <td>${versionId}</td>
                    <td>${formatBytes(size)}</td>
                    <td>${formatTime(lastModified)}</td>
                    <td>${isLatest ? 'Yes' : 'No'}</td>
                    <td>
                        ${size > 0 ? `<button onclick="downloadObjectVersion('${bucketName}', '${key.replace(/'/g, "\\'")}', '${versionId}')">Download</button>` : ''}
                        <button onclick="deleteObjectVersion('${bucketName}', '${key.replace(/'/g, "\\'")}', '${versionId}')">Delete</button>
                    </td>
                </tr>
            `;
        }

        for (let i = 0; i < deleteMarkers.length; i++) {
            const marker = deleteMarkers[i];
            const key = marker.getElementsByTagName('Key')[0]?.textContent || '';
            const versionId = marker.getElementsByTagName('VersionId')[0]?.textContent || '';
            const lastModified = marker.getElementsByTagName('LastModified')[0]?.textContent || '';
            const isLatest = marker.getElementsByTagName('IsLatest')[0]?.textContent === 'true';

            const versionIdElement = marker.getElementsByTagName('VersionId')[0];
            let actualVersionId = versionId;
            
            if (versionIdElement) {
                actualVersionId = versionIdElement.textContent || versionIdElement.innerHTML || '';
            }

            hasVersions = true;
            
            // Decode the key for display purposes
            let keyDisplay = key;
            try {
                keyDisplay = decodeURIComponent(key);
            } catch (e) {
                // If decoding fails, use the original key
                console.warn('Failed to decode key for delete marker display:', key, e);
            }
            
            const displayVersionId = actualVersionId || 'null';
            
            tbody.innerHTML += `
                <tr style="background-color: #ffe6e6;">
                    <td>${keyDisplay} (DELETE MARKER)</td>
                    <td>${displayVersionId}</td>
                    <td>-</td>
                    <td>${formatTime(lastModified)}</td>
                    <td>${isLatest ? 'Yes' : 'No'}</td>
                    <td>
                        <button onclick="deleteObjectVersion('${bucketName}', '${key.replace(/'/g, "\\'")}', '${actualVersionId}')">Delete</button>
                    </td>
                </tr>
            `;
        }

        if (!hasVersions) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px;">No versions found</td></tr>';
        }

    } catch (error) {
        const tbody = document.getElementById('object-versions-body');
        tbody.innerHTML = 
            `<tr><td colspan="6" style="text-align: center; padding: 20px; color: red;">
                Error loading versions: ${error.message}
                <br><br>
                <button onclick="loadObjectVersionsWithActions('${bucketName}')" style="margin-top: 10px;">Retry</button>
            </td></tr>`;
        alert('Error loading object versions: ' + error.message);
    }
}

async function deleteObjectVersion(bucketName, objectKey, versionId) {
    if (versionId === null || versionId === undefined) {
        alert('Cannot delete: Version ID is null or undefined');
        return;
    }
    
    const cleanVersionId = String(versionId).trim();
    
    if (cleanVersionId === 'null' || cleanVersionId === 'undefined' || cleanVersionId === '') {
        if (objectKey.includes('DELETE MARKER') || confirm(`Version ID appears to be invalid ('${cleanVersionId}'). This might be a DELETE MARKER. Try to delete anyway?`)) {
            // Continue with deletion
        } else {
            alert('Cannot delete: Invalid version ID');
            return;
        }
    }
    
    if (!confirm(`Delete version ${cleanVersionId.substring(0, 20)}... of object "${objectKey}"?`)) return;
    
    showProgressBar();
    
    try {
        // objectKey is already encoded from the server response, use it directly
        const url = `/spider/s3/${bucketName}/${objectKey}?versionId=${encodeURIComponent(cleanVersionId)}&ConnectionName=${connConfig}`;
        
        const response = await fetch(url, {
            method: 'DELETE',
            headers: {
                'X-Connection-Name': connConfig
            }
        });
        
        hideProgressBar();
        
        if (response.ok) {
            loadObjectVersionsWithActions(bucketName);
        } else {
            const errorText = await response.text();
            
            if (errorText.includes('<?xml') || errorText.includes('<Error>')) {
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(errorText, 'text/xml');
                    const errorCode = xmlDoc.getElementsByTagName('Code')[0]?.textContent || 'Unknown';
                    const errorMessage = xmlDoc.getElementsByTagName('Message')[0]?.textContent || 'Unknown error';
                    throw new Error(`${errorCode}: ${errorMessage}`);
                } catch (parseError) {
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        }
    } catch (error) {
        hideProgressBar();
        alert('Error deleting version: ' + error.message);
    }
}

function downloadObjectVersion(bucket, key, versionId) {
    if (versionId === null || versionId === undefined) {
        alert('Cannot download: Version ID is null or undefined');
        return;
    }
    
    const cleanVersionId = String(versionId).trim();
    
    let downloadUrl;
    if (cleanVersionId && cleanVersionId !== '' && cleanVersionId !== 'undefined') {
        // key is already encoded from the server response, use it directly
        downloadUrl = `/spider/s3/${bucket}/${key}?versionId=${encodeURIComponent(cleanVersionId)}&ConnectionName=${encodeURIComponent(connConfig)}`;
    } else {
        downloadUrl = `/spider/s3/${bucket}/${key}?ConnectionName=${encodeURIComponent(connConfig)}`;
    }
    
    const link = document.createElement('a');
    link.href = downloadUrl;
    link.download = key.split('/').pop() || key;
    link.target = '_blank';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

async function deleteAllVersions(bucketName) {
    if (!confirm(`Delete ALL object versions and delete markers in bucket "${bucketName}"?\n\nThis action cannot be undone!`)) return;
    
    showProgressBar();
    
    try {
        const response = await fetch(`/spider/s3/${bucketName}?versions&ConnectionName=${connConfig}`);
        const xmlData = await response.text();
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlData, 'text/xml');
        
        const versions = xmlDoc.getElementsByTagName('Version');
        const deleteMarkers = xmlDoc.getElementsByTagName('DeleteMarker');
        
        if (versions.length === 0 && deleteMarkers.length === 0) {
            alert('No versions or delete markers to delete');
            hideProgressBar();
            return;
        }
        
        let successCount = 0;
        let failureCount = 0;
        const errors = [];
        
        for (let i = 0; i < versions.length; i++) {
            const version = versions[i];
            const key = version.getElementsByTagName('Key')[0]?.textContent;
            const versionId = version.getElementsByTagName('VersionId')[0]?.textContent;
            
            if (key && versionId) {
                try {
                    // key is already encoded from the server response, use it directly
                    const url = `/spider/s3/${bucketName}/${key}?versionId=${encodeURIComponent(versionId)}&ConnectionName=${connConfig}`;
                    const deleteResponse = await fetch(url, {
                        method: 'DELETE',
                        headers: {
                            'X-Connection-Name': connConfig
                        }
                    });
                    
                    if (deleteResponse.ok) {
                        successCount++;
                    } else {
                        failureCount++;
                        const errorText = await deleteResponse.text();
                        errors.push(`${key} (${versionId}): ${deleteResponse.status} ${deleteResponse.statusText}`);
                    }
                } catch (error) {
                    failureCount++;
                    errors.push(`${key} (${versionId}): ${error.message}`);
                }
            }
        }
        
        for (let i = 0; i < deleteMarkers.length; i++) {
            const marker = deleteMarkers[i];
            const key = marker.getElementsByTagName('Key')[0]?.textContent;
            const versionId = marker.getElementsByTagName('VersionId')[0]?.textContent;
            
            if (key && versionId) {
                try {
                    // key is already encoded from the server response, use it directly
                    const url = `/spider/s3/${bucketName}/${key}?versionId=${encodeURIComponent(versionId)}&ConnectionName=${connConfig}`;
                    const deleteResponse = await fetch(url, {
                        method: 'DELETE',
                        headers: {
                            'X-Connection-Name': connConfig
                        }
                    });
                    
                    if (deleteResponse.ok) {
                        successCount++;
                    } else {
                        failureCount++;
                        const errorText = await deleteResponse.text();
                        errors.push(`${key} (DELETE MARKER - ${versionId}): ${deleteResponse.status} ${deleteResponse.statusText}`);
                    }
                } catch (error) {
                    failureCount++;
                    errors.push(`${key} (DELETE MARKER - ${versionId}): ${error.message}`);
                }
            }
        }
        
        hideProgressBar();
        
        if (failureCount > 0) {
            let message = `Deletion completed with errors:\n\n`;
            message += `Successfully deleted: ${successCount} items\n`;
            message += `Failed to delete: ${failureCount} items\n\n`;
            message += `Errors:\n`;
            errors.slice(0, 10).forEach(error => {
                message += `- ${error}\n`;
            });
            
            if (errors.length > 10) {
                message += `... and ${errors.length - 10} more errors\n`;
            }
            
            alert(message);
        }
        
        loadObjectVersionsWithActions(bucketName);
        
    } catch (error) {
        hideProgressBar();
        alert('Error deleting all versions: ' + error.message);
    }
}

function searchKeyword() {
    const filter = document.getElementById('searchInput').value.trim().toUpperCase();
    highlightRows(document.getElementById('bucket-table'), filter);
    highlightRows(document.getElementById('object-table'), filter);
}

function highlightRows(table, filter) {
    if (!table) return;
    const trs = table.getElementsByTagName('tr');
    for (let i=1; i<trs.length; i++) {
        let found = false;
        for (let j=0; j<trs[i].cells.length; j++) {
            if ((trs[i].cells[j].textContent||'').toUpperCase().indexOf(filter) > -1) found = true;
        }
        trs[i].style.background = found && filter ? '#fffab6' : '';
    }
}

function clearSearchInput() {
    document.getElementById('searchInput').value = '';
    searchKeyword();
}

function toggleSelectAll(source, mode) {
    let checkboxes = [];
    if (mode === 'bucket') checkboxes = document.getElementsByName('bucket-checkbox');
    if (mode === 'object') checkboxes = document.getElementsByName('object-checkbox');
    for (const c of checkboxes) c.checked = source.checked;
}

function formatTime(iso) {
    if (!iso) return '';
    const d = new Date(iso);
    const koreaTime = new Date(d.getTime() + (9 * 60 * 60 * 1000));
    return `${koreaTime.getUTCFullYear()}-${(koreaTime.getUTCMonth()+1).toString().padStart(2,'0')}-${koreaTime.getUTCDate().toString().padStart(2,'0')} ${koreaTime.getUTCHours().toString().padStart(2,'0')}:${koreaTime.getUTCMinutes().toString().padStart(2,'0')}:${koreaTime.getUTCSeconds().toString().padStart(2,'0')} KST`;
}

function formatBytes(bytes) {
    if (!bytes || isNaN(bytes)) return '';
    if (bytes < 1024) return bytes + ' B';
    let kb = bytes/1024;
    if (kb < 1024) return kb.toFixed(1)+' KB';
    let mb = kb/1024;
    if (mb < 1024) return mb.toFixed(1)+' MB';
    let gb = mb/1024;
    return gb.toFixed(1)+' GB';
}

// Upload URL functions
function showUploadURLOverlay() {
    if (!currentBucket) {
        alert('Please select a bucket first');
        return;
    }
    
    document.getElementById('upload-url-bucket-name').textContent = currentBucket;
    document.getElementById('upload-object-key').value = '';
    document.getElementById('upload-expiration-hours').value = '1';
    document.getElementById('upload-url-result').style.display = 'none';
    document.getElementById('upload-url-text').value = '';
    document.getElementById('upload-url-overlay').style.display = 'flex';
    document.addEventListener('keydown', handleUploadURLEsc);
}

function handleUploadURLEsc(event) {
    if (event.key === 'Escape') {
        hideUploadURLOverlay();
    }
}

function hideUploadURLOverlay() {
    document.getElementById('upload-url-overlay').style.display = 'none';
    document.getElementById('upload-url-result').style.display = 'none';
    document.getElementById('upload-object-key').value = '';
    document.getElementById('upload-expiration-hours').value = '1';
    document.getElementById('upload-url-text').value = '';
    document.removeEventListener('keydown', handleUploadURLEsc);
}

async function generateUploadURLAction() {
    const bucket = currentBucket;
    const objectKey = document.getElementById('upload-object-key').value.trim();
    const hours = parseInt(document.getElementById('upload-expiration-hours').value) || 1;
    const expiresSeconds = hours * 3600;

    if (!objectKey) {
        alert('Please enter an object key/filename');
        return;
    }

    try {
        const encodedKey = encodeURIComponent(objectKey);
        const response = await fetch(`/spider/s3/presigned/upload/${bucket}/${encodedKey}?ConnectionName=${connConfig}&expires=${expiresSeconds}`, {
            headers: {
                'Accept': 'application/xml'
            }
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const xmlText = await response.text();
        
        // Extract PresignedURL using regex to avoid namespace issues
        const urlMatch = xmlText.match(/<PresignedURL>([^<]+)<\/PresignedURL>/);
        const presignedURL = urlMatch ? urlMatch[1] : null;
        
        if (presignedURL) {
            document.getElementById('upload-url-text').value = presignedURL;
            document.getElementById('upload-url-result').style.display = 'block';
        } else {
            throw new Error('No presigned URL returned from server');
        }
        
    } catch (error) {
        console.error('Error generating upload URL:', error);
        alert('Error generating upload URL: ' + error.message);
    }
}

function copyUploadURL() {
    const urlText = document.getElementById('upload-url-text');
    urlText.select();
    urlText.setSelectionRange(0, 99999);
    navigator.clipboard.writeText(urlText.value).then(() => {
        // Upload URL copied successfully - no notification needed
    }).catch(() => {
        alert('Failed to copy URL to clipboard');
    });
}

function testUploadURL() {
    const uploadURL = document.getElementById('upload-url-text').value;
    if (!uploadURL) {
        alert('No upload URL generated yet');
        return;
    }
    
    console.log('Testing upload URL:', uploadURL);
    
    // Create a simple test for the upload URL
    const testContent = "This is a test file content generated by CB-Spider AdminWeb";
    const blob = new Blob([testContent], { type: 'text/plain' });
    
    fetch(uploadURL, {
        method: 'PUT',
        body: blob,
        headers: {
            'Content-Type': 'text/plain'
        }
    })
    .then(response => {
        console.log('Upload response status:', response.status);
        console.log('Upload response headers:', [...response.headers.entries()]);
        
        if (response.ok) {
            alert('Test upload successful! Check your S3 bucket.');
            // Refresh the object list
            if (currentBucket) {
                showObjectPanel(currentBucket);
            }
        } else {
            return response.text().then(responseText => {
                console.error('Upload failed response:', responseText);
                throw new Error(`Upload failed with status: ${response.status} - ${responseText || response.statusText}`);
            });
        }
    })
    .catch(error => {
        console.error('Test upload failed:', error);
        
        // Provide more detailed error information
        let errorMessage = 'Test upload failed: ';
        if (error.message.includes('Failed to fetch')) {
            errorMessage += 'Network error or CORS issue. This might be due to:\n';
            errorMessage += '1. CORS not configured for this bucket\n';
            errorMessage += '2. Invalid PreSigned URL\n';
            errorMessage += '3. Network connectivity issue\n\n';
            errorMessage += 'Check browser console for more details.';
        } else {
            errorMessage += error.message;
        }
        
        alert(errorMessage);
    });
}

document.addEventListener('DOMContentLoaded', () => {
    console.log('S3 Manager loaded successfully');
    
    const utcTimeCells = document.querySelectorAll('[data-utc-time]');
    utcTimeCells.forEach(cell => {
        const utcTime = cell.getAttribute('data-utc-time');
        if (utcTime) {
            const formattedTime = formatTime(utcTime);
            cell.textContent = formattedTime;
        }
    });
    
    // Check if there's a saved bucket selection from previous page load
    const savedBucket = sessionStorage.getItem('cb-spider-selected-bucket');
    const savedPrefix = sessionStorage.getItem('cb-spider-selected-prefix');
    
    if (savedBucket) {
        // Clear the saved selection
        sessionStorage.removeItem('cb-spider-selected-bucket');
        sessionStorage.removeItem('cb-spider-selected-prefix');
        
        // Restore the selected bucket
        console.log('Restoring selected bucket:', savedBucket, 'prefix:', savedPrefix);
        showObjectPanel(savedBucket, savedPrefix || '');
    } else {
        // No saved selection, show first bucket as default
        const bucketRows = document.querySelectorAll('#bucket-list-body tr');
        if (bucketRows.length > 0) {
            const firstBucketCell = bucketRows[0].querySelector('.bucket-name-cell span');
            if (firstBucketCell) {
                const bucketName = firstBucketCell.textContent.trim();
                if (bucketName) {
                    showObjectPanel(bucketName);
                }
            }
        }
    }
});
</script>
</body>
</html>